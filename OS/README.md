# 멀티 프로세스 방식과 멀티 스레드 방식의 성능 비교

### 프로세스
------
##### :heavy_check_mark: 멀티 프로세스란?
여러 개의 프로세서를 사용하는 것<br>
같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹 이라고 한다.<br>
##### :heavy_check_mark: 특징
- 각 프로세스는 메모리 영역을 각각 할당
- 각 프로세스는 별도의 주소공간에서 실행
- 프로그램이 운영체제에 의해 메모리에 적재되어 실행되고 있는 상태
- 프로세스의 상태로는 생성, 실행, 준비, 대기, 종료 <br>
### 스레드
------
##### :heavy_check_mark: 멀티 스레드란?
한개의 프로세스 내에 여러개의 스레드를 갖는 방식
##### :heavy_check_mark: 특징
- 프로세스 내에서 스택/레지스터만 각각 할당 받고 나머지 메모리 영역은 공유
- 스레드는 한 기능을 수행하는 독립적인 단위로써 최소한의 메모리 영역(스택)은 각각 할당해야 독립적으로 수행이 가능<br>

### 프로그램 알고리즘
------
프로세스 / 스레드를 1~64개를 생성 후 각 프로세스/스레드가 loop을 돌며 공유메모리 / 전역변수에 접근하는 데 동기화 문제를 해결하며 1000만의 약수를 구하는 프로그램
<br>
:heavy_check_mark: 시간 측정 방법 :
- time()함수 이용
- tms 구조체의 stime,utime,cstime,cutime을 이용<br>
:heavy_check_mark: 프로세스 :
- 공유 메모리 : shmget을 이용
- 동기화 문제 : semaphore를 이용<br>
:heavy_check_mark: 스레드 :
- 공유 메모리 : 전역변수를 이용
- 동기화 문제 : binary semaphore인 mutex 이용
### 실행 결과
------
:heavy_check_mark: 멀티 프로세스
- 10번 실행 결과의 평균 값

| 프로세스 | 1개 | 2개 | 4개 | 8개 | 16개 | 32개 | 64개 |
|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **Real Time** | 0.63 | 3.959 | 7.266 | 7.719 | 7.28 | 7.368 | 7.501 |
| **User Time** | 0.62 | 2.095 | 2.596 | 1.733 | 0.835 | 0.423 | 0.222 |
| **Sys  Time** | 0 | 1.781 | 4.213 | 5.461 | 6.253 | 3.22 | 1.634 |

![image02](https://user-images.githubusercontent.com/52964858/84995443-fad1aa00-b186-11ea-8fa3-71f48f0d594a.png)

:heavy_check_mark: 멀티 스레드
- 10번 실행 결과의 평균 값

| 스레드 | 1개 | 2개 | 4개 | 8개 | 16개 | 32개 | 64개 |
|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **Real Time** | 0.331 | 1.339 | 2.142 | 2.1 | 2.041 | 1.938 | 1.949 |
| **User Time** | 0.327 | 1.701 | 3.384 | 3.854 | 3.789 | 3.501 | 3.59 |
| **Sys  Time** | 0 | 0.952 | 4.315 | 11.722 | 27.475 | 27.102 | 27.419 |

![3](https://user-images.githubusercontent.com/52964858/84995446-fb6a4080-b186-11ea-9b49-ed6d2c6101a6.png)


멀티 스레드 방식의 경우 sytemtime과 usertime의 시간을 구할때 tms구조체의 ctime,utime 객체를 사용하게 되면 스레드 개수의 곱으로 시간이 나오게 된다.<br>
그래서 오히려 real time보다 높게 나오는 일이 발생하게 된다. <br>
따라서 user time과 system time을 스레드 개수로 나누어 보았다.

| 스레드 | 1개 | 2개 | 4개 | 8개 | 16개 | 32개 | 64개 |
|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **User Time/스레드 개수** | 0.850 | 0.846 | 0.481 | 0.236 | 0.218 | 0.218 | 0.224 |
| **Sys  Time/스레드 개수** | 0 | 0.476 | 1.078 | 1.465 | 1.717 | 1.693 | 1.713 |

![image01](https://user-images.githubusercontent.com/52964858/84995441-fad1aa00-b186-11ea-94f0-4bb6b1d326c1.png)

해당 실험환경조건이 한번에 동작가능한 스레드 개수가 16개이기 때문에 스레드 개수 32/64개의 time은 16으로 나누어 주었다.<br>
나눈값의 그래프를 보니 systime이 위의 그래프와 비슷한 그림을 그리는 것을 볼 수 있다.

![4](https://user-images.githubusercontent.com/52964858/84995437-f9a07d00-b186-11ea-84e1-b1d15eca474e.png)

"결과 : " 1000만의 약수를 구하는 과정에서 많은 동기화 문제때문에 오버헤드가 크게 발생하여 오히려 스레드/프로세스 개수가 늘어나도 처리 속도는
빨라지지 않고 더 느려지는 것을 볼 수가 있었고 한 번에 동작 가능한 프로세스/스레드 개수가 정해져 있어(메모리에 로드 되어있으며 대기할 수 있는) 일정 개수 이후로는 시간이 계속 증가되지 않고 비슷하게 유지됨을 볼 수 있다.
해당 알고리즘(프로그램 주제)의 경우에는 멀티 프로세스가 멀티 스레드 방식보다 오버헤드가 크게 발생하여 더 시간이 느린 것을 볼 수 있었다.
