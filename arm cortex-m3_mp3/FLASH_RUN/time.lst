   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"time.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.time_from_seconds,"ax",%progbits
  16              		.align	1
  17              		.global	time_from_seconds
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	time_from_seconds:
  25              	.LVL0:
  26              	.LFB29:
  27              		.file 1 "time.c"
   1:time.c        **** /********************************************************************************/
   2:time.c        **** /* time.c                                                                       */
   3:time.c        **** /* STM32F10X                                                                    */
   4:time.c        **** /*(Lee ChangWoo HL2IRW  hl2irw@kpu.ac.kr 011-726-6860)                          */
   5:time.c        **** /* stm_start                                                                    */
   6:time.c        **** /********************************************************************************/
   7:time.c        **** #include "hwdefs.h"
   8:time.c        **** #include "fundefs.h"
   9:time.c        **** 
  10:time.c        **** volatile unsigned int now_time;
  11:time.c        **** volatile unsigned char time_rtc_flag;
  12:time.c        **** const unsigned char month_length[12] = {31,29,31,30,31,30,31,31,30,31,30,31};
  13:time.c        **** extern volatile unsigned short jiffes;
  14:time.c        **** typedef enum {false, true} bool;
  15:time.c        **** bool time_update=true;
  16:time.c        **** long Cyear,month,day,hour,min,sec;
  17:time.c        **** 
  18:time.c        **** 
  19:time.c        **** void time_from_seconds (time_rtc *ptime, unsigned int ul_seconds)
  20:time.c        **** {
  28              		.loc 1 20 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  21:time.c        ****       long year, idx = 0;
  32              		.loc 1 21 7 view .LVU1
  22:time.c        ****       // Extract the number of seconds from the time.
  23:time.c        ****       ptime->sec = ul_seconds % 60;
  33              		.loc 1 23 7 view .LVU2
  34              		.loc 1 23 31 is_stmt 0 view .LVU3
  35 0000 3C23     		movs	r3, #60
  36 0002 B1FBF3F2 		udiv	r2, r1, r3
  37 0006 03FB1211 		mls	r1, r3, r2, r1
  38              	.LVL1:
  39              		.loc 1 23 18 view .LVU4
  40 000a 8171     		strb	r1, [r0, #6]
  24:time.c        ****       ul_seconds /= 60;
  41              		.loc 1 24 7 is_stmt 1 view .LVU5
  42              	.LVL2:
  25:time.c        ****       // Extract the number of minutes from the time.
  26:time.c        ****       ptime->min = ul_seconds % 60;
  43              		.loc 1 26 7 view .LVU6
  44              		.loc 1 26 31 is_stmt 0 view .LVU7
  45 000c B2FBF3F1 		udiv	r1, r2, r3
  46 0010 03FB1123 		mls	r3, r3, r1, r2
  27:time.c        ****       ul_seconds /= 60;
  28:time.c        ****       // Extract the number of hours from the time.
  29:time.c        ****       ptime->hour = ul_seconds % 24;
  47              		.loc 1 29 32 view .LVU8
  48 0014 1822     		movs	r2, #24
  49              	.LVL3:
  26:time.c        ****       ul_seconds /= 60;
  50              		.loc 1 26 18 view .LVU9
  51 0016 4371     		strb	r3, [r0, #5]
  27:time.c        ****       ul_seconds /= 60;
  52              		.loc 1 27 7 is_stmt 1 view .LVU10
  53              	.LVL4:
  54              		.loc 1 29 7 view .LVU11
  55              		.loc 1 29 32 is_stmt 0 view .LVU12
  56 0018 B1FBF2F3 		udiv	r3, r1, r2
  57 001c 02FB1312 		mls	r2, r2, r3, r1
  58              		.loc 1 29 19 view .LVU13
  59 0020 0271     		strb	r2, [r0, #4]
  30:time.c        ****       ul_seconds /= 24;
  60              		.loc 1 30 7 is_stmt 1 view .LVU14
  61              	.LVL5:
  31:time.c        ****       // We now have days, so add the number of days between January 1, 1900 and
  32:time.c        ****       // January 1, 1970.
  33:time.c        ****       ul_seconds += (70 * 365) + 18;
  62              		.loc 1 33 7 view .LVU15
  63              		.loc 1 33 18 is_stmt 0 view .LVU16
  64 0022 03F5C742 		add	r2, r3, #25472
  34:time.c        ****       // The day of the week just happens to work out this way.
  35:time.c        ****       ptime->wday = ul_seconds % 7;
  65              		.loc 1 35 32 view .LVU17
  66 0026 0723     		movs	r3, #7
  67              	.LVL6:
  33:time.c        ****       // The day of the week just happens to work out this way.
  68              		.loc 1 33 18 view .LVU18
  69 0028 6032     		adds	r2, r2, #96
  70              	.LVL7:
  71              		.loc 1 35 7 is_stmt 1 view .LVU19
  72              		.loc 1 35 32 is_stmt 0 view .LVU20
  73 002a B2FBF3F3 		udiv	r3, r2, r3
  20:time.c        ****       long year, idx = 0;
  74              		.loc 1 20 1 view .LVU21
  75 002e 30B5     		push	{r4, r5, lr}
  76              		.cfi_def_cfa_offset 12
  77              		.cfi_offset 4, -12
  78              		.cfi_offset 5, -8
  79              		.cfi_offset 14, -4
  36:time.c        ****       // Compute the number of years in terms of group of years from leap year to
  37:time.c        ****       // leap year.
  38:time.c        ****       year = 4 * (ul_seconds / ((365 * 4) + 1));
  80              		.loc 1 38 30 view .LVU22
  81 0030 40F2B554 		movw	r4, #1461
  35:time.c        ****       // Compute the number of years in terms of group of years from leap year to
  82              		.loc 1 35 32 view .LVU23
  83 0034 C3EBC303 		rsb	r3, r3, r3, lsl #3
  84 0038 D31A     		subs	r3, r2, r3
  35:time.c        ****       // Compute the number of years in terms of group of years from leap year to
  85              		.loc 1 35 19 view .LVU24
  86 003a C371     		strb	r3, [r0, #7]
  87              		.loc 1 38 7 is_stmt 1 view .LVU25
  88              		.loc 1 38 30 is_stmt 0 view .LVU26
  89 003c B2FBF4F3 		udiv	r3, r2, r4
  90              		.loc 1 38 16 view .LVU27
  91 0040 9900     		lsls	r1, r3, #2
  92              	.LVL8:
  39:time.c        ****       ul_seconds %= (365 * 4) + 1;
  93              		.loc 1 39 7 is_stmt 1 view .LVU28
  94              		.loc 1 39 18 is_stmt 0 view .LVU29
  95 0042 04FB1323 		mls	r3, r4, r3, r2
  96              	.LVL9:
  40:time.c        ****       // If there are more than 365 days left in the current count of days, then
  41:time.c        ****       // subtract the days from the remaining non-leap years.
  42:time.c        ****       if (ul_seconds >= 366) {
  97              		.loc 1 42 7 is_stmt 1 view .LVU30
  98              		.loc 1 42 10 is_stmt 0 view .LVU31
  99 0046 B3F5B77F 		cmp	r3, #366
  43:time.c        ****          year += (ul_seconds - 1) / 365;
 100              		.loc 1 43 35 view .LVU32
 101 004a 23BF     		ittte	cs
 102 004c 40F26D15 		movwcs	r5, #365
 103              		.loc 1 43 30 view .LVU33
 104 0050 03F1FF33 		addcs	r3, r3, #-1
 105              	.LVL10:
 106              		.loc 1 43 35 view .LVU34
 107 0054 B3FBF5F4 		udivcs	r4, r3, r5
 108              	.LVL11:
  38:time.c        ****       ul_seconds %= (365 * 4) + 1;
 109              		.loc 1 38 12 view .LVU35
 110 0058 0A46     		movcc	r2, r1
 111              	.LVL12:
 112              		.loc 1 43 10 is_stmt 1 view .LVU36
 113              		.loc 1 43 15 is_stmt 0 view .LVU37
 114 005a 28BF     		it	cs
 115 005c 6218     		addcs	r2, r4, r1
 116              	.LVL13:
  44:time.c        ****          ul_seconds = (ul_seconds - 1) % 365;
 117              		.loc 1 44 10 is_stmt 1 view .LVU38
  45:time.c        ****       }
  46:time.c        ****       // Save the computed year.
  47:time.c        ****       ptime->year = 1900 + year;
 118              		.loc 1 47 26 is_stmt 0 view .LVU39
 119 005e 02F26C71 		addw	r1, r2, #1900
  44:time.c        ****          ul_seconds = (ul_seconds - 1) % 365;
 120              		.loc 1 44 21 view .LVU40
 121 0062 28BF     		it	cs
 122 0064 05FB1433 		mlscs	r3, r5, r4, r3
 123              	.LVL14:
 124              		.loc 1 47 7 is_stmt 1 view .LVU41
  48:time.c        ****       // If this is a non-leap year and the day is past February 28th, then
  49:time.c        ****       // increment the count of days by one (i.e. act as if each year is a leap
  50:time.c        ****       // year).
  51:time.c        ****       if (((year & 3) != 0) && (ul_seconds >= (31 + 28))) {
 125              		.loc 1 51 10 is_stmt 0 view .LVU42
 126 0068 9207     		lsls	r2, r2, #30
 127              	.LVL15:
  47:time.c        ****       // If this is a non-leap year and the day is past February 28th, then
 128              		.loc 1 47 19 view .LVU43
 129 006a 0180     		strh	r1, [r0]	@ movhi
 130              		.loc 1 51 7 is_stmt 1 view .LVU44
 131              		.loc 1 51 10 is_stmt 0 view .LVU45
 132 006c 02D0     		beq	.L4
 133              		.loc 1 51 29 discriminator 1 view .LVU46
 134 006e 3A2B     		cmp	r3, #58
  52:time.c        ****          ul_seconds++;
 135              		.loc 1 52 10 is_stmt 1 discriminator 1 view .LVU47
 136              		.loc 1 52 20 is_stmt 0 discriminator 1 view .LVU48
 137 0070 88BF     		it	hi
 138 0072 0133     		addhi	r3, r3, #1
 139              	.LVL16:
 140              	.L4:
  20:time.c        ****       long year, idx = 0;
 141              		.loc 1 20 1 view .LVU49
 142 0074 0022     		movs	r2, #0
 143 0076 064C     		ldr	r4, .L10
 144              	.LVL17:
 145              	.L5:
  53:time.c        ****       }
  54:time.c        ****       // Subtract days for each month till we find the current month.
  55:time.c        ****       while (ul_seconds >= month_length[idx]) {
 146              		.loc 1 55 13 is_stmt 1 view .LVU50
 147              		.loc 1 55 40 is_stmt 0 view .LVU51
 148 0078 14F8011B 		ldrb	r1, [r4], #1	@ zero_extendqisi2
 149 007c 0132     		adds	r2, r2, #1
 150              		.loc 1 55 13 view .LVU52
 151 007e 9942     		cmp	r1, r3
 152 0080 03D9     		bls	.L6
  56:time.c        ****             ul_seconds -= month_length[idx++];
  57:time.c        ****       }
  58:time.c        ****       // Save the computed month and day.
  59:time.c        ****       ptime->day = ul_seconds + 1;
 153              		.loc 1 59 7 is_stmt 1 view .LVU53
 154              		.loc 1 59 31 is_stmt 0 view .LVU54
 155 0082 0133     		adds	r3, r3, #1
 156              	.LVL18:
 157              		.loc 1 59 18 view .LVU55
 158 0084 C370     		strb	r3, [r0, #3]
  60:time.c        ****       ptime->month = idx + 1;
 159              		.loc 1 60 7 is_stmt 1 view .LVU56
 160              		.loc 1 60 20 is_stmt 0 view .LVU57
 161 0086 8270     		strb	r2, [r0, #2]
  61:time.c        **** }
 162              		.loc 1 61 1 view .LVU58
 163 0088 30BD     		pop	{r4, r5, pc}
 164              	.LVL19:
 165              	.L6:
  56:time.c        ****             ul_seconds -= month_length[idx++];
 166              		.loc 1 56 13 is_stmt 1 view .LVU59
  56:time.c        ****             ul_seconds -= month_length[idx++];
 167              		.loc 1 56 24 is_stmt 0 view .LVU60
 168 008a 5B1A     		subs	r3, r3, r1
 169              	.LVL20:
  56:time.c        ****             ul_seconds -= month_length[idx++];
 170              		.loc 1 56 24 view .LVU61
 171 008c F4E7     		b	.L5
 172              	.L11:
 173 008e 00BF     		.align	2
 174              	.L10:
 175 0090 00000000 		.word	.LANCHOR0
 176              		.cfi_endproc
 177              	.LFE29:
 179              		.section	.text.time_to_seconds,"ax",%progbits
 180              		.align	1
 181              		.global	time_to_seconds
 182              		.syntax unified
 183              		.thumb
 184              		.thumb_func
 185              		.fpu softvfp
 187              	time_to_seconds:
 188              	.LVL21:
 189              	.LFB30:
  62:time.c        **** 
  63:time.c        **** 
  64:time.c        **** 
  65:time.c        **** void time_to_seconds (time_rtc *ptime, unsigned int *pul_seconds)
  66:time.c        **** {
 190              		.loc 1 66 1 is_stmt 1 view -0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
  67:time.c        ****       long idx;
 194              		.loc 1 67 7 view .LVU63
  68:time.c        ****       // Compute the number of days that have past in this year.
  69:time.c        ****       *pul_seconds = ptime->day - 1;
 195              		.loc 1 69 7 view .LVU64
  66:time.c        ****       long idx;
 196              		.loc 1 66 1 is_stmt 0 view .LVU65
 197 0000 70B5     		push	{r4, r5, r6, lr}
 198              		.cfi_def_cfa_offset 16
 199              		.cfi_offset 4, -16
 200              		.cfi_offset 5, -12
 201              		.cfi_offset 6, -8
 202              		.cfi_offset 14, -4
 203              		.loc 1 69 27 view .LVU66
 204 0002 C378     		ldrb	r3, [r0, #3]	@ zero_extendqisi2
  70:time.c        ****       idx = ptime->month - 1;
  71:time.c        ****       while (idx--) {
  72:time.c        ****             *pul_seconds += month_length[idx];
 205              		.loc 1 72 41 view .LVU67
 206 0004 1E4E     		ldr	r6, .L20
  69:time.c        ****       idx = ptime->month - 1;
 207              		.loc 1 69 33 view .LVU68
 208 0006 013B     		subs	r3, r3, #1
  69:time.c        ****       idx = ptime->month - 1;
 209              		.loc 1 69 20 view .LVU69
 210 0008 0B60     		str	r3, [r1]
  70:time.c        ****       idx = ptime->month - 1;
 211              		.loc 1 70 7 is_stmt 1 view .LVU70
  70:time.c        ****       idx = ptime->month - 1;
 212              		.loc 1 70 18 is_stmt 0 view .LVU71
 213 000a 8478     		ldrb	r4, [r0, #2]	@ zero_extendqisi2
  70:time.c        ****       idx = ptime->month - 1;
 214              		.loc 1 70 11 view .LVU72
 215 000c 621E     		subs	r2, r4, #1
 216              	.LVL22:
  71:time.c        ****             *pul_seconds += month_length[idx];
 217              		.loc 1 71 7 is_stmt 1 view .LVU73
 218              	.L13:
  71:time.c        ****             *pul_seconds += month_length[idx];
 219              		.loc 1 71 13 view .LVU74
  71:time.c        ****             *pul_seconds += month_length[idx];
 220              		.loc 1 71 17 is_stmt 0 view .LVU75
 221 000e 013A     		subs	r2, r2, #1
 222              	.LVL23:
  71:time.c        ****             *pul_seconds += month_length[idx];
 223              		.loc 1 71 13 view .LVU76
 224 0010 551C     		adds	r5, r2, #1
 225 0012 0B68     		ldr	r3, [r1]
 226 0014 2FD1     		bne	.L14
  73:time.c        ****       }
  74:time.c        ****       // If this is a non-leap year and the day is past February 28th, then
  75:time.c        ****       // subtract the count of days by one (since we treat each year as if it
  76:time.c        ****       // were a leap year).
  77:time.c        ****       if (((ptime->year & 3) != 0) && (*pul_seconds >= (31 + 28))) {
 227              		.loc 1 77 7 is_stmt 1 view .LVU77
 228              		.loc 1 77 18 is_stmt 0 view .LVU78
 229 0016 B0F90020 		ldrsh	r2, [r0]
 230              	.LVL24:
 231              		.loc 1 77 10 view .LVU79
 232 001a 9607     		lsls	r6, r2, #30
 233 001c 04D0     		beq	.L15
 234              		.loc 1 77 36 discriminator 1 view .LVU80
 235 001e 3A2B     		cmp	r3, #58
  78:time.c        ****          (*pul_seconds)--;
 236              		.loc 1 78 10 is_stmt 1 discriminator 1 view .LVU81
 237              		.loc 1 78 24 is_stmt 0 discriminator 1 view .LVU82
 238 0020 84BF     		itt	hi
 239 0022 03F1FF33 		addhi	r3, r3, #-1
 240 0026 0B60     		strhi	r3, [r1]
 241              	.L15:
  79:time.c        ****       }
  80:time.c        ****       // Add the days for the years that have past.
  81:time.c        ****       idx = ptime->year - 1970;
 242              		.loc 1 81 7 is_stmt 1 view .LVU83
 243              	.LVL25:
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 244              		.loc 1 82 7 view .LVU84
  83:time.c        ****       // Convert the days to hours and add the current hour.
  84:time.c        ****       *pul_seconds = (*pul_seconds * 24) + ptime->hour;
 245              		.loc 1 84 7 view .LVU85
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 246              		.loc 1 82 28 is_stmt 0 view .LVU86
 247 0028 40F26D13 		movw	r3, #365
  81:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 248              		.loc 1 81 11 view .LVU87
 249 002c A2F2B275 		subw	r5, r2, #1970
 250              	.LVL26:
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 251              		.loc 1 82 28 view .LVU88
 252 0030 6B43     		muls	r3, r5, r3
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 253              		.loc 1 82 43 view .LVU89
 254 0032 6FF4F665 		mvn	r5, #1968
 255              	.LVL27:
 256              		.loc 1 84 42 view .LVU90
 257 0036 1826     		movs	r6, #24
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 258              		.loc 1 82 43 view .LVU91
 259 0038 5519     		adds	r5, r2, r5
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 260              		.loc 1 82 48 view .LVU92
 261 003a 002D     		cmp	r5, #0
 262 003c B8BF     		it	lt
 263 003e A2F2AE75 		subwlt	r5, r2, #1966
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 264              		.loc 1 82 35 view .LVU93
 265 0042 03EBA503 		add	r3, r3, r5, asr #2
  82:time.c        ****       *pul_seconds += (idx * 365) + ((idx + 1) / 4);
 266              		.loc 1 82 20 view .LVU94
 267 0046 0D68     		ldr	r5, [r1]
 268 0048 2B44     		add	r3, r3, r5
 269              		.loc 1 84 49 view .LVU95
 270 004a 0579     		ldrb	r5, [r0, #4]	@ zero_extendqisi2
 271              		.loc 1 84 42 view .LVU96
 272 004c 06FB0353 		mla	r3, r6, r3, r5
  85:time.c        **** 	  hour=(*pul_seconds);
 273              		.loc 1 85 4 is_stmt 1 view .LVU97
 274              		.loc 1 85 8 is_stmt 0 view .LVU98
 275 0050 0C4D     		ldr	r5, .L20+4
  86:time.c        ****       // Convert the hours to minutes and add the current minute.
  87:time.c        ****       *pul_seconds = (*pul_seconds * 60) + ptime->min;
 276              		.loc 1 87 49 view .LVU99
 277 0052 4679     		ldrb	r6, [r0, #5]	@ zero_extendqisi2
  85:time.c        **** 	  hour=(*pul_seconds);
 278              		.loc 1 85 8 view .LVU100
 279 0054 2B60     		str	r3, [r5]
 280              		.loc 1 87 7 is_stmt 1 view .LVU101
 281              		.loc 1 87 36 is_stmt 0 view .LVU102
 282 0056 3C25     		movs	r5, #60
 283              		.loc 1 87 42 view .LVU103
 284 0058 05FB0363 		mla	r3, r5, r3, r6
  88:time.c        **** 	  min=(*pul_seconds);
 285              		.loc 1 88 4 is_stmt 1 view .LVU104
  89:time.c        ****       // Convert the minutes to seconds and add the current second.
  90:time.c        ****       *pul_seconds = (*pul_seconds * 60) + ptime->sec;
 286              		.loc 1 90 49 is_stmt 0 view .LVU105
 287 005c 8079     		ldrb	r0, [r0, #6]	@ zero_extendqisi2
 288              	.LVL28:
  88:time.c        **** 	  min=(*pul_seconds);
 289              		.loc 1 88 7 view .LVU106
 290 005e 0A4E     		ldr	r6, .L20+8
 291 0060 3360     		str	r3, [r6]
 292              		.loc 1 90 7 is_stmt 1 view .LVU107
 293              		.loc 1 90 42 is_stmt 0 view .LVU108
 294 0062 05FB0303 		mla	r3, r5, r3, r0
 295              		.loc 1 90 20 view .LVU109
 296 0066 0B60     		str	r3, [r1]
  91:time.c        **** 	  sec=(*pul_seconds);
 297              		.loc 1 91 4 is_stmt 1 view .LVU110
 298              		.loc 1 91 7 is_stmt 0 view .LVU111
 299 0068 0849     		ldr	r1, .L20+12
 300              	.LVL29:
 301              		.loc 1 91 7 view .LVU112
 302 006a 0B60     		str	r3, [r1]
  92:time.c        **** 	  month=ptime->month;
 303              		.loc 1 92 4 is_stmt 1 view .LVU113
 304              		.loc 1 92 9 is_stmt 0 view .LVU114
 305 006c 084B     		ldr	r3, .L20+16
 306 006e 1C60     		str	r4, [r3]
  93:time.c        **** 	  Cyear=ptime->year;
 307              		.loc 1 93 4 is_stmt 1 view .LVU115
 308              		.loc 1 93 9 is_stmt 0 view .LVU116
 309 0070 084B     		ldr	r3, .L20+20
 310 0072 1A60     		str	r2, [r3]
  94:time.c        **** }
 311              		.loc 1 94 1 view .LVU117
 312 0074 70BD     		pop	{r4, r5, r6, pc}
 313              	.LVL30:
 314              	.L14:
  72:time.c        ****       }
 315              		.loc 1 72 13 is_stmt 1 view .LVU118
  72:time.c        ****       }
 316              		.loc 1 72 41 is_stmt 0 view .LVU119
 317 0076 955D     		ldrb	r5, [r2, r6]	@ zero_extendqisi2
  72:time.c        ****       }
 318              		.loc 1 72 26 view .LVU120
 319 0078 2B44     		add	r3, r3, r5
 320 007a 0B60     		str	r3, [r1]
 321 007c C7E7     		b	.L13
 322              	.L21:
 323 007e 00BF     		.align	2
 324              	.L20:
 325 0080 00000000 		.word	.LANCHOR0
 326 0084 00000000 		.word	hour
 327 0088 00000000 		.word	min
 328 008c 00000000 		.word	sec
 329 0090 00000000 		.word	month
 330 0094 00000000 		.word	Cyear
 331              		.cfi_endproc
 332              	.LFE30:
 334              		.section	.text.RTC_IRQHandler,"ax",%progbits
 335              		.align	1
 336              		.global	RTC_IRQHandler
 337              		.syntax unified
 338              		.thumb
 339              		.thumb_func
 340              		.fpu softvfp
 342              	RTC_IRQHandler:
 343              	.LFB31:
  95:time.c        **** 
  96:time.c        **** 
  97:time.c        **** void RTC_IRQHandler (void)
  98:time.c        **** {
 344              		.loc 1 98 1 is_stmt 1 view -0
 345              		.cfi_startproc
 346              		@ args = 0, pretend = 0, frame = 0
 347              		@ frame_needed = 0, uses_anonymous_args = 0
  99:time.c        ****       if (RTC_GetITStatus(RTC_IT_SEC) != RESET) {
 348              		.loc 1 99 7 view .LVU122
  98:time.c        ****       if (RTC_GetITStatus(RTC_IT_SEC) != RESET) {
 349              		.loc 1 98 1 is_stmt 0 view .LVU123
 350 0000 08B5     		push	{r3, lr}
 351              		.cfi_def_cfa_offset 8
 352              		.cfi_offset 3, -8
 353              		.cfi_offset 14, -4
 354              		.loc 1 99 11 view .LVU124
 355 0002 0120     		movs	r0, #1
 356 0004 FFF7FEFF 		bl	RTC_GetITStatus
 357              	.LVL31:
 358              		.loc 1 99 10 view .LVU125
 359 0008 48B1     		cbz	r0, .L22
 100:time.c        ****       	 RTC_ClearITPendingBit(RTC_IT_SEC);
 360              		.loc 1 100 9 is_stmt 1 view .LVU126
 361 000a 0120     		movs	r0, #1
 362 000c FFF7FEFF 		bl	RTC_ClearITPendingBit
 363              	.LVL32:
 101:time.c        ****       	 time_rtc_flag = 1;
 364              		.loc 1 101 9 view .LVU127
 365              		.loc 1 101 23 is_stmt 0 view .LVU128
 366 0010 0122     		movs	r2, #1
 367 0012 034B     		ldr	r3, .L24
 368 0014 1A70     		strb	r2, [r3]
 102:time.c        ****       	 RTC_WaitForLastTask();
 369              		.loc 1 102 9 is_stmt 1 view .LVU129
 103:time.c        ****       }
 104:time.c        **** }
 370              		.loc 1 104 1 is_stmt 0 view .LVU130
 371 0016 BDE80840 		pop	{r3, lr}
 372              		.cfi_remember_state
 373              		.cfi_restore 14
 374              		.cfi_restore 3
 375              		.cfi_def_cfa_offset 0
 102:time.c        ****       	 RTC_WaitForLastTask();
 376              		.loc 1 102 9 view .LVU131
 377 001a FFF7FEBF 		b	RTC_WaitForLastTask
 378              	.LVL33:
 379              	.L22:
 380              		.cfi_restore_state
 381              		.loc 1 104 1 view .LVU132
 382 001e 08BD     		pop	{r3, pc}
 383              	.L25:
 384              		.align	2
 385              	.L24:
 386 0020 00000000 		.word	time_rtc_flag
 387              		.cfi_endproc
 388              	.LFE31:
 390              		.section	.text.set_time,"ax",%progbits
 391              		.align	1
 392              		.global	set_time
 393              		.syntax unified
 394              		.thumb
 395              		.thumb_func
 396              		.fpu softvfp
 398              	set_time:
 399              	.LVL34:
 400              	.LFB32:
 105:time.c        **** 
 106:time.c        **** 
 107:time.c        **** void set_time (time_rtc *p_time)
 108:time.c        **** {
 401              		.loc 1 108 1 is_stmt 1 view -0
 402              		.cfi_startproc
 403              		@ args = 0, pretend = 0, frame = 8
 404              		@ frame_needed = 0, uses_anonymous_args = 0
 109:time.c        ****       unsigned int real_time_second;
 405              		.loc 1 109 7 view .LVU134
 110:time.c        ****       time_to_seconds(p_time,&real_time_second);
 406              		.loc 1 110 7 view .LVU135
 108:time.c        ****       unsigned int real_time_second;
 407              		.loc 1 108 1 is_stmt 0 view .LVU136
 408 0000 07B5     		push	{r0, r1, r2, lr}
 409              		.cfi_def_cfa_offset 16
 410              		.cfi_offset 14, -4
 411              		.loc 1 110 7 view .LVU137
 412 0002 01A9     		add	r1, sp, #4
 413 0004 FFF7FEFF 		bl	time_to_seconds
 414              	.LVL35:
 111:time.c        ****       /* Wait until last write operation on RTC registers has finished */
 112:time.c        ****       RTC_WaitForLastTask();
 415              		.loc 1 112 7 is_stmt 1 view .LVU138
 416 0008 FFF7FEFF 		bl	RTC_WaitForLastTask
 417              	.LVL36:
 113:time.c        ****       /* Change the current time */
 114:time.c        ****       RTC_SetCounter(real_time_second);
 418              		.loc 1 114 7 view .LVU139
 419 000c 0198     		ldr	r0, [sp, #4]
 420 000e FFF7FEFF 		bl	RTC_SetCounter
 421              	.LVL37:
 115:time.c        ****       /* Wait until last write operation on RTC registers has finished */
 116:time.c        ****       RTC_WaitForLastTask();
 422              		.loc 1 116 7 view .LVU140
 423 0012 FFF7FEFF 		bl	RTC_WaitForLastTask
 424              	.LVL38:
 117:time.c        **** 	  //time_display();
 118:time.c        **** 	  
 119:time.c        **** }
 425              		.loc 1 119 1 is_stmt 0 view .LVU141
 426 0016 03B0     		add	sp, sp, #12
 427              		.cfi_def_cfa_offset 4
 428              		@ sp needed
 429 0018 5DF804FB 		ldr	pc, [sp], #4
 430              		.cfi_endproc
 431              	.LFE32:
 433              		.section	.text.check_rtc,"ax",%progbits
 434              		.align	1
 435              		.global	check_rtc
 436              		.syntax unified
 437              		.thumb
 438              		.thumb_func
 439              		.fpu softvfp
 441              	check_rtc:
 442              	.LFB33:
 120:time.c        **** 
 121:time.c        **** 
 122:time.c        **** void check_rtc (void)
 123:time.c        **** {
 443              		.loc 1 123 1 is_stmt 1 view -0
 444              		.cfi_startproc
 445              		@ args = 0, pretend = 0, frame = 8
 446              		@ frame_needed = 0, uses_anonymous_args = 0
 124:time.c        ****       time_rtc n_time;
 447              		.loc 1 124 7 view .LVU143
 125:time.c        ****       now_time = RTC_GetCounter();
 448              		.loc 1 125 7 view .LVU144
 123:time.c        ****       time_rtc n_time;
 449              		.loc 1 123 1 is_stmt 0 view .LVU145
 450 0000 07B5     		push	{r0, r1, r2, lr}
 451              		.cfi_def_cfa_offset 16
 452              		.cfi_offset 14, -4
 453              		.loc 1 125 18 view .LVU146
 454 0002 FFF7FEFF 		bl	RTC_GetCounter
 455              	.LVL39:
 456              		.loc 1 125 16 view .LVU147
 457 0006 0D4B     		ldr	r3, .L29
 458 0008 1860     		str	r0, [r3]
 126:time.c        ****       time_from_seconds(&n_time,now_time);
 459              		.loc 1 126 7 is_stmt 1 view .LVU148
 460 000a 1968     		ldr	r1, [r3]
 461 000c 6846     		mov	r0, sp
 462 000e FFF7FEFF 		bl	time_from_seconds
 463              	.LVL40:
 127:time.c        ****       if ((n_time.year < 2000) || (n_time.year > 2100)) {
 464              		.loc 1 127 7 view .LVU149
 465              		.loc 1 127 32 is_stmt 0 view .LVU150
 466 0012 BDF80030 		ldrh	r3, [sp]
 467 0016 A3F5FA63 		sub	r3, r3, #2000
 468              		.loc 1 127 10 view .LVU151
 469 001a 9BB2     		uxth	r3, r3
 470 001c 642B     		cmp	r3, #100
 471 001e 0AD9     		bls	.L27
 128:time.c        ****          n_time.sec = 0;
 472              		.loc 1 128 10 is_stmt 1 view .LVU152
 129:time.c        ****          n_time.min = 0;
 473              		.loc 1 129 10 view .LVU153
 130:time.c        ****          n_time.hour = 12;
 474              		.loc 1 130 10 view .LVU154
 131:time.c        ****          n_time.day = 1;
 475              		.loc 1 131 10 view .LVU155
 132:time.c        ****          n_time.month = 1;
 476              		.loc 1 132 10 view .LVU156
 133:time.c        ****          n_time.year = 2016;
 477              		.loc 1 133 10 view .LVU157
 478              		.loc 1 133 22 is_stmt 0 view .LVU158
 479 0020 074B     		ldr	r3, .L29+4
 134:time.c        ****       	 set_time(&n_time);
 480              		.loc 1 134 9 view .LVU159
 481 0022 6846     		mov	r0, sp
 133:time.c        ****          n_time.year = 2016;
 482              		.loc 1 133 22 view .LVU160
 483 0024 0093     		str	r3, [sp]
 130:time.c        ****          n_time.day = 1;
 484              		.loc 1 130 22 view .LVU161
 485 0026 0C23     		movs	r3, #12
 486 0028 ADF80430 		strh	r3, [sp, #4]	@ movhi
 128:time.c        ****          n_time.min = 0;
 487              		.loc 1 128 21 view .LVU162
 488 002c 0023     		movs	r3, #0
 489 002e 8DF80630 		strb	r3, [sp, #6]
 490              		.loc 1 134 9 is_stmt 1 view .LVU163
 491 0032 FFF7FEFF 		bl	set_time
 492              	.LVL41:
 493              	.L27:
 135:time.c        ****       }
 136:time.c        **** }
 494              		.loc 1 136 1 is_stmt 0 view .LVU164
 495 0036 03B0     		add	sp, sp, #12
 496              		.cfi_def_cfa_offset 4
 497              		@ sp needed
 498 0038 5DF804FB 		ldr	pc, [sp], #4
 499              	.L30:
 500              		.align	2
 501              	.L29:
 502 003c 00000000 		.word	now_time
 503 0040 E0070101 		.word	16844768
 504              		.cfi_endproc
 505              	.LFE33:
 507              		.section	.rodata.time_display.str1.1,"aMS",%progbits,1
 508              	.LC0:
 509 0000 20253464 		.ascii	" %4d-%.2d-%.2d \000"
 509      2D252E32 
 509      642D252E 
 509      32642000 
 510              		.section	.text.time_display,"ax",%progbits
 511              		.align	1
 512              		.global	time_display
 513              		.syntax unified
 514              		.thumb
 515              		.thumb_func
 516              		.fpu softvfp
 518              	time_display:
 519              	.LFB34:
 137:time.c        **** 
 138:time.c        **** void time_display (void)
 139:time.c        **** {
 520              		.loc 1 139 1 is_stmt 1 view -0
 521              		.cfi_startproc
 522              		@ args = 0, pretend = 0, frame = 0
 523              		@ frame_needed = 0, uses_anonymous_args = 0
 140:time.c        **** 	long old_hour=0,old_min=0,old_sec=0;
 524              		.loc 1 140 2 view .LVU166
 525              	.LVL42:
 141:time.c        **** 	unsigned char dh,dl;
 526              		.loc 1 141 2 view .LVU167
 142:time.c        **** 	if ((old_sec != sec) || (time_update)) {
 527              		.loc 1 142 2 view .LVU168
 528              		.loc 1 142 15 is_stmt 0 view .LVU169
 529 0000 364B     		ldr	r3, .L58
 139:time.c        **** 	long old_hour=0,old_min=0,old_sec=0;
 530              		.loc 1 139 1 view .LVU170
 531 0002 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 532              		.cfi_def_cfa_offset 32
 533              		.cfi_offset 4, -20
 534              		.cfi_offset 5, -16
 535              		.cfi_offset 6, -12
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 14, -4
 538 0004 364C     		ldr	r4, .L58+4
 539              		.loc 1 142 15 view .LVU171
 540 0006 1D68     		ldr	r5, [r3]
 541 0008 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 542              		.loc 1 142 5 view .LVU172
 543 000a 0DB9     		cbnz	r5, .L32
 544              		.loc 1 142 23 discriminator 1 view .LVU173
 545 000c 002A     		cmp	r2, #0
 546 000e 61D0     		beq	.L33
 547              	.L32:
 143:time.c        **** 	   old_sec = sec;
 548              		.loc 1 143 5 is_stmt 1 view .LVU174
 549              	.LVL43:
 144:time.c        **** 	   dh = (old_sec / 10) + 0x30;
 550              		.loc 1 144 5 view .LVU175
 551              		.loc 1 144 19 is_stmt 0 view .LVU176
 552 0010 0A21     		movs	r1, #10
 553 0012 95FBF1F3 		sdiv	r3, r5, r1
 145:time.c        **** 	   dl = (old_sec % 10) + 0x30;
 554              		.loc 1 145 19 view .LVU177
 555 0016 01FB1355 		mls	r5, r1, r3, r5
 556              	.LVL44:
 144:time.c        **** 	   dh = (old_sec / 10) + 0x30;
 557              		.loc 1 144 8 view .LVU178
 558 001a 03F13006 		add	r6, r3, #48
 559              		.loc 1 145 8 view .LVU179
 560 001e 3035     		adds	r5, r5, #48
 144:time.c        **** 	   dh = (old_sec / 10) + 0x30;
 561              		.loc 1 144 8 view .LVU180
 562 0020 F6B2     		uxtb	r6, r6
 563              	.LVL45:
 564              		.loc 1 145 5 is_stmt 1 view .LVU181
 565              		.loc 1 145 8 is_stmt 0 view .LVU182
 566 0022 EDB2     		uxtb	r5, r5
 567              	.LVL46:
 146:time.c        **** 	   if (time_update) put_engxy(17,0,':');
 568              		.loc 1 146 5 is_stmt 1 view .LVU183
 569              		.loc 1 146 8 is_stmt 0 view .LVU184
 570 0024 22B1     		cbz	r2, .L34
 571              		.loc 1 146 22 is_stmt 1 discriminator 1 view .LVU185
 572 0026 3A22     		movs	r2, #58
 573 0028 0021     		movs	r1, #0
 574 002a 1120     		movs	r0, #17
 575 002c FFF7FEFF 		bl	put_engxy
 576              	.LVL47:
 577              	.L34:
 147:time.c        **** 	   put_engxy(18,0,dh);
 578              		.loc 1 147 5 view .LVU186
 579 0030 3246     		mov	r2, r6
 580 0032 0021     		movs	r1, #0
 581 0034 1220     		movs	r0, #18
 582 0036 FFF7FEFF 		bl	put_engxy
 583              	.LVL48:
 148:time.c        **** 	   put_engxy(19,0,dl);
 584              		.loc 1 148 5 view .LVU187
 585 003a 2A46     		mov	r2, r5
 586 003c 0021     		movs	r1, #0
 587 003e 1320     		movs	r0, #19
 588 0040 FFF7FEFF 		bl	put_engxy
 589              	.LVL49:
 149:time.c        **** 	   if ((old_min != min) || (time_update)) {
 590              		.loc 1 149 5 view .LVU188
 591              		.loc 1 149 18 is_stmt 0 view .LVU189
 592 0044 274B     		ldr	r3, .L58+8
 593 0046 1D68     		ldr	r5, [r3]
 594              	.LVL50:
 595              		.loc 1 149 8 view .LVU190
 596 0048 15B9     		cbnz	r5, .L35
 597              		.loc 1 149 26 discriminator 1 view .LVU191
 598 004a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 599 004c 002B     		cmp	r3, #0
 600 004e 41D0     		beq	.L33
 601              	.L35:
 150:time.c        **** 	   	  old_min = min;
 602              		.loc 1 150 8 is_stmt 1 view .LVU192
 603              	.LVL51:
 151:time.c        **** 	      dh = (old_min / 10) + 0x30;
 604              		.loc 1 151 8 view .LVU193
 605              		.loc 1 151 22 is_stmt 0 view .LVU194
 606 0050 0A22     		movs	r2, #10
 607 0052 95FBF2F3 		sdiv	r3, r5, r2
 152:time.c        **** 	      dl = (old_min % 10) + 0x30;
 608              		.loc 1 152 22 view .LVU195
 609 0056 02FB1355 		mls	r5, r2, r3, r5
 610              	.LVL52:
 151:time.c        **** 	      dh = (old_min / 10) + 0x30;
 611              		.loc 1 151 11 view .LVU196
 612 005a 03F13006 		add	r6, r3, #48
 613              	.LVL53:
 153:time.c        **** 	      if (time_update) put_engxy(14,0,':');
 614              		.loc 1 153 11 view .LVU197
 615 005e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 152:time.c        **** 	      dl = (old_min % 10) + 0x30;
 616              		.loc 1 152 11 view .LVU198
 617 0060 3035     		adds	r5, r5, #48
 151:time.c        **** 	      dh = (old_min / 10) + 0x30;
 618              		.loc 1 151 11 view .LVU199
 619 0062 F6B2     		uxtb	r6, r6
 620              	.LVL54:
 152:time.c        **** 	      dl = (old_min % 10) + 0x30;
 621              		.loc 1 152 8 is_stmt 1 view .LVU200
 152:time.c        **** 	      dl = (old_min % 10) + 0x30;
 622              		.loc 1 152 11 is_stmt 0 view .LVU201
 623 0064 EDB2     		uxtb	r5, r5
 624              	.LVL55:
 625              		.loc 1 153 8 is_stmt 1 view .LVU202
 626              		.loc 1 153 11 is_stmt 0 view .LVU203
 627 0066 23B1     		cbz	r3, .L37
 628              		.loc 1 153 25 is_stmt 1 discriminator 1 view .LVU204
 629 0068 3A22     		movs	r2, #58
 630 006a 0021     		movs	r1, #0
 631 006c 0E20     		movs	r0, #14
 632 006e FFF7FEFF 		bl	put_engxy
 633              	.LVL56:
 634              	.L37:
 154:time.c        **** 	      put_engxy(15,0,dh);
 635              		.loc 1 154 8 view .LVU205
 636 0072 3246     		mov	r2, r6
 637 0074 0021     		movs	r1, #0
 638 0076 0F20     		movs	r0, #15
 639 0078 FFF7FEFF 		bl	put_engxy
 640              	.LVL57:
 155:time.c        **** 	      put_engxy(16,0,dl);
 641              		.loc 1 155 8 view .LVU206
 642 007c 2A46     		mov	r2, r5
 643 007e 0021     		movs	r1, #0
 644 0080 1020     		movs	r0, #16
 645 0082 FFF7FEFF 		bl	put_engxy
 646              	.LVL58:
 156:time.c        **** 	      if ((old_hour != hour) || (time_update)) {
 647              		.loc 1 156 8 view .LVU207
 648              		.loc 1 156 22 is_stmt 0 view .LVU208
 649 0086 184B     		ldr	r3, .L58+12
 650 0088 1E68     		ldr	r6, [r3]
 651              	.LVL59:
 652              		.loc 1 156 11 view .LVU209
 653 008a 0EB9     		cbnz	r6, .L38
 654              		.loc 1 156 31 discriminator 1 view .LVU210
 655 008c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 656 008e 0BB3     		cbz	r3, .L33
 657              	.L38:
 157:time.c        **** 	         old_hour = hour;
 658              		.loc 1 157 11 is_stmt 1 view .LVU211
 659              	.LVL60:
 158:time.c        **** 	         dh = (old_hour / 10) + 0x30;
 660              		.loc 1 158 11 view .LVU212
 159:time.c        **** 	         dl = (old_hour % 10) + 0x30;
 661              		.loc 1 159 11 view .LVU213
 160:time.c        **** 	         put_engxy(12,0,dh);
 662              		.loc 1 160 11 view .LVU214
 158:time.c        **** 	         dh = (old_hour / 10) + 0x30;
 663              		.loc 1 158 26 is_stmt 0 view .LVU215
 664 0090 0A27     		movs	r7, #10
 665 0092 96FBF7F5 		sdiv	r5, r6, r7
 158:time.c        **** 	         dh = (old_hour / 10) + 0x30;
 666              		.loc 1 158 14 view .LVU216
 667 0096 05F13002 		add	r2, r5, #48
 668              		.loc 1 160 11 view .LVU217
 669 009a 0021     		movs	r1, #0
 670 009c 0C20     		movs	r0, #12
 671 009e D2B2     		uxtb	r2, r2
 672 00a0 FFF7FEFF 		bl	put_engxy
 673              	.LVL61:
 161:time.c        **** 	         put_engxy(13,0,dl);
 674              		.loc 1 161 11 is_stmt 1 view .LVU218
 159:time.c        **** 	         dl = (old_hour % 10) + 0x30;
 675              		.loc 1 159 26 is_stmt 0 view .LVU219
 676 00a4 07FB1562 		mls	r2, r7, r5, r6
 159:time.c        **** 	         dl = (old_hour % 10) + 0x30;
 677              		.loc 1 159 14 view .LVU220
 678 00a8 3032     		adds	r2, r2, #48
 679              		.loc 1 161 11 view .LVU221
 680 00aa 0021     		movs	r1, #0
 681 00ac 0D20     		movs	r0, #13
 682 00ae D2B2     		uxtb	r2, r2
 683 00b0 FFF7FEFF 		bl	put_engxy
 684              	.LVL62:
 162:time.c        **** 		  	 if ((old_hour == 0) || (time_update)) {
 685              		.loc 1 162 7 is_stmt 1 view .LVU222
 686              		.loc 1 162 10 is_stmt 0 view .LVU223
 687 00b4 0EB1     		cbz	r6, .L39
 688              		.loc 1 162 27 discriminator 1 view .LVU224
 689 00b6 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 690 00b8 63B1     		cbz	r3, .L33
 691              	.LVL63:
 692              	.L39:
 163:time.c        **** 		  	 	lcd_printf(0,0," %4d-%.2d-%.2d ",Cyear,month,day);
 693              		.loc 1 163 8 is_stmt 1 view .LVU225
 694 00ba 0021     		movs	r1, #0
 695 00bc 0B4B     		ldr	r3, .L58+16
 696 00be 0846     		mov	r0, r1
 697 00c0 1B68     		ldr	r3, [r3]
 698 00c2 0B4A     		ldr	r2, .L58+20
 699 00c4 0193     		str	r3, [sp, #4]
 700 00c6 0B4B     		ldr	r3, .L58+24
 701 00c8 1B68     		ldr	r3, [r3]
 702 00ca 0093     		str	r3, [sp]
 703 00cc 0A4B     		ldr	r3, .L58+28
 704 00ce 1B68     		ldr	r3, [r3]
 705 00d0 FFF7FEFF 		bl	lcd_printf
 706              	.LVL64:
 707              	.L33:
 164:time.c        **** 		     }
 165:time.c        **** 	      }				
 166:time.c        ****        }
 167:time.c        **** 	}
 168:time.c        ****     time_update = false;	
 708              		.loc 1 168 5 view .LVU226
 709              		.loc 1 168 17 is_stmt 0 view .LVU227
 710 00d4 0023     		movs	r3, #0
 711 00d6 2370     		strb	r3, [r4]
 169:time.c        **** }
 712              		.loc 1 169 1 view .LVU228
 713 00d8 03B0     		add	sp, sp, #12
 714              		.cfi_def_cfa_offset 20
 715              		@ sp needed
 716 00da F0BD     		pop	{r4, r5, r6, r7, pc}
 717              	.L59:
 718              		.align	2
 719              	.L58:
 720 00dc 00000000 		.word	sec
 721 00e0 00000000 		.word	.LANCHOR1
 722 00e4 00000000 		.word	min
 723 00e8 00000000 		.word	hour
 724 00ec 00000000 		.word	day
 725 00f0 00000000 		.word	.LC0
 726 00f4 00000000 		.word	month
 727 00f8 00000000 		.word	Cyear
 728              		.cfi_endproc
 729              	.LFE34:
 731              		.section	.text.setup_rtc,"ax",%progbits
 732              		.align	1
 733              		.global	setup_rtc
 734              		.syntax unified
 735              		.thumb
 736              		.thumb_func
 737              		.fpu softvfp
 739              	setup_rtc:
 740              	.LFB35:
 170:time.c        **** void setup_rtc (void)
 171:time.c        **** {
 741              		.loc 1 171 1 is_stmt 1 view -0
 742              		.cfi_startproc
 743              		@ args = 0, pretend = 0, frame = 0
 744              		@ frame_needed = 0, uses_anonymous_args = 0
 172:time.c        ****       /* Enable PWR and BKP clocks */
 173:time.c        ****       RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 745              		.loc 1 173 7 view .LVU230
 171:time.c        ****       /* Enable PWR and BKP clocks */
 746              		.loc 1 171 1 is_stmt 0 view .LVU231
 747 0000 10B5     		push	{r4, lr}
 748              		.cfi_def_cfa_offset 8
 749              		.cfi_offset 4, -8
 750              		.cfi_offset 14, -4
 751              		.loc 1 173 7 view .LVU232
 752 0002 0121     		movs	r1, #1
 753 0004 4FF0C050 		mov	r0, #402653184
 754 0008 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 755              	.LVL65:
 174:time.c        ****       /* Allow access to BKP Domain */
 175:time.c        ****       PWR_BackupAccessCmd(ENABLE);
 756              		.loc 1 175 7 is_stmt 1 view .LVU233
 757 000c 0120     		movs	r0, #1
 758 000e FFF7FEFF 		bl	PWR_BackupAccessCmd
 759              	.LVL66:
 176:time.c        ****       /* Reset Backup Domain */
 177:time.c        ****       BKP_DeInit();
 760              		.loc 1 177 7 view .LVU234
 761 0012 FFF7FEFF 		bl	BKP_DeInit
 762              	.LVL67:
 178:time.c        ****       /* Enable LSE */
 179:time.c        ****       RCC_LSEConfig(RCC_LSE_ON);
 763              		.loc 1 179 7 view .LVU235
 764 0016 0120     		movs	r0, #1
 765 0018 FFF7FEFF 		bl	RCC_LSEConfig
 766              	.LVL68:
 180:time.c        ****       /* Wait till LSE is ready */
 181:time.c        ****       jiffes = 0;
 767              		.loc 1 181 7 view .LVU236
 768              		.loc 1 181 14 is_stmt 0 view .LVU237
 769 001c 0023     		movs	r3, #0
 770 001e 154C     		ldr	r4, .L66
 771 0020 2380     		strh	r3, [r4]	@ movhi
 182:time.c        ****       while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) {
 772              		.loc 1 182 7 is_stmt 1 view .LVU238
 773              	.L62:
 774              		.loc 1 182 13 view .LVU239
 775              		.loc 1 182 14 is_stmt 0 view .LVU240
 776 0022 4120     		movs	r0, #65
 777 0024 FFF7FEFF 		bl	RCC_GetFlagStatus
 778              	.LVL69:
 779              		.loc 1 182 13 view .LVU241
 780 0028 D8B1     		cbz	r0, .L63
 183:time.c        ****             if (jiffes) {
 184:time.c        ****                jiffes = 0;
 185:time.c        ****                /* Reload IWDG counter */
 186:time.c        ****                IWDG_ReloadCounter();
 187:time.c        ****             }
 188:time.c        ****       }
 189:time.c        ****       /* Select LSE as RTC Clock Source */
 190:time.c        ****       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
 781              		.loc 1 190 7 is_stmt 1 view .LVU242
 782 002a 4FF48070 		mov	r0, #256
 783 002e FFF7FEFF 		bl	RCC_RTCCLKConfig
 784              	.LVL70:
 191:time.c        ****       /* Enable RTC Clock */
 192:time.c        ****       RCC_RTCCLKCmd(ENABLE);
 785              		.loc 1 192 7 view .LVU243
 786 0032 0120     		movs	r0, #1
 787 0034 FFF7FEFF 		bl	RCC_RTCCLKCmd
 788              	.LVL71:
 193:time.c        ****       /* Wait for RTC registers synchronization */
 194:time.c        ****       RTC_WaitForSynchro();
 789              		.loc 1 194 7 view .LVU244
 790 0038 FFF7FEFF 		bl	RTC_WaitForSynchro
 791              	.LVL72:
 195:time.c        ****       /* Wait until last write operation on RTC registers has finished */
 196:time.c        ****       RTC_WaitForLastTask();
 792              		.loc 1 196 7 view .LVU245
 793 003c FFF7FEFF 		bl	RTC_WaitForLastTask
 794              	.LVL73:
 197:time.c        ****       /* Wait until last write operation on RTC registers has finished */
 198:time.c        ****       RTC_WaitForLastTask();
 795              		.loc 1 198 7 view .LVU246
 796 0040 FFF7FEFF 		bl	RTC_WaitForLastTask
 797              	.LVL74:
 199:time.c        ****       /* Set RTC prescaler: set RTC period to 1sec */
 200:time.c        ****       RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
 798              		.loc 1 200 7 view .LVU247
 799 0044 47F6FF70 		movw	r0, #32767
 800 0048 FFF7FEFF 		bl	RTC_SetPrescaler
 801              	.LVL75:
 201:time.c        ****       /* Wait until last write operation on RTC registers has finished */
 202:time.c        ****       RTC_WaitForLastTask();
 802              		.loc 1 202 7 view .LVU248
 803 004c FFF7FEFF 		bl	RTC_WaitForLastTask
 804              	.LVL76:
 203:time.c        ****       check_rtc();
 805              		.loc 1 203 7 view .LVU249
 806 0050 FFF7FEFF 		bl	check_rtc
 807              	.LVL77:
 204:time.c        ****       BKP_WriteBackupRegister(BKP_DR1,0x0408);
 808              		.loc 1 204 7 view .LVU250
 205:time.c        **** }
 809              		.loc 1 205 1 is_stmt 0 view .LVU251
 810 0054 BDE81040 		pop	{r4, lr}
 811              		.cfi_remember_state
 812              		.cfi_restore 14
 813              		.cfi_restore 4
 814              		.cfi_def_cfa_offset 0
 204:time.c        ****       BKP_WriteBackupRegister(BKP_DR1,0x0408);
 815              		.loc 1 204 7 view .LVU252
 816 0058 4FF48161 		mov	r1, #1032
 817 005c 0420     		movs	r0, #4
 818 005e FFF7FEBF 		b	BKP_WriteBackupRegister
 819              	.LVL78:
 820              	.L63:
 821              		.cfi_restore_state
 183:time.c        ****                jiffes = 0;
 822              		.loc 1 183 13 is_stmt 1 view .LVU253
 183:time.c        ****                jiffes = 0;
 823              		.loc 1 183 17 is_stmt 0 view .LVU254
 824 0062 2388     		ldrh	r3, [r4]
 825 0064 9BB2     		uxth	r3, r3
 183:time.c        ****                jiffes = 0;
 826              		.loc 1 183 16 view .LVU255
 827 0066 002B     		cmp	r3, #0
 828 0068 DBD0     		beq	.L62
 184:time.c        ****                /* Reload IWDG counter */
 829              		.loc 1 184 16 is_stmt 1 view .LVU256
 184:time.c        ****                /* Reload IWDG counter */
 830              		.loc 1 184 23 is_stmt 0 view .LVU257
 831 006a 2080     		strh	r0, [r4]	@ movhi
 186:time.c        ****             }
 832              		.loc 1 186 16 is_stmt 1 view .LVU258
 833 006c FFF7FEFF 		bl	IWDG_ReloadCounter
 834              	.LVL79:
 835 0070 D7E7     		b	.L62
 836              	.L67:
 837 0072 00BF     		.align	2
 838              	.L66:
 839 0074 00000000 		.word	jiffes
 840              		.cfi_endproc
 841              	.LFE35:
 843              		.section	.text.init_rtc,"ax",%progbits
 844              		.align	1
 845              		.global	init_rtc
 846              		.syntax unified
 847              		.thumb
 848              		.thumb_func
 849              		.fpu softvfp
 851              	init_rtc:
 852              	.LFB36:
 206:time.c        **** 
 207:time.c        **** 
 208:time.c        **** void init_rtc (void)
 209:time.c        **** {
 853              		.loc 1 209 1 view -0
 854              		.cfi_startproc
 855              		@ args = 0, pretend = 0, frame = 8
 856              		@ frame_needed = 0, uses_anonymous_args = 0
 210:time.c        ****       NVIC_InitTypeDef NVIC_InitStructure;
 857              		.loc 1 210 7 view .LVU260
 211:time.c        ****       /* Configure and enable RTC interrupt */
 212:time.c        ****       NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
 858              		.loc 1 212 7 view .LVU261
 213:time.c        ****       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
 859              		.loc 1 213 7 view .LVU262
 214:time.c        ****       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 860              		.loc 1 214 7 view .LVU263
 209:time.c        ****       NVIC_InitTypeDef NVIC_InitStructure;
 861              		.loc 1 209 1 is_stmt 0 view .LVU264
 862 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 863              		.cfi_def_cfa_offset 24
 864              		.cfi_offset 4, -12
 865              		.cfi_offset 5, -8
 866              		.cfi_offset 14, -4
 212:time.c        ****       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
 867              		.loc 1 212 42 view .LVU265
 868 0002 40F20333 		movw	r3, #771
 215:time.c        ****       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 869              		.loc 1 215 45 view .LVU266
 870 0006 0125     		movs	r5, #1
 214:time.c        ****       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 871              		.loc 1 214 53 view .LVU267
 872 0008 0024     		movs	r4, #0
 216:time.c        ****       NVIC_Init(&NVIC_InitStructure);
 873              		.loc 1 216 7 view .LVU268
 874 000a 6846     		mov	r0, sp
 212:time.c        ****       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
 875              		.loc 1 212 42 view .LVU269
 876 000c ADF80030 		strh	r3, [sp]	@ movhi
 214:time.c        ****       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 877              		.loc 1 214 53 view .LVU270
 878 0010 8DF80240 		strb	r4, [sp, #2]
 215:time.c        ****       NVIC_Init(&NVIC_InitStructure);
 879              		.loc 1 215 7 is_stmt 1 view .LVU271
 215:time.c        ****       NVIC_Init(&NVIC_InitStructure);
 880              		.loc 1 215 45 is_stmt 0 view .LVU272
 881 0014 0195     		str	r5, [sp, #4]
 882              		.loc 1 216 7 is_stmt 1 view .LVU273
 883 0016 FFF7FEFF 		bl	NVIC_Init
 884              	.LVL80:
 217:time.c        **** 	  /* Enable PWR and BKP clocks */
 218:time.c        ****       RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 885              		.loc 1 218 7 view .LVU274
 886 001a 2946     		mov	r1, r5
 887 001c 4FF0C050 		mov	r0, #402653184
 888 0020 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 889              	.LVL81:
 219:time.c        ****       PWR_BackupAccessCmd(ENABLE);
 890              		.loc 1 219 7 view .LVU275
 891 0024 2846     		mov	r0, r5
 892 0026 FFF7FEFF 		bl	PWR_BackupAccessCmd
 893              	.LVL82:
 220:time.c        ****       BKP_ClearFlag();
 894              		.loc 1 220 7 view .LVU276
 895 002a FFF7FEFF 		bl	BKP_ClearFlag
 896              	.LVL83:
 221:time.c        ****       if (BKP_ReadBackupRegister(BKP_DR1) != (unsigned short)0x0408) {
 897              		.loc 1 221 7 view .LVU277
 898              		.loc 1 221 11 is_stmt 0 view .LVU278
 899 002e 0420     		movs	r0, #4
 900 0030 FFF7FEFF 		bl	BKP_ReadBackupRegister
 901              	.LVL84:
 902              		.loc 1 221 10 view .LVU279
 903 0034 B0F5816F 		cmp	r0, #1032
 904 0038 17D0     		beq	.L69
 222:time.c        ****          setup_rtc();
 905              		.loc 1 222 10 is_stmt 1 view .LVU280
 906 003a FFF7FEFF 		bl	setup_rtc
 907              	.LVL85:
 223:time.c        ****          BKP_TamperPinCmd(DISABLE);
 908              		.loc 1 223 10 view .LVU281
 909 003e 2046     		mov	r0, r4
 910 0040 FFF7FEFF 		bl	BKP_TamperPinCmd
 911              	.LVL86:
 224:time.c        ****          BKP_ITConfig(DISABLE);
 912              		.loc 1 224 10 view .LVU282
 913 0044 2046     		mov	r0, r4
 914 0046 FFF7FEFF 		bl	BKP_ITConfig
 915              	.LVL87:
 225:time.c        ****          BKP_ClearFlag();
 916              		.loc 1 225 10 view .LVU283
 917 004a FFF7FEFF 		bl	BKP_ClearFlag
 918              	.LVL88:
 226:time.c        ****          BKP_WriteBackupRegister(BKP_DR1,0x0408);
 919              		.loc 1 226 10 view .LVU284
 920 004e 4FF48161 		mov	r1, #1032
 921 0052 0420     		movs	r0, #4
 922 0054 FFF7FEFF 		bl	BKP_WriteBackupRegister
 923              	.LVL89:
 924              	.L70:
 227:time.c        ****       } else {
 228:time.c        ****       	 RTC_WaitForSynchro();
 229:time.c        ****       }
 230:time.c        ****       PWR_BackupAccessCmd(DISABLE);
 925              		.loc 1 230 7 view .LVU285
 926 0058 0020     		movs	r0, #0
 927 005a FFF7FEFF 		bl	PWR_BackupAccessCmd
 928              	.LVL90:
 231:time.c        ****       /* Enable the RTC Second */
 232:time.c        ****       RTC_ITConfig(RTC_IT_SEC, ENABLE);
 929              		.loc 1 232 7 view .LVU286
 930 005e 0121     		movs	r1, #1
 931 0060 0846     		mov	r0, r1
 932 0062 FFF7FEFF 		bl	RTC_ITConfig
 933              	.LVL91:
 233:time.c        **** }...
 934              		.loc 1 233 1 is_stmt 0 view .LVU287
 935 0066 03B0     		add	sp, sp, #12
 936              		.cfi_remember_state
 937              		.cfi_def_cfa_offset 12
 938              		@ sp needed
 939 0068 30BD     		pop	{r4, r5, pc}
 940              	.L69:
 941              		.cfi_restore_state
 228:time.c        ****       	 RTC_WaitForSynchro();
 942              		.loc 1 228 9 is_stmt 1 view .LVU288
 943 006a FFF7FEFF 		bl	RTC_WaitForSynchro
 944              	.LVL92:
 945 006e F3E7     		b	.L70
 946              		.cfi_endproc
 947              	.LFE36:
 949              		.comm	sec,4,4
 950              		.comm	min,4,4
 951              		.comm	hour,4,4
 952              		.comm	day,4,4
 953              		.comm	month,4,4
 954              		.comm	Cyear,4,4
 955              		.global	time_update
 956              		.global	month_length
 957              		.comm	time_rtc_flag,1,1
 958              		.comm	now_time,4,4
 959              		.section	.data.time_update,"aw"
 960              		.set	.LANCHOR1,. + 0
 963              	time_update:
 964 0000 01       		.byte	1
 965              		.section	.rodata.month_length,"a"
 966              		.set	.LANCHOR0,. + 0
 969              	month_length:
 970 0000 1F1D1F1E 		.ascii	"\037\035\037\036\037\036\037\037\036\037\036\037"
 970      1F1E1F1F 
 970      1E1F1E1F 
 971              		.text
 972              	.Letext0:
 973              		.file 2 "c:\\project\\stm32fx_lib\\stm32f1x_iolib\\include\\core.h"
 974              		.file 3 "/project/stm32fx_lib/stm32f1x_iolib/include/cmsis/stm32f1xx.h"
 975              		.file 4 "/project/stm32fx_lib/stm32f1x_iolib/include/irq.h"
 976              		.file 5 "userdefs.h"
 977              		.file 6 "/project/stm32fx_lib/stm32f1x_iolib/include/fundefs.h"
DEFINED SYMBOLS
                            *ABS*:00000000 time.c
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:16     .text.time_from_seconds:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:24     .text.time_from_seconds:00000000 time_from_seconds
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:175    .text.time_from_seconds:00000090 $d
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:180    .text.time_to_seconds:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:187    .text.time_to_seconds:00000000 time_to_seconds
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:325    .text.time_to_seconds:00000080 $d
                            *COM*:00000004 hour
                            *COM*:00000004 min
                            *COM*:00000004 sec
                            *COM*:00000004 month
                            *COM*:00000004 Cyear
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:335    .text.RTC_IRQHandler:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:342    .text.RTC_IRQHandler:00000000 RTC_IRQHandler
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:386    .text.RTC_IRQHandler:00000020 $d
                            *COM*:00000001 time_rtc_flag
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:391    .text.set_time:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:398    .text.set_time:00000000 set_time
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:434    .text.check_rtc:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:441    .text.check_rtc:00000000 check_rtc
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:502    .text.check_rtc:0000003c $d
                            *COM*:00000004 now_time
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:511    .text.time_display:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:518    .text.time_display:00000000 time_display
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:720    .text.time_display:000000dc $d
                            *COM*:00000004 day
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:732    .text.setup_rtc:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:739    .text.setup_rtc:00000000 setup_rtc
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:839    .text.setup_rtc:00000074 $d
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:844    .text.init_rtc:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:851    .text.init_rtc:00000000 init_rtc
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:963    .data.time_update:00000000 time_update
C:\Users\gowoo\AppData\Local\Temp\cczFMeHd.s:969    .rodata.month_length:00000000 month_length

UNDEFINED SYMBOLS
RTC_GetITStatus
RTC_ClearITPendingBit
RTC_WaitForLastTask
RTC_SetCounter
RTC_GetCounter
put_engxy
lcd_printf
RCC_APB1PeriphClockCmd
PWR_BackupAccessCmd
BKP_DeInit
RCC_LSEConfig
RCC_GetFlagStatus
RCC_RTCCLKConfig
RCC_RTCCLKCmd
RTC_WaitForSynchro
RTC_SetPrescaler
BKP_WriteBackupRegister
IWDG_ReloadCounter
jiffes
NVIC_Init
BKP_ClearFlag
BKP_ReadBackupRegister
BKP_TamperPinCmd
BKP_ITConfig
RTC_ITConfig
