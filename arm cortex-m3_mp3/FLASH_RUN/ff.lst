   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"ff.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.mem_cpy,"ax",%progbits
  16              		.align	1
  17              		.arch armv7-m
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	mem_cpy:
  24              	.LVL0:
  25              	.LFB29:
  26              		.file 1 "ff.c"
   1:ff.c          **** /*----------------------------------------------------------------------------/
   2:ff.c          **** /  FatFs - FAT file system module  R0.07c                    (C)ChaN, 2009
   3:ff.c          **** /-----------------------------------------------------------------------------/
   4:ff.c          **** / FatFs module is an open source software to implement FAT file system to
   5:ff.c          **** / small embedded systems. This is a free software and is opened for education,
   6:ff.c          **** / research and commercial use under license policy of following trems.
   7:ff.c          **** /
   8:ff.c          **** /  Copyright (C) 2009, ChaN, all right reserved.
   9:ff.c          **** /
  10:ff.c          **** / * The FatFs module is a free software and there is NO WARRANTY.
  11:ff.c          **** / * No restriction on use. You can use, modify and redistribute it for
  12:ff.c          **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
  13:ff.c          **** / * Redistributions of source code must retain the above copyright notice.
  14:ff.c          **** /
  15:ff.c          **** /-----------------------------------------------------------------------------/
  16:ff.c          **** / Feb 26,'06 R0.00  Prototype.
  17:ff.c          **** /
  18:ff.c          **** / Apr 29,'06 R0.01  First stable version.
  19:ff.c          **** /
  20:ff.c          **** / Jun 01,'06 R0.02  Added FAT12 support.
  21:ff.c          **** /                   Removed unbuffered mode.
  22:ff.c          **** /                   Fixed a problem on small (<32M) patition.
  23:ff.c          **** / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
  24:ff.c          **** /
  25:ff.c          **** / Sep 22,'06 R0.03  Added f_rename().
  26:ff.c          **** /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
  27:ff.c          **** / Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.
  28:ff.c          **** /                   Fixed f_mkdir() creates incorrect directory on FAT32.
  29:ff.c          **** /
  30:ff.c          **** / Feb 04,'07 R0.04  Supported multiple drive system.
  31:ff.c          **** /                   Changed some interfaces for multiple drive system.
  32:ff.c          **** /                   Changed f_mountdrv() to f_mount().
  33:ff.c          **** /                   Added f_mkfs().
  34:ff.c          **** / Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.
  35:ff.c          **** /                   Added a capability of extending file size to f_lseek().
  36:ff.c          **** /                   Added minimization level 3.
  37:ff.c          **** /                   Fixed an endian sensitive code in f_mkfs().
  38:ff.c          **** / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
  39:ff.c          **** /                   Added FSInfo support.
  40:ff.c          **** /                   Fixed DBCS name can result FR_INVALID_NAME.
  41:ff.c          **** /                   Fixed short seek (<= csize) collapses the file object.
  42:ff.c          **** /
  43:ff.c          **** / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
  44:ff.c          **** /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
  45:ff.c          **** /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
  46:ff.c          **** / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
  47:ff.c          **** /                   Fixed off by one error at FAT sub-type determination.
  48:ff.c          **** /                   Fixed btr in f_read() can be mistruncated.
  49:ff.c          **** /                   Fixed cached sector is not flushed when create and close
  50:ff.c          **** /                   without write.
  51:ff.c          **** /
  52:ff.c          **** / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
  53:ff.c          **** /                   Improved performance of f_lseek() on moving to the same
  54:ff.c          **** /                   or following cluster.
  55:ff.c          **** /
  56:ff.c          **** / Apr 01,'09 R0.07  Merged Tiny-FatFs as a buffer configuration option.
  57:ff.c          **** /                   Added long file name support.
  58:ff.c          **** /                   Added multiple code page support.
  59:ff.c          **** /                   Added re-entrancy for multitask operation.
  60:ff.c          **** /                   Added auto cluster size selection to f_mkfs().
  61:ff.c          **** /                   Added rewind option to f_readdir().
  62:ff.c          **** /                   Changed result code of critical errors.
  63:ff.c          **** /                   Renamed string functions to avoid name collision.
  64:ff.c          **** / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
  65:ff.c          **** /                   Added multiple sector size support.
  66:ff.c          **** / Jun 21,'09 R0.07c Fixed f_unlink() may return FR_OK on error.
  67:ff.c          **** /                   Fixed wrong cache control in f_lseek().
  68:ff.c          **** /                   Added relative path feature.
  69:ff.c          **** /                   Added f_chdir() and f_chdrive().
  70:ff.c          **** /                   Added proper case conversion to extended char.
  71:ff.c          **** /---------------------------------------------------------------------------*/
  72:ff.c          **** #include "hwdefs.h"
  73:ff.c          **** #include "ff.h"			/* FatFs configurations and declarations */
  74:ff.c          **** #include "diskio.h"		/* Declarations of low level disk I/O functions */
  75:ff.c          **** 
  76:ff.c          **** /*--------------------------------------------------------------------------
  77:ff.c          **** 
  78:ff.c          ****    Module Private Definitions
  79:ff.c          **** 
  80:ff.c          **** ---------------------------------------------------------------------------*/
  81:ff.c          **** 
  82:ff.c          **** #if _FS_REENTRANT
  83:ff.c          **** #if _USE_LFN == 1
  84:ff.c          **** #error Static LFN work area must not be used in re-entrant configuration.
  85:ff.c          **** #endif
  86:ff.c          **** #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
  87:ff.c          **** #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
  88:ff.c          **** 
  89:ff.c          **** #else
  90:ff.c          **** #define	ENTER_FF(fs)
  91:ff.c          **** #define LEAVE_FF(fs, res)	return res
  92:ff.c          **** 
  93:ff.c          **** #endif
  94:ff.c          **** 
  95:ff.c          **** #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
  96:ff.c          **** 
  97:ff.c          **** #ifndef NULL
  98:ff.c          **** #define	NULL	0
  99:ff.c          **** #endif
 100:ff.c          **** 
 101:ff.c          **** /* Name status flags */
 102:ff.c          **** #define NS_LOSS		0x01	/* Lossy conversion */
 103:ff.c          **** #define NS_LFN		0x02	/* Force to create LFN entry */
 104:ff.c          **** #define NS_LAST		0x04	/* Last segment */
 105:ff.c          **** #define NS_BODY		0x08	/* Lower case flag (body) */
 106:ff.c          **** #define NS_EXT		0x10	/* Lower case flag (ext) */
 107:ff.c          **** #define NS_DOT		0x20	/* Dot entry */
 108:ff.c          **** 
 109:ff.c          **** 
 110:ff.c          **** 
 111:ff.c          **** 
 112:ff.c          **** /*--------------------------------------------------------------------------
 113:ff.c          **** 
 114:ff.c          ****    Private Work Area
 115:ff.c          **** 
 116:ff.c          **** ---------------------------------------------------------------------------*/
 117:ff.c          **** 
 118:ff.c          **** static
 119:ff.c          **** FATFS *FatFs[_DRIVES];	/* Pointer to the file system objects (logical drives) */
 120:ff.c          **** 
 121:ff.c          **** static
 122:ff.c          **** WORD Fsid;				/* File system mount ID */
 123:ff.c          **** 
 124:ff.c          **** #if _FS_RPATH
 125:ff.c          **** static
 126:ff.c          **** BYTE Drive;				/* Current drive */
 127:ff.c          **** #endif
 128:ff.c          **** 
 129:ff.c          **** 
 130:ff.c          **** #if _USE_LFN == 1	/* LFN with static LFN working buffer */
 131:ff.c          **** static
 132:ff.c          **** WORD LfnBuf[_MAX_LFN + 1];
 133:ff.c          **** #define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR *lp = LfnBuf
 134:ff.c          **** #define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
 135:ff.c          **** 
 136:ff.c          **** #elif _USE_LFN > 1	/* LFN with dynamic LFN working buffer */
 137:ff.c          **** #define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR lbuf[_MAX_LFN + 1], *lp = lbuf
 138:ff.c          **** #define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
 139:ff.c          **** 
 140:ff.c          **** #else				/* No LFN */
 141:ff.c          **** #define	NAMEBUF(sp,lp)	BYTE sp[12]
 142:ff.c          **** #define INITBUF(dj,sp,lp)	dj.fn = sp
 143:ff.c          **** 
 144:ff.c          **** #endif
 145:ff.c          **** 
 146:ff.c          **** 
 147:ff.c          **** 
 148:ff.c          **** 
 149:ff.c          **** /*--------------------------------------------------------------------------
 150:ff.c          **** 
 151:ff.c          ****    Private Functions
 152:ff.c          **** 
 153:ff.c          **** ---------------------------------------------------------------------------*/
 154:ff.c          **** 
 155:ff.c          **** 
 156:ff.c          **** /*-----------------------------------------------------------------------*/
 157:ff.c          **** /* String functions                                                      */
 158:ff.c          **** /*-----------------------------------------------------------------------*/
 159:ff.c          **** 
 160:ff.c          **** /* Copy memory to memory */
 161:ff.c          **** static
 162:ff.c          **** void mem_cpy (void* dst, const void* src, int cnt) {
  27              		.loc 1 162 52 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
 163:ff.c          **** 	char *d = (char*)dst;
  32              		.loc 1 163 2 view .LVU1
 164:ff.c          **** 	const char *s = (const char *)src;
  33              		.loc 1 164 2 view .LVU2
 165:ff.c          **** 	while (cnt--) *d++ = *s++;
  34              		.loc 1 165 2 view .LVU3
  35 0000 0138     		subs	r0, r0, #1
  36              	.LVL1:
  37              		.loc 1 165 2 is_stmt 0 view .LVU4
  38 0002 0A44     		add	r2, r2, r1
  39              	.LVL2:
  40              	.L2:
  41              		.loc 1 165 8 is_stmt 1 discriminator 1 view .LVU5
  42              		.loc 1 165 8 is_stmt 0 discriminator 1 view .LVU6
  43 0004 9142     		cmp	r1, r2
  44 0006 00D1     		bne	.L3
 166:ff.c          **** }
  45              		.loc 1 166 1 view .LVU7
  46 0008 7047     		bx	lr
  47              	.L3:
 165:ff.c          **** 	while (cnt--) *d++ = *s++;
  48              		.loc 1 165 16 is_stmt 1 discriminator 2 view .LVU8
  49              	.LVL3:
 165:ff.c          **** 	while (cnt--) *d++ = *s++;
  50              		.loc 1 165 23 is_stmt 0 discriminator 2 view .LVU9
  51 000a 11F8013B 		ldrb	r3, [r1], #1	@ zero_extendqisi2
  52              	.LVL4:
 165:ff.c          **** 	while (cnt--) *d++ = *s++;
  53              		.loc 1 165 21 discriminator 2 view .LVU10
  54 000e 00F8013F 		strb	r3, [r0, #1]!
  55 0012 F7E7     		b	.L2
  56              		.cfi_endproc
  57              	.LFE29:
  59              		.section	.text.mem_cmp,"ax",%progbits
  60              		.align	1
  61              		.syntax unified
  62              		.thumb
  63              		.thumb_func
  64              		.fpu softvfp
  66              	mem_cmp:
  67              	.LVL5:
  68              	.LFB31:
 167:ff.c          **** 
 168:ff.c          **** /* Fill memory */
 169:ff.c          **** static
 170:ff.c          **** void mem_set (void* dst, int val, int cnt) {
 171:ff.c          **** 	char *d = (char*)dst;
 172:ff.c          **** 	while (cnt--) *d++ = (char)val;
 173:ff.c          **** }
 174:ff.c          **** 
 175:ff.c          **** /* Compare memory to memory */
 176:ff.c          **** static
 177:ff.c          **** int mem_cmp (const void* dst, const void* src, int cnt) {
  69              		.loc 1 177 57 is_stmt 1 view -0
  70              		.cfi_startproc
  71              		@ args = 0, pretend = 0, frame = 0
  72              		@ frame_needed = 0, uses_anonymous_args = 0
  73              		.loc 1 177 57 is_stmt 0 view .LVU12
  74 0000 0346     		mov	r3, r0
 178:ff.c          **** 	const char *d = (const char *)dst, *s = (const char *)src;
  75              		.loc 1 178 2 is_stmt 1 view .LVU13
  76              	.LVL6:
 179:ff.c          **** 	int r = 0;
  77              		.loc 1 179 2 view .LVU14
 180:ff.c          **** 	while (cnt-- && (r = *d++ - *s++) == 0) ;
  78              		.loc 1 180 2 view .LVU15
 177:ff.c          **** 	const char *d = (const char *)dst, *s = (const char *)src;
  79              		.loc 1 177 57 is_stmt 0 view .LVU16
  80 0002 10B5     		push	{r4, lr}
  81              		.cfi_def_cfa_offset 8
  82              		.cfi_offset 4, -8
  83              		.cfi_offset 14, -4
  84 0004 0244     		add	r2, r2, r0
  85              	.LVL7:
  86              	.L6:
  87              		.loc 1 180 42 is_stmt 1 discriminator 2 view .LVU17
  88              		.loc 1 180 8 discriminator 2 view .LVU18
  89              		.loc 1 180 8 is_stmt 0 discriminator 2 view .LVU19
  90 0006 9342     		cmp	r3, r2
  91 0008 06D0     		beq	.L7
  92              	.LVL8:
  93              		.loc 1 180 23 discriminator 1 view .LVU20
  94 000a 13F8010B 		ldrb	r0, [r3], #1	@ zero_extendqisi2
  95              	.LVL9:
  96              		.loc 1 180 30 discriminator 1 view .LVU21
  97 000e 11F8014B 		ldrb	r4, [r1], #1	@ zero_extendqisi2
  98              	.LVL10:
  99              		.loc 1 180 15 discriminator 1 view .LVU22
 100 0012 001B     		subs	r0, r0, r4
 101              	.LVL11:
 102              		.loc 1 180 15 discriminator 1 view .LVU23
 103 0014 F7D0     		beq	.L6
 104              	.LVL12:
 105              	.L4:
 181:ff.c          **** 	return r;
 182:ff.c          **** }
 106              		.loc 1 182 1 view .LVU24
 107 0016 10BD     		pop	{r4, pc}
 108              	.LVL13:
 109              	.L7:
 110              		.loc 1 182 1 view .LVU25
 111 0018 0020     		movs	r0, #0
 181:ff.c          **** 	return r;
 112              		.loc 1 181 2 is_stmt 1 view .LVU26
 181:ff.c          **** 	return r;
 113              		.loc 1 181 9 is_stmt 0 view .LVU27
 114 001a FCE7     		b	.L4
 115              		.cfi_endproc
 116              	.LFE31:
 118              		.section	.text.clust2sect,"ax",%progbits
 119              		.align	1
 120              		.syntax unified
 121              		.thumb
 122              		.thumb_func
 123              		.fpu softvfp
 125              	clust2sect:
 126              	.LVL14:
 127              	.LFB39:
 183:ff.c          **** 
 184:ff.c          **** /* Check if chr is contained in the string */
 185:ff.c          **** static
 186:ff.c          **** int chk_chr (const char* str, int chr) {
 187:ff.c          **** 	while (*str && *str != chr) str++;
 188:ff.c          **** 	return *str;
 189:ff.c          **** }
 190:ff.c          **** 
 191:ff.c          **** 
 192:ff.c          **** 
 193:ff.c          **** /*-----------------------------------------------------------------------*/
 194:ff.c          **** /* Request/Release grant to access the volume                            */
 195:ff.c          **** /*-----------------------------------------------------------------------*/
 196:ff.c          **** #if _FS_REENTRANT
 197:ff.c          **** 
 198:ff.c          **** static
 199:ff.c          **** BOOL lock_fs (
 200:ff.c          **** 	FATFS *fs		/* File system object */
 201:ff.c          **** )
 202:ff.c          **** {
 203:ff.c          **** 	return ff_req_grant(fs->sobj);
 204:ff.c          **** }
 205:ff.c          **** 
 206:ff.c          **** 
 207:ff.c          **** static
 208:ff.c          **** void unlock_fs (
 209:ff.c          **** 	FATFS *fs,		/* File system object */
 210:ff.c          **** 	FRESULT res		/* Result code to be returned */
 211:ff.c          **** )
 212:ff.c          **** {
 213:ff.c          **** 	if (res != FR_NOT_ENABLED &&
 214:ff.c          **** 		res != FR_INVALID_DRIVE &&
 215:ff.c          **** 		res != FR_INVALID_OBJECT &&
 216:ff.c          **** 		res != FR_TIMEOUT) {
 217:ff.c          **** 		ff_rel_grant(fs->sobj);
 218:ff.c          **** 	}
 219:ff.c          **** }
 220:ff.c          **** #endif
 221:ff.c          **** 
 222:ff.c          **** 
 223:ff.c          **** 
 224:ff.c          **** /*-----------------------------------------------------------------------*/
 225:ff.c          **** /* Change window offset                                                  */
 226:ff.c          **** /*-----------------------------------------------------------------------*/
 227:ff.c          **** 
 228:ff.c          **** static
 229:ff.c          **** FRESULT move_window (
 230:ff.c          **** 	FATFS *fs,		/* File system object */
 231:ff.c          **** 	DWORD sector	/* Sector number to make apperance in the fs->win[] */
 232:ff.c          **** )					/* Move to zero only writes back dirty window */
 233:ff.c          **** {
 234:ff.c          **** 	DWORD wsect;
 235:ff.c          **** 
 236:ff.c          **** 
 237:ff.c          **** 	wsect = fs->winsect;
 238:ff.c          **** 	if (wsect != sector) {	/* Changed current window */
 239:ff.c          **** #if !_FS_READONLY
 240:ff.c          **** 		if (fs->wflag) {	/* Write back dirty window if needed */
 241:ff.c          **** 			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
 242:ff.c          **** 				return FR_DISK_ERR;
 243:ff.c          **** 			fs->wflag = 0;
 244:ff.c          **** 			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
 245:ff.c          **** 				BYTE nf;
 246:ff.c          **** 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
 247:ff.c          **** 					wsect += fs->sects_fat;
 248:ff.c          **** 					disk_write(fs->drive, fs->win, wsect, 1);
 249:ff.c          **** 				}
 250:ff.c          **** 			}
 251:ff.c          **** 		}
 252:ff.c          **** #endif
 253:ff.c          **** 		if (sector) {
 254:ff.c          **** 			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
 255:ff.c          **** 				return FR_DISK_ERR;
 256:ff.c          **** 			fs->winsect = sector;
 257:ff.c          **** 		}
 258:ff.c          **** 	}
 259:ff.c          **** 
 260:ff.c          **** 	return FR_OK;
 261:ff.c          **** }
 262:ff.c          **** 
 263:ff.c          **** 
 264:ff.c          **** 
 265:ff.c          **** 
 266:ff.c          **** /*-----------------------------------------------------------------------*/
 267:ff.c          **** /* Clean-up cached data                                                  */
 268:ff.c          **** /*-----------------------------------------------------------------------*/
 269:ff.c          **** #if !_FS_READONLY
 270:ff.c          **** static
 271:ff.c          **** FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
 272:ff.c          **** 	FATFS *fs	/* File system object */
 273:ff.c          **** )
 274:ff.c          **** {
 275:ff.c          **** 	FRESULT res;
 276:ff.c          **** 
 277:ff.c          **** 
 278:ff.c          **** 	res = move_window(fs, 0);
 279:ff.c          **** 	if (res == FR_OK) {
 280:ff.c          **** 		/* Update FSInfo sector if needed */
 281:ff.c          **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 282:ff.c          **** 			fs->winsect = 0;
 283:ff.c          **** 			mem_set(fs->win, 0, 512);
 284:ff.c          **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 285:ff.c          **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 286:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 287:ff.c          **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 288:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 289:ff.c          **** 			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 290:ff.c          **** 			fs->fsi_flag = 0;
 291:ff.c          **** 		}
 292:ff.c          **** 		/* Make sure that no pending write process in the physical drive */
 293:ff.c          **** 		if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
 294:ff.c          **** 			res = FR_DISK_ERR;
 295:ff.c          **** 	}
 296:ff.c          **** 
 297:ff.c          **** 	return res;
 298:ff.c          **** }
 299:ff.c          **** #endif
 300:ff.c          **** 
 301:ff.c          **** 
 302:ff.c          **** 
 303:ff.c          **** 
 304:ff.c          **** /*-----------------------------------------------------------------------*/
 305:ff.c          **** /* FAT access - Read value of a FAT entry                                */
 306:ff.c          **** /*-----------------------------------------------------------------------*/
 307:ff.c          **** 
 308:ff.c          **** static
 309:ff.c          **** DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
 310:ff.c          **** 	FATFS *fs,	/* File system object */
 311:ff.c          **** 	DWORD clst	/* Cluster# to get the link information */
 312:ff.c          **** )
 313:ff.c          **** {
 314:ff.c          **** 	UINT wc, bc;
 315:ff.c          **** 	DWORD fsect;
 316:ff.c          **** 
 317:ff.c          **** 
 318:ff.c          **** 	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
 319:ff.c          **** 		return 1;
 320:ff.c          **** 
 321:ff.c          **** 	fsect = fs->fatbase;
 322:ff.c          **** 	switch (fs->fs_type) {
 323:ff.c          **** 	case FS_FAT12 :
 324:ff.c          **** 		bc = clst; bc += bc / 2;
 325:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 326:ff.c          **** 		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 327:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 328:ff.c          **** 		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 329:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 330:ff.c          **** 
 331:ff.c          **** 	case FS_FAT16 :
 332:ff.c          **** 		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
 333:ff.c          **** 		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 334:ff.c          **** 
 335:ff.c          **** 	case FS_FAT32 :
 336:ff.c          **** 		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
 337:ff.c          **** 		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 338:ff.c          **** 	}
 339:ff.c          **** 
 340:ff.c          **** 	return 0xFFFFFFFF;	/* An error occured at the disk I/O layer */
 341:ff.c          **** }
 342:ff.c          **** 
 343:ff.c          **** 
 344:ff.c          **** 
 345:ff.c          **** 
 346:ff.c          **** /*-----------------------------------------------------------------------*/
 347:ff.c          **** /* FAT access - Change value of a FAT entry                              */
 348:ff.c          **** /*-----------------------------------------------------------------------*/
 349:ff.c          **** #if !_FS_READONLY
 350:ff.c          **** static
 351:ff.c          **** FRESULT put_fat (
 352:ff.c          **** 	FATFS *fs,	/* File system object */
 353:ff.c          **** 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->max_clust - 1 */
 354:ff.c          **** 	DWORD val	/* New value to mark the cluster */
 355:ff.c          **** )
 356:ff.c          **** {
 357:ff.c          **** 	UINT bc;
 358:ff.c          **** 	BYTE *p;
 359:ff.c          **** 	DWORD fsect;
 360:ff.c          **** 	FRESULT res;
 361:ff.c          **** 
 362:ff.c          **** 
 363:ff.c          **** 	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
 364:ff.c          **** 		res = FR_INT_ERR;
 365:ff.c          **** 
 366:ff.c          **** 	} else {
 367:ff.c          **** 		fsect = fs->fatbase;
 368:ff.c          **** 		switch (fs->fs_type) {
 369:ff.c          **** 		case FS_FAT12 :
 370:ff.c          **** 			bc = clst; bc += bc / 2;
 371:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 372:ff.c          **** 			if (res != FR_OK) break;
 373:ff.c          **** 			p = &fs->win[bc & (SS(fs) - 1)];
 374:ff.c          **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 375:ff.c          **** 			bc++;
 376:ff.c          **** 			fs->wflag = 1;
 377:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 378:ff.c          **** 			if (res != FR_OK) break;
 379:ff.c          **** 			p = &fs->win[bc & (SS(fs) - 1)];
 380:ff.c          **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 381:ff.c          **** 			break;
 382:ff.c          **** 
 383:ff.c          **** 		case FS_FAT16 :
 384:ff.c          **** 			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
 385:ff.c          **** 			if (res != FR_OK) break;
 386:ff.c          **** 			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
 387:ff.c          **** 			break;
 388:ff.c          **** 
 389:ff.c          **** 		case FS_FAT32 :
 390:ff.c          **** 			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
 391:ff.c          **** 			if (res != FR_OK) break;
 392:ff.c          **** 			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
 393:ff.c          **** 			break;
 394:ff.c          **** 
 395:ff.c          **** 		default :
 396:ff.c          **** 			res = FR_INT_ERR;
 397:ff.c          **** 		}
 398:ff.c          **** 		fs->wflag = 1;
 399:ff.c          **** 	}
 400:ff.c          **** 
 401:ff.c          **** 	return res;
 402:ff.c          **** }
 403:ff.c          **** #endif /* !_FS_READONLY */
 404:ff.c          **** 
 405:ff.c          **** 
 406:ff.c          **** 
 407:ff.c          **** 
 408:ff.c          **** /*-----------------------------------------------------------------------*/
 409:ff.c          **** /* FAT handling - Remove a cluster chain                                 */
 410:ff.c          **** /*-----------------------------------------------------------------------*/
 411:ff.c          **** #if !_FS_READONLY
 412:ff.c          **** static
 413:ff.c          **** FRESULT remove_chain (
 414:ff.c          **** 	FATFS *fs,			/* File system object */
 415:ff.c          **** 	DWORD clst			/* Cluster# to remove a chain from */
 416:ff.c          **** )
 417:ff.c          **** {
 418:ff.c          **** 	FRESULT res;
 419:ff.c          **** 	DWORD nxt;
 420:ff.c          **** 
 421:ff.c          **** 
 422:ff.c          **** 	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
 423:ff.c          **** 		res = FR_INT_ERR;
 424:ff.c          **** 
 425:ff.c          **** 	} else {
 426:ff.c          **** 		res = FR_OK;
 427:ff.c          **** 		while (clst < fs->max_clust) {			/* Not a last link? */
 428:ff.c          **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 429:ff.c          **** 			if (nxt == 0) break;				/* Empty cluster? */
 430:ff.c          **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 431:ff.c          **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 432:ff.c          **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 433:ff.c          **** 			if (res != FR_OK) break;
 434:ff.c          **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 435:ff.c          **** 				fs->free_clust++;
 436:ff.c          **** 				fs->fsi_flag = 1;
 437:ff.c          **** 			}
 438:ff.c          **** 			clst = nxt;	/* Next cluster */
 439:ff.c          **** 		}
 440:ff.c          **** 	}
 441:ff.c          **** 
 442:ff.c          **** 	return res;
 443:ff.c          **** }
 444:ff.c          **** #endif
 445:ff.c          **** 
 446:ff.c          **** 
 447:ff.c          **** 
 448:ff.c          **** 
 449:ff.c          **** /*-----------------------------------------------------------------------*/
 450:ff.c          **** /* FAT handling - Stretch or Create a cluster chain                      */
 451:ff.c          **** /*-----------------------------------------------------------------------*/
 452:ff.c          **** #if !_FS_READONLY
 453:ff.c          **** static
 454:ff.c          **** DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster
 455:ff.c          **** 	FATFS *fs,			/* File system object */
 456:ff.c          **** 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
 457:ff.c          **** )
 458:ff.c          **** {
 459:ff.c          **** 	DWORD cs, ncl, scl, mcl;
 460:ff.c          **** 
 461:ff.c          **** 
 462:ff.c          **** 	mcl = fs->max_clust;
 463:ff.c          **** 	if (clst == 0) {		/* Create new chain */
 464:ff.c          **** 		scl = fs->last_clust;			/* Get suggested start point */
 465:ff.c          **** 		if (scl == 0 || scl >= mcl) scl = 1;
 466:ff.c          **** 	}
 467:ff.c          **** 	else {					/* Stretch existing chain */
 468:ff.c          **** 		cs = get_fat(fs, clst);			/* Check the cluster status */
 469:ff.c          **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 470:ff.c          **** 		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 471:ff.c          **** 		scl = clst;
 472:ff.c          **** 	}
 473:ff.c          **** 
 474:ff.c          **** 	ncl = scl;				/* Start cluster */
 475:ff.c          **** 	for (;;) {
 476:ff.c          **** 		ncl++;							/* Next cluster */
 477:ff.c          **** 		if (ncl >= mcl) {				/* Wrap around */
 478:ff.c          **** 			ncl = 2;
 479:ff.c          **** 			if (ncl > scl) return 0;	/* No free custer */
 480:ff.c          **** 		}
 481:ff.c          **** 		cs = get_fat(fs, ncl);			/* Get the cluster status */
 482:ff.c          **** 		if (cs == 0) break;				/* Found a free cluster */
 483:ff.c          **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
 484:ff.c          **** 			return cs;
 485:ff.c          **** 		if (ncl == scl) return 0;		/* No free custer */
 486:ff.c          **** 	}
 487:ff.c          **** 
 488:ff.c          **** 	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
 489:ff.c          **** 		return 0xFFFFFFFF;
 490:ff.c          **** 	if (clst != 0) {					/* Link it to the previous one if needed */
 491:ff.c          **** 		if (put_fat(fs, clst, ncl))
 492:ff.c          **** 			return 0xFFFFFFFF;
 493:ff.c          **** 	}
 494:ff.c          **** 
 495:ff.c          **** 	fs->last_clust = ncl;				/* Update FSINFO */
 496:ff.c          **** 	if (fs->free_clust != 0xFFFFFFFF) {
 497:ff.c          **** 		fs->free_clust--;
 498:ff.c          **** 		fs->fsi_flag = 1;
 499:ff.c          **** 	}
 500:ff.c          **** 
 501:ff.c          **** 	return ncl;		/* Return new cluster number */
 502:ff.c          **** }
 503:ff.c          **** #endif /* !_FS_READONLY */
 504:ff.c          **** 
 505:ff.c          **** 
 506:ff.c          **** 
 507:ff.c          **** 
 508:ff.c          **** /*-----------------------------------------------------------------------*/
 509:ff.c          **** /* Get sector# from cluster#                                             */
 510:ff.c          **** /*-----------------------------------------------------------------------*/
 511:ff.c          **** 
 512:ff.c          **** static
 513:ff.c          **** DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
 514:ff.c          **** 	FATFS *fs,		/* File system object */
 515:ff.c          **** 	DWORD clst		/* Cluster# to be converted */
 516:ff.c          **** )
 517:ff.c          **** {
 128              		.loc 1 517 1 is_stmt 1 view -0
 129              		.cfi_startproc
 130              		@ args = 0, pretend = 0, frame = 0
 131              		@ frame_needed = 0, uses_anonymous_args = 0
 132              		@ link register save eliminated.
 518:ff.c          **** 	clst -= 2;
 133              		.loc 1 518 2 view .LVU29
 519:ff.c          **** 	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
 134              		.loc 1 519 29 is_stmt 0 view .LVU30
 135 0000 036A     		ldr	r3, [r0, #32]
 518:ff.c          **** 	clst -= 2;
 136              		.loc 1 518 7 view .LVU31
 137 0002 0239     		subs	r1, r1, #2
 138              	.LVL15:
 139              		.loc 1 519 2 is_stmt 1 view .LVU32
 140              		.loc 1 519 29 is_stmt 0 view .LVU33
 141 0004 023B     		subs	r3, r3, #2
 142              		.loc 1 519 5 view .LVU34
 143 0006 8B42     		cmp	r3, r1
 520:ff.c          **** 	return clst * fs->csize + fs->database;
 144              		.loc 1 520 2 is_stmt 1 view .LVU35
 145              		.loc 1 520 18 is_stmt 0 view .LVU36
 146 0008 83BF     		ittte	hi
 147 000a 8378     		ldrbhi	r3, [r0, #2]	@ zero_extendqisi2
 148              		.loc 1 520 26 view .LVU37
 149 000c C06A     		ldrhi	r0, [r0, #44]
 150              	.LVL16:
 151              		.loc 1 520 26 view .LVU38
 152 000e 01FB0300 		mlahi	r0, r1, r3, r0
 519:ff.c          **** 	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
 153              		.loc 1 519 42 view .LVU39
 154 0012 0020     		movls	r0, #0
 521:ff.c          **** }
 155              		.loc 1 521 1 view .LVU40
 156 0014 7047     		bx	lr
 157              		.cfi_endproc
 158              	.LFE39:
 160              		.section	.text.get_fileinfo,"ax",%progbits
 161              		.align	1
 162              		.syntax unified
 163              		.thumb
 164              		.thumb_func
 165              		.fpu softvfp
 167              	get_fileinfo:
 168              	.LVL17:
 169              	.LFB47:
 522:ff.c          **** 
 523:ff.c          **** 
 524:ff.c          **** 
 525:ff.c          **** 
 526:ff.c          **** /*-----------------------------------------------------------------------*/
 527:ff.c          **** /* Directory handling - Seek directory index                             */
 528:ff.c          **** /*-----------------------------------------------------------------------*/
 529:ff.c          **** 
 530:ff.c          **** static
 531:ff.c          **** FRESULT dir_seek (
 532:ff.c          **** 	DIR *dj,		/* Pointer to directory object */
 533:ff.c          **** 	WORD idx		/* Directory index number */
 534:ff.c          **** )
 535:ff.c          **** {
 536:ff.c          **** 	DWORD clst;
 537:ff.c          **** 	WORD ic;
 538:ff.c          **** 
 539:ff.c          **** 
 540:ff.c          **** 	dj->index = idx;
 541:ff.c          **** 	clst = dj->sclust;
 542:ff.c          **** 	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
 543:ff.c          **** 		return FR_INT_ERR;
 544:ff.c          **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 545:ff.c          **** 		clst = dj->fs->dirbase;
 546:ff.c          **** 
 547:ff.c          **** 	if (clst == 0) {	/* Static table */
 548:ff.c          **** 		dj->clust = clst;
 549:ff.c          **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 550:ff.c          **** 			return FR_INT_ERR;
 551:ff.c          **** 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
 552:ff.c          **** 	}
 553:ff.c          **** 	else {				/* Dynamic table */
 554:ff.c          **** 		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
 555:ff.c          **** 		while (idx >= ic) {	/* Follow cluster chain */
 556:ff.c          **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 557:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 558:ff.c          **** 			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 559:ff.c          **** 				return FR_INT_ERR;
 560:ff.c          **** 			idx -= ic;
 561:ff.c          **** 		}
 562:ff.c          **** 		dj->clust = clst;
 563:ff.c          **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
 564:ff.c          **** 	}
 565:ff.c          **** 
 566:ff.c          **** 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
 567:ff.c          **** 
 568:ff.c          **** 	return FR_OK;	/* Seek succeeded */
 569:ff.c          **** }
 570:ff.c          **** 
 571:ff.c          **** 
 572:ff.c          **** 
 573:ff.c          **** 
 574:ff.c          **** /*-----------------------------------------------------------------------*/
 575:ff.c          **** /* Directory handling - Move directory index next                        */
 576:ff.c          **** /*-----------------------------------------------------------------------*/
 577:ff.c          **** 
 578:ff.c          **** static
 579:ff.c          **** FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach
 580:ff.c          **** 	DIR *dj,		/* Pointer to directory object */
 581:ff.c          **** 	BOOL streach	/* FALSE: Do not streach table, TRUE: Streach table if needed */
 582:ff.c          **** )
 583:ff.c          **** {
 584:ff.c          **** 	DWORD clst;
 585:ff.c          **** 	WORD i;
 586:ff.c          **** 
 587:ff.c          **** 
 588:ff.c          **** 	i = dj->index + 1;
 589:ff.c          **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 590:ff.c          **** 		return FR_NO_FILE;
 591:ff.c          **** 
 592:ff.c          **** 	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
 593:ff.c          **** 		dj->sect++;					/* Next sector */
 594:ff.c          **** 
 595:ff.c          **** 		if (dj->clust == 0) {	/* Static table */
 596:ff.c          **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 597:ff.c          **** 				return FR_NO_FILE;
 598:ff.c          **** 		}
 599:ff.c          **** 		else {					/* Dynamic table */
 600:ff.c          **** 			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 601:ff.c          **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 602:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;
 603:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 604:ff.c          **** 				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
 605:ff.c          **** #if !_FS_READONLY
 606:ff.c          **** 					BYTE c;
 607:ff.c          **** 					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
 608:ff.c          **** 					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
 609:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 610:ff.c          **** 					if (clst == 1) return FR_INT_ERR;
 611:ff.c          **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 612:ff.c          **** 					/* Clean-up streached table */
 613:ff.c          **** 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
 614:ff.c          **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 615:ff.c          **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 616:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 617:ff.c          **** 						dj->fs->wflag = 1;
 618:ff.c          **** 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 619:ff.c          **** 						dj->fs->winsect++;
 620:ff.c          **** 					}
 621:ff.c          **** 					dj->fs->winsect -= c;						/* Rewind window address */
 622:ff.c          **** #else
 623:ff.c          **** 					return FR_NO_FILE;			/* Report EOT */
 624:ff.c          **** #endif
 625:ff.c          **** 				}
 626:ff.c          **** 				dj->clust = clst;				/* Initialize data for new cluster */
 627:ff.c          **** 				dj->sect = clust2sect(dj->fs, clst);
 628:ff.c          **** 			}
 629:ff.c          **** 		}
 630:ff.c          **** 	}
 631:ff.c          **** 
 632:ff.c          **** 	dj->index = i;
 633:ff.c          **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
 634:ff.c          **** 
 635:ff.c          **** 	return FR_OK;
 636:ff.c          **** }
 637:ff.c          **** 
 638:ff.c          **** 
 639:ff.c          **** 
 640:ff.c          **** 
 641:ff.c          **** /*-----------------------------------------------------------------------*/
 642:ff.c          **** /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
 643:ff.c          **** /*-----------------------------------------------------------------------*/
 644:ff.c          **** #if _USE_LFN
 645:ff.c          **** static
 646:ff.c          **** const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory 
 647:ff.c          **** 
 648:ff.c          **** 
 649:ff.c          **** static
 650:ff.c          **** BOOL cmp_lfn (			/* TRUE:Matched, FALSE:Not matched */
 651:ff.c          **** 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
 652:ff.c          **** 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
 653:ff.c          **** )
 654:ff.c          **** {
 655:ff.c          **** 	int i, s;
 656:ff.c          **** 	WCHAR wc;
 657:ff.c          **** 
 658:ff.c          **** 
 659:ff.c          **** 	i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;	/* Get offset in the LFN buffer */
 660:ff.c          **** 	s = 0;
 661:ff.c          **** 	do {
 662:ff.c          **** 		wc = ff_wtoupper(LD_WORD(dir+LfnOfs[s]));	/* Get an LFN character */
 663:ff.c          **** 		if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it with the reference character *
 664:ff.c          **** 			return FALSE;
 665:ff.c          **** 	} while (++s < 13 && wc);		/* Repeat until all chars in the entry or a NUL char is processed */
 666:ff.c          **** 
 667:ff.c          **** 	return TRUE;					/* The LFN entry matched */
 668:ff.c          **** }
 669:ff.c          **** 
 670:ff.c          **** 
 671:ff.c          **** 
 672:ff.c          **** static
 673:ff.c          **** BOOL pick_lfn (			/* TRUE:Succeeded, FALSE:Buffer overflow */
 674:ff.c          **** 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
 675:ff.c          **** 	BYTE *dir			/* Pointer to the directory entry */
 676:ff.c          **** )
 677:ff.c          **** {
 678:ff.c          **** 	int i, s;
 679:ff.c          **** 	WCHAR wc;
 680:ff.c          **** 
 681:ff.c          **** 
 682:ff.c          **** 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 683:ff.c          **** 
 684:ff.c          **** 	s = 0;
 685:ff.c          **** 	do {
 686:ff.c          **** 		if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
 687:ff.c          **** 		wc = LD_WORD(dir+LfnOfs[s]);		/* Get an LFN char */
 688:ff.c          **** 		if (!wc) break;						/* End of LFN? */
 689:ff.c          **** 		lfnbuf[i++] = wc;					/* Store it */
 690:ff.c          **** 	} while (++s < 13);						/* Repeat until last char is copied */
 691:ff.c          **** 
 692:ff.c          **** 	if (dir[LDIR_Ord] & 0x40) {				/* Put terminator if it is the last LFN part */
 693:ff.c          **** 		if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
 694:ff.c          **** 		lfnbuf[i] = 0;
 695:ff.c          **** 	}
 696:ff.c          **** 
 697:ff.c          **** 	return TRUE;
 698:ff.c          **** }
 699:ff.c          **** 
 700:ff.c          **** 
 701:ff.c          **** #if !_FS_READONLY
 702:ff.c          **** static
 703:ff.c          **** void fit_lfn (
 704:ff.c          **** 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
 705:ff.c          **** 	BYTE *dir,				/* Pointer to the directory entry */
 706:ff.c          **** 	BYTE ord,				/* LFN order (1-20) */
 707:ff.c          **** 	BYTE sum				/* SFN sum */
 708:ff.c          **** )
 709:ff.c          **** {
 710:ff.c          **** 	int i, s;
 711:ff.c          **** 	WCHAR wc;
 712:ff.c          **** 
 713:ff.c          **** 
 714:ff.c          **** 	dir[LDIR_Chksum] = sum;			/* Set check sum */
 715:ff.c          **** 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 716:ff.c          **** 	dir[LDIR_Type] = 0;
 717:ff.c          **** 	ST_WORD(dir+LDIR_FstClusLO, 0);
 718:ff.c          **** 
 719:ff.c          **** 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 720:ff.c          **** 	s = wc = 0;
 721:ff.c          **** 	do {
 722:ff.c          **** 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
 723:ff.c          **** 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 724:ff.c          **** 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
 725:ff.c          **** 	} while (++s < 13);
 726:ff.c          **** 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= 0x40;	/* Bottom LFN part is the start of LFN sequence */
 727:ff.c          **** 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 728:ff.c          **** }
 729:ff.c          **** 
 730:ff.c          **** #endif
 731:ff.c          **** #endif
 732:ff.c          **** 
 733:ff.c          **** 
 734:ff.c          **** 
 735:ff.c          **** /*-----------------------------------------------------------------------*/
 736:ff.c          **** /* Create numbered name                                                  */
 737:ff.c          **** /*-----------------------------------------------------------------------*/
 738:ff.c          **** #if _USE_LFN
 739:ff.c          **** void gen_numname (
 740:ff.c          **** 	BYTE *dst,			/* Pointer to genartated SFN */
 741:ff.c          **** 	const BYTE *src,	/* Pointer to source SFN to be modified */
 742:ff.c          **** 	const WCHAR *lfn,	/* Pointer to LFN */
 743:ff.c          **** 	WORD num			/* Sequense number */
 744:ff.c          **** )
 745:ff.c          **** {
 746:ff.c          **** 	char ns[8];
 747:ff.c          **** 	int i, j;
 748:ff.c          **** 
 749:ff.c          **** 
 750:ff.c          **** 	mem_cpy(dst, src, 11);
 751:ff.c          **** 
 752:ff.c          **** 	if (num > 5) {	/* On many collisions, generate a hash number instead of sequencial number */
 753:ff.c          **** 		do num = (num >> 1) + (num << 15) + (WORD)*lfn++; while (*lfn);
 754:ff.c          **** 	}
 755:ff.c          **** 
 756:ff.c          **** 	/* itoa */
 757:ff.c          **** 	i = 7;
 758:ff.c          **** 	do {
 759:ff.c          **** 		ns[i--] = (num % 10) + '0';
 760:ff.c          **** 		num /= 10;
 761:ff.c          **** 	} while (num);
 762:ff.c          **** 	ns[i] = '~';
 763:ff.c          **** 
 764:ff.c          **** 	/* Append the number */
 765:ff.c          **** 	for (j = 0; j < i && dst[j] != ' '; j++) {
 766:ff.c          **** 		if (IsDBCS1(dst[j])) {
 767:ff.c          **** 			if (j == i - 1) break;
 768:ff.c          **** 			j++;
 769:ff.c          **** 		}
 770:ff.c          **** 	}
 771:ff.c          **** 	do {
 772:ff.c          **** 		dst[j++] = (i < 8) ? ns[i++] : ' ';
 773:ff.c          **** 	} while (j < 8);
 774:ff.c          **** }
 775:ff.c          **** #endif
 776:ff.c          **** 
 777:ff.c          **** 
 778:ff.c          **** 
 779:ff.c          **** 
 780:ff.c          **** /*-----------------------------------------------------------------------*/
 781:ff.c          **** /* Calculate sum of an SFN                                               */
 782:ff.c          **** /*-----------------------------------------------------------------------*/
 783:ff.c          **** #if _USE_LFN
 784:ff.c          **** static
 785:ff.c          **** BYTE sum_sfn (
 786:ff.c          **** 	const BYTE *dir		/* Ptr to directory entry */
 787:ff.c          **** )
 788:ff.c          **** {
 789:ff.c          **** 	BYTE sum = 0;
 790:ff.c          **** 	int n = 11;
 791:ff.c          **** 
 792:ff.c          **** 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 793:ff.c          **** 	return sum;
 794:ff.c          **** }
 795:ff.c          **** #endif
 796:ff.c          **** 
 797:ff.c          **** 
 798:ff.c          **** 
 799:ff.c          **** 
 800:ff.c          **** /*-----------------------------------------------------------------------*/
 801:ff.c          **** /* Directory handling - Find an object in the directory                  */
 802:ff.c          **** /*-----------------------------------------------------------------------*/
 803:ff.c          **** 
 804:ff.c          **** static
 805:ff.c          **** FRESULT dir_find (
 806:ff.c          **** 	DIR *dj			/* Pointer to the directory object linked to the file name */
 807:ff.c          **** )
 808:ff.c          **** {
 809:ff.c          **** 	FRESULT res;
 810:ff.c          **** 	BYTE c, *dir;
 811:ff.c          **** #if _USE_LFN
 812:ff.c          **** 	BYTE a, lfen, ord, sum;
 813:ff.c          **** #endif
 814:ff.c          **** 
 815:ff.c          **** 	res = dir_seek(dj, 0);			/* Rewind directory object */
 816:ff.c          **** 	if (res != FR_OK) return res;
 817:ff.c          **** 
 818:ff.c          **** #if _USE_LFN
 819:ff.c          **** 	ord = sum = 0xFF; lfen = *(dj->fn+11) & NS_LOSS;
 820:ff.c          **** #endif
 821:ff.c          **** 	do {
 822:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 823:ff.c          **** 		if (res != FR_OK) break;
 824:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 825:ff.c          **** 		c = dir[DIR_Name];
 826:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 827:ff.c          **** #if _USE_LFN	/* LFN configuration */
 828:ff.c          **** 		a = dir[DIR_Attr] & AM_MASK;
 829:ff.c          **** 		if (c == 0xE5 || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 830:ff.c          **** 			ord = 0xFF;
 831:ff.c          **** 		} else {
 832:ff.c          **** 			if (a == AM_LFN) {			/* An LFN entry is found */
 833:ff.c          **** 				if (dj->lfn) {
 834:ff.c          **** 					if (c & 0x40) {		/* Is it start of LFN sequence? */
 835:ff.c          **** 						sum = dir[LDIR_Chksum];
 836:ff.c          **** 						c &= 0xBF; ord = c;		/* LFN start order */
 837:ff.c          **** 						dj->lfn_idx = dj->index;
 838:ff.c          **** 					}
 839:ff.c          **** 					/* Check LFN validity. Compare LFN if it is out of 8.3 format */
 840:ff.c          **** 					ord = (c == ord && sum == dir[LDIR_Chksum] && (!lfen || cmp_lfn(dj->lfn, dir))) ? ord - 1 : 0x
 841:ff.c          **** 				}
 842:ff.c          **** 			} else {					/* An SFN entry is found */
 843:ff.c          **** 				if (ord || sum != sum_sfn(dir))	/* Did not LFN match? */
 844:ff.c          **** 					dj->lfn_idx = 0xFFFF;
 845:ff.c          **** 				if (lfen) {				/* Match LFN if it is out of 8.3 format */
 846:ff.c          **** 					if (ord == 0) break;
 847:ff.c          **** 				} else {				/* Match SFN if LFN is in 8.3 format */
 848:ff.c          **** 					if (!mem_cmp(dir, dj->fn, 11)) break;
 849:ff.c          **** 				}
 850:ff.c          **** 				ord = 0xFF;
 851:ff.c          **** 			}
 852:ff.c          **** 		}
 853:ff.c          **** #else		/* Non LFN configuration */
 854:ff.c          **** 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 855:ff.c          **** 			break;
 856:ff.c          **** #endif
 857:ff.c          **** 		res = dir_next(dj, FALSE);				/* Next entry */
 858:ff.c          **** 	} while (res == FR_OK);
 859:ff.c          **** 
 860:ff.c          **** 	return res;
 861:ff.c          **** }
 862:ff.c          **** 
 863:ff.c          **** 
 864:ff.c          **** 
 865:ff.c          **** 
 866:ff.c          **** /*-----------------------------------------------------------------------*/
 867:ff.c          **** /* Read an object from the directory                                     */
 868:ff.c          **** /*-----------------------------------------------------------------------*/
 869:ff.c          **** #if _FS_MINIMIZE <= 1
 870:ff.c          **** static
 871:ff.c          **** FRESULT dir_read (
 872:ff.c          **** 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
 873:ff.c          **** )
 874:ff.c          **** {
 875:ff.c          **** 	FRESULT res;
 876:ff.c          **** 	BYTE c, *dir;
 877:ff.c          **** #if _USE_LFN
 878:ff.c          **** 	BYTE a, ord = 0xFF, sum = 0xFF;
 879:ff.c          **** #endif
 880:ff.c          **** 
 881:ff.c          **** 	res = FR_NO_FILE;
 882:ff.c          **** 	while (dj->sect) {
 883:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 884:ff.c          **** 		if (res != FR_OK) break;
 885:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 886:ff.c          **** 		c = dir[DIR_Name];
 887:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 888:ff.c          **** #if _USE_LFN	/* LFN configuration */
 889:ff.c          **** 		a = dir[DIR_Attr] & AM_MASK;
 890:ff.c          **** 		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without
 891:ff.c          **** 			ord = 0xFF;
 892:ff.c          **** 		} else {
 893:ff.c          **** 			if (a == AM_LFN) {			/* An LFN entry is found */
 894:ff.c          **** 				if (c & 0x40) {			/* Is it start of LFN sequence? */
 895:ff.c          **** 					sum = dir[LDIR_Chksum];
 896:ff.c          **** 					c &= 0xBF; ord = c;
 897:ff.c          **** 					dj->lfn_idx = dj->index;
 898:ff.c          **** 				}
 899:ff.c          **** 				/* Check LFN validity and capture it */
 900:ff.c          **** 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 901:ff.c          **** 			} else {					/* An SFN entry is found */
 902:ff.c          **** 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN entry? */
 903:ff.c          **** 					dj->lfn_idx = 0xFFFF;		/* No LFN. */
 904:ff.c          **** 				break;
 905:ff.c          **** 			}
 906:ff.c          **** 		}
 907:ff.c          **** #else		/* Non LFN configuration */
 908:ff.c          **** 		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
 909:ff.c          **** 			break;
 910:ff.c          **** #endif
 911:ff.c          **** 		res = dir_next(dj, FALSE);				/* Next entry */
 912:ff.c          **** 		if (res != FR_OK) break;
 913:ff.c          **** 	}
 914:ff.c          **** 
 915:ff.c          **** 	if (res != FR_OK) dj->sect = 0;
 916:ff.c          **** 
 917:ff.c          **** 	return res;
 918:ff.c          **** }
 919:ff.c          **** #endif
 920:ff.c          **** 
 921:ff.c          **** 
 922:ff.c          **** 
 923:ff.c          **** /*-----------------------------------------------------------------------*/
 924:ff.c          **** /* Register an object to the directory                                   */
 925:ff.c          **** /*-----------------------------------------------------------------------*/
 926:ff.c          **** #if !_FS_READONLY
 927:ff.c          **** static
 928:ff.c          **** FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_D
 929:ff.c          **** 	DIR *dj				/* Target directory with object name to be created */
 930:ff.c          **** )
 931:ff.c          **** {
 932:ff.c          **** 	FRESULT res;
 933:ff.c          **** 	BYTE c, *dir;
 934:ff.c          **** #if _USE_LFN	/* LFN configuration */
 935:ff.c          **** 	WORD n, ne, is;
 936:ff.c          **** 	BYTE sn[12], *fn, sum;
 937:ff.c          **** 	WCHAR *lfn;
 938:ff.c          **** 
 939:ff.c          **** 
 940:ff.c          **** 	fn = dj->fn; lfn = dj->lfn;
 941:ff.c          **** 	mem_cpy(sn, fn, 12);
 942:ff.c          **** 
 943:ff.c          **** 	if (_FS_RPATH && (sn[11] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */
 944:ff.c          **** 
 945:ff.c          **** 	if (sn[11] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 946:ff.c          **** 		fn[11] = 0; dj->lfn = NULL;			/* Find only SFN */
 947:ff.c          **** 		for (n = 1; n < 100; n++) {
 948:ff.c          **** 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
 949:ff.c          **** 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
 950:ff.c          **** 			if (res != FR_OK) break;
 951:ff.c          **** 		}
 952:ff.c          **** 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 953:ff.c          **** 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 954:ff.c          **** 		fn[11] = sn[11]; dj->lfn = lfn;
 955:ff.c          **** 	}
 956:ff.c          **** 
 957:ff.c          **** 	if (sn[11] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
 958:ff.c          **** 		for (ne = 0; lfn[ne]; ne++) ;
 959:ff.c          **** 		ne = (ne + 25) / 13;
 960:ff.c          **** 	} else {						/* Otherwise reserve only an SFN entry. */
 961:ff.c          **** 		ne = 1;
 962:ff.c          **** 	}
 963:ff.c          **** 
 964:ff.c          **** 	/* Reserve contiguous entries */
 965:ff.c          **** 	res = dir_seek(dj, 0);
 966:ff.c          **** 	if (res != FR_OK) return res;
 967:ff.c          **** 	n = is = 0;
 968:ff.c          **** 	do {
 969:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 970:ff.c          **** 		if (res != FR_OK) break;
 971:ff.c          **** 		c = *dj->dir;				/* Check the entry status */
 972:ff.c          **** 		if (c == 0xE5 || c == 0) {	/* Is it a blank entry? */
 973:ff.c          **** 			if (n == 0) is = dj->index;	/* First index of the contigulus entry */
 974:ff.c          **** 			if (++n == ne) break;	/* A contiguous entry that requiered count is found */
 975:ff.c          **** 		} else {
 976:ff.c          **** 			n = 0;					/* Not a blank entry. Restart to search */
 977:ff.c          **** 		}
 978:ff.c          **** 		res = dir_next(dj, TRUE);	/* Next entry with table streach */
 979:ff.c          **** 	} while (res == FR_OK);
 980:ff.c          **** 
 981:ff.c          **** 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
 982:ff.c          **** 		res = dir_seek(dj, is);
 983:ff.c          **** 		if (res == FR_OK) {
 984:ff.c          **** 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
 985:ff.c          **** 			ne--;
 986:ff.c          **** 			do {					/* Store LFN entries in bottom first */
 987:ff.c          **** 				res = move_window(dj->fs, dj->sect);
 988:ff.c          **** 				if (res != FR_OK) break;
 989:ff.c          **** 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
 990:ff.c          **** 				dj->fs->wflag = 1;
 991:ff.c          **** 				res = dir_next(dj, FALSE);	/* Next entry */
 992:ff.c          **** 			} while (res == FR_OK && --ne);
 993:ff.c          **** 		}
 994:ff.c          **** 	}
 995:ff.c          **** 
 996:ff.c          **** #else	/* Non LFN configuration */
 997:ff.c          **** 	res = dir_seek(dj, 0);
 998:ff.c          **** 	if (res == FR_OK) {
 999:ff.c          **** 		do {	/* Find a blank entry for the SFN */
1000:ff.c          **** 			res = move_window(dj->fs, dj->sect);
1001:ff.c          **** 			if (res != FR_OK) break;
1002:ff.c          **** 			c = *dj->dir;
1003:ff.c          **** 			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
1004:ff.c          **** 			res = dir_next(dj, TRUE);		/* Next entry with table streach */
1005:ff.c          **** 		} while (res == FR_OK);
1006:ff.c          **** 	}
1007:ff.c          **** #endif
1008:ff.c          **** 
1009:ff.c          **** 	if (res == FR_OK) {		/* Initialize the SFN entry */
1010:ff.c          **** 		res = move_window(dj->fs, dj->sect);
1011:ff.c          **** 		if (res == FR_OK) {
1012:ff.c          **** 			dir = dj->dir;
1013:ff.c          **** 			mem_set(dir, 0, 32);		/* Clean the entry */
1014:ff.c          **** 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
1015:ff.c          **** 			dir[DIR_NTres] = *(dj->fn+11) & 0x18;	/* Put NT flag */
1016:ff.c          **** 			dj->fs->wflag = 1;
1017:ff.c          **** 		}
1018:ff.c          **** 	}
1019:ff.c          **** 
1020:ff.c          **** 	return res;
1021:ff.c          **** }
1022:ff.c          **** #endif /* !_FS_READONLY */
1023:ff.c          **** 
1024:ff.c          **** 
1025:ff.c          **** 
1026:ff.c          **** 
1027:ff.c          **** /*-----------------------------------------------------------------------*/
1028:ff.c          **** /* Remove an object from the directory                                   */
1029:ff.c          **** /*-----------------------------------------------------------------------*/
1030:ff.c          **** #if !_FS_READONLY && !_FS_MINIMIZE
1031:ff.c          **** static
1032:ff.c          **** FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
1033:ff.c          **** 	DIR *dj				/* Directory object pointing the entry to be removed */
1034:ff.c          **** )
1035:ff.c          **** {
1036:ff.c          **** 	FRESULT res;
1037:ff.c          **** #if _USE_LFN	/* LFN configuration */
1038:ff.c          **** 	WORD i;
1039:ff.c          **** 
1040:ff.c          **** 	i = dj->index;	/* SFN index */
1041:ff.c          **** 	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of t
1042:ff.c          **** 	if (res == FR_OK) {
1043:ff.c          **** 		do {
1044:ff.c          **** 			res = move_window(dj->fs, dj->sect);
1045:ff.c          **** 			if (res != FR_OK) break;
1046:ff.c          **** 			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
1047:ff.c          **** 			dj->fs->wflag = 1;
1048:ff.c          **** 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
1049:ff.c          **** 			res = dir_next(dj, FALSE);	/* Next entry */
1050:ff.c          **** 		} while (res == FR_OK);
1051:ff.c          **** 		if (res == FR_NO_FILE) res = FR_INT_ERR;
1052:ff.c          **** 	}
1053:ff.c          **** 
1054:ff.c          **** #else			/* Non LFN configuration */
1055:ff.c          **** 	res = dir_seek(dj, dj->index);
1056:ff.c          **** 	if (res == FR_OK) {
1057:ff.c          **** 		res = move_window(dj->fs, dj->sect);
1058:ff.c          **** 		if (res == FR_OK) {
1059:ff.c          **** 			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
1060:ff.c          **** 			dj->fs->wflag = 1;
1061:ff.c          **** 		}
1062:ff.c          **** 	}
1063:ff.c          **** #endif
1064:ff.c          **** 
1065:ff.c          **** 	return res;
1066:ff.c          **** }
1067:ff.c          **** #endif /* !_FS_READONLY */
1068:ff.c          **** 
1069:ff.c          **** 
1070:ff.c          **** 
1071:ff.c          **** 
1072:ff.c          **** /*-----------------------------------------------------------------------*/
1073:ff.c          **** /* Pick a segment and create the object name in directory form           */
1074:ff.c          **** /*-----------------------------------------------------------------------*/
1075:ff.c          **** 
1076:ff.c          **** 
1077:ff.c          **** static
1078:ff.c          **** FRESULT create_name (
1079:ff.c          **** 	DIR *dj,			/* Pointer to the directory object */
1080:ff.c          **** 	const XCHAR **path	/* Pointer to pointer to the segment in the path string */
1081:ff.c          **** )
1082:ff.c          **** {
1083:ff.c          **** #ifdef _EXCVT
1084:ff.c          **** 	static const BYTE cvt[] = _EXCVT;
1085:ff.c          **** #endif
1086:ff.c          **** #if _USE_LFN	/* LFN configuration */
1087:ff.c          **** 	BYTE b, cf;
1088:ff.c          **** 	WCHAR w, *lfn;
1089:ff.c          **** 	int i, ni, si, di;
1090:ff.c          **** 	const XCHAR *p;
1091:ff.c          **** 
1092:ff.c          **** 	/* Create LFN in Unicode */
1093:ff.c          **** 	si = di = 0;
1094:ff.c          **** 	p = *path;
1095:ff.c          **** 	lfn = dj->lfn;
1096:ff.c          **** 	for (;;) {
1097:ff.c          **** 		w = p[si++];					/* Get a character */
1098:ff.c          **** 		if (w < L' ' || w == L'/' || w == L'\\') break;	/* Break on end of segment */
1099:ff.c          **** 		if (di >= _MAX_LFN)				/* Reject too long name */
1100:ff.c          **** 			return FR_INVALID_NAME;
1101:ff.c          **** #if !_LFN_UNICODE
1102:ff.c          **** 		w &= 0xFF;
1103:ff.c          **** 		if (IsDBCS1(w)) {				/* If it is a DBC 1st byte */
1104:ff.c          **** 			BYTE c = p[si++];			/* Get 2nd byte */
1105:ff.c          **** 			if (!IsDBCS2(c))			/* Reject invalid code for DBC */
1106:ff.c          **** 				return FR_INVALID_NAME;
1107:ff.c          **** 			w = (w << 8) + c;
1108:ff.c          **** 		}
1109:ff.c          **** //		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
1110:ff.c          **** 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
1111:ff.c          **** #endif
1112:ff.c          **** 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject unallowable chars for LFN */
1113:ff.c          **** 			return FR_INVALID_NAME;
1114:ff.c          **** 		lfn[di++] = w;					/* Store the Unicode char */
1115:ff.c          **** 	}
1116:ff.c          **** 	*path = &p[si];						/* Rerurn pointer to the next segment */
1117:ff.c          **** 	cf = (w < L' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1118:ff.c          **** #if _FS_RPATH
1119:ff.c          **** 	if ((di == 1 && lfn[di - 1] == L'.') || /* Is this a dot entry? */
1120:ff.c          **** 		(di == 2 && lfn[di - 1] == L'.' && lfn[di - 2] == L'.')) {
1121:ff.c          **** 		lfn[di] = 0;
1122:ff.c          **** 		for (i = 0; i < 11; i++)
1123:ff.c          **** 			dj->fn[i] = (i < di) ? '.' : ' ';
1124:ff.c          **** 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
1125:ff.c          **** 		return FR_OK;
1126:ff.c          **** 	}
1127:ff.c          **** #endif
1128:ff.c          **** 	while (di) {						/* Strip trailing spaces and dots */
1129:ff.c          **** 		w = lfn[di - 1];
1130:ff.c          **** 		if (w != L' ' && w != L'.') break;
1131:ff.c          **** 		di--;
1132:ff.c          **** 	}
1133:ff.c          **** 	if (!di) return FR_INVALID_NAME;	/* Reject null string */
1134:ff.c          **** 
1135:ff.c          **** 	lfn[di] = 0;						/* LFN is created */
1136:ff.c          **** 
1137:ff.c          **** 	/* Create SFN in directory form */
1138:ff.c          **** 	mem_set(dj->fn, ' ', 11);
1139:ff.c          **** 	for (si = 0; lfn[si] == L' ' || lfn[si] == L'.'; si++) ;	/* Strip leading spaces and dots */
1140:ff.c          **** 	if (si) cf |= NS_LOSS | NS_LFN;
1141:ff.c          **** 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
1142:ff.c          **** 
1143:ff.c          **** 	b = i = 0; ni = 8;
1144:ff.c          **** 	for (;;) {
1145:ff.c          **** 		w = lfn[si++];					/* Get an LFN char */
1146:ff.c          **** 		if (!w) break;					/* Break when enf of the LFN */
1147:ff.c          **** 		if (w == L' ' || (w == L'.' && si != di)) {	/* Remove spaces and dots */
1148:ff.c          **** 			cf |= NS_LOSS | NS_LFN; continue;
1149:ff.c          **** 		}
1150:ff.c          **** 
1151:ff.c          **** 		if (i >= ni || si == di) {		/* Extension or end of SFN */
1152:ff.c          **** 			if (ni == 11) {				/* Long extension */
1153:ff.c          **** 				cf |= NS_LOSS | NS_LFN; break;
1154:ff.c          **** 			}
1155:ff.c          **** 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* File name is longer than 8 bytes */
1156:ff.c          **** 			if (si > di) break;			/* No extension */
1157:ff.c          **** 			si = di; i = 8; ni = 11;	/* Enter extension section */
1158:ff.c          **** 			b <<= 2; continue;
1159:ff.c          **** 		}
1160:ff.c          **** 
1161:ff.c          **** 		if (w >= 0x80) {				/* Non ASCII char */
1162:ff.c          **** #ifdef _EXCVT
1163:ff.c          **** 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
1164:ff.c          **** 			if (w) w = cvt[w - 0x80];	/* Convert extend char (SBCS) */
1165:ff.c          **** #else
1166:ff.c          **** 			w = ff_convert(ff_wtoupper(w), 0);	/* Unicode (Caps) -> OEM code */
1167:ff.c          **** #endif
1168:ff.c          **** 			cf |= NS_LFN;				/* Force create an LFN */
1169:ff.c          **** 		}
1170:ff.c          **** 
1171:ff.c          **** 		if (_DF1S && w >= 0x100) {		/* Double byte char */
1172:ff.c          **** 			if (i >= ni - 1) {
1173:ff.c          **** 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1174:ff.c          **** 			}
1175:ff.c          **** 			dj->fn[i++] = (BYTE)(w >> 8);
1176:ff.c          **** 		} else {						/* Single byte char */
1177:ff.c          **** 			if (!w || chk_chr("+,;[=]", w)) {	/* Replace unallowable chars for SFN */
1178:ff.c          **** 				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
1179:ff.c          **** 			} else {
1180:ff.c          **** 				if (IsUpper(w)) {		/* Large capital */
1181:ff.c          **** 					b |= 2;
1182:ff.c          **** 				} else {
1183:ff.c          **** 					if (IsLower(w)) {	/* Small capital */
1184:ff.c          **** 						b |= 1; w -= 0x20;
1185:ff.c          **** 					}
1186:ff.c          **** 				}
1187:ff.c          **** 			}
1188:ff.c          **** 		}
1189:ff.c          **** 		dj->fn[i++] = (BYTE)w;
1190:ff.c          **** 	}
1191:ff.c          **** 
1192:ff.c          **** 	if (dj->fn[0] == 0xE5) dj->fn[0] = 0x05;	/* If the first char collides with 0xE5, replace it with 
1193:ff.c          **** 
1194:ff.c          **** 	if (ni == 8) b <<= 2;
1195:ff.c          **** 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capital
1196:ff.c          **** 		cf |= NS_LFN;
1197:ff.c          **** 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are create
1198:ff.c          **** 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
1199:ff.c          **** 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
1200:ff.c          **** 	}
1201:ff.c          **** 
1202:ff.c          **** 	dj->fn[11] = cf;	/* SFN is created */
1203:ff.c          **** 
1204:ff.c          **** 
1205:ff.c          **** #else	/* Non-LFN configuration */
1206:ff.c          **** 	BYTE b, c, d, *sfn;
1207:ff.c          **** 	int ni, si, i;
1208:ff.c          **** 	const char *p;
1209:ff.c          **** 
1210:ff.c          **** 	/* Create file name in directory form */
1211:ff.c          **** 	sfn = dj->fn;
1212:ff.c          **** 	mem_set(sfn, ' ', 11);
1213:ff.c          **** 	si = i = b = 0; ni = 8;
1214:ff.c          **** 	p = *path;
1215:ff.c          **** #if _FS_RPATH
1216:ff.c          **** 	if (p[si] == '.') { /* Is this a dot entry? */
1217:ff.c          **** 		for (;;) {
1218:ff.c          **** 			c = p[si++];
1219:ff.c          **** 			if (c != '.' || si >= 3) break;
1220:ff.c          **** 			sfn[i++] = c;
1221:ff.c          **** 		}
1222:ff.c          **** 		if (c != '/' && c != '\\' && c >= ' ') return FR_INVALID_NAME;
1223:ff.c          **** 		*path = &p[si];									/* Rerurn pointer to the next segment */
1224:ff.c          **** 		sfn[11] = (c < ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
1225:ff.c          **** 		return FR_OK;
1226:ff.c          **** 	}
1227:ff.c          **** #endif
1228:ff.c          **** 	for (;;) {
1229:ff.c          **** 		c = p[si++];
1230:ff.c          **** 		if (c < ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
1231:ff.c          **** 		if (c == '.' || i >= ni) {
1232:ff.c          **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
1233:ff.c          **** 			i = 8; ni = 11;
1234:ff.c          **** 			b <<= 2; continue;
1235:ff.c          **** 		}
1236:ff.c          **** 		if (c >= 0x80) {				/* Extended char */
1237:ff.c          **** #ifdef _EXCVT
1238:ff.c          **** 			c = cvt[c - 0x80];			/* Convert extend char (SBCS) */
1239:ff.c          **** #else
1240:ff.c          **** 			b |= 3;						/* Eliminate NT flag if ext char is exist */
1241:ff.c          **** #if !_DF1S	/* ASCII only cfg */
1242:ff.c          **** 			return FR_INVALID_NAME;
1243:ff.c          **** #endif
1244:ff.c          **** #endif
1245:ff.c          **** 		}
1246:ff.c          **** 		if (IsDBCS1(c)) {				/* If it is DBC 1st byte */
1247:ff.c          **** 			d = p[si++];				/* Get 2nd byte */
1248:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
1249:ff.c          **** 				return FR_INVALID_NAME;
1250:ff.c          **** 			sfn[i++] = c;
1251:ff.c          **** 			sfn[i++] = d;
1252:ff.c          **** 		} else {
1253:ff.c          **** 			if (chk_chr(" \"*+,[=]|\x7F", c))	/* Reject unallowable chrs for SFN */
1254:ff.c          **** 				return FR_INVALID_NAME;
1255:ff.c          **** 			if (IsUpper(c)) {
1256:ff.c          **** 				b |= 2;
1257:ff.c          **** 			} else {
1258:ff.c          **** 				if (IsLower(c)) {
1259:ff.c          **** 					b |= 1; c -= 0x20;
1260:ff.c          **** 				}
1261:ff.c          **** 			}
1262:ff.c          **** 			sfn[i++] = c;
1263:ff.c          **** 		}
1264:ff.c          **** 	}
1265:ff.c          **** 	*path = &p[si];						/* Rerurn pointer to the next segment */
1266:ff.c          **** 	c = (c < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1267:ff.c          **** 
1268:ff.c          **** 	if (!i) return FR_INVALID_NAME;		/* Reject null string */
1269:ff.c          **** 	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
1270:ff.c          **** 
1271:ff.c          **** 	if (ni == 8) b <<= 2;
1272:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
1273:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
1274:ff.c          **** 
1275:ff.c          **** 	sfn[11] = c;		/* Store NT flag, File name is created */
1276:ff.c          **** #endif
1277:ff.c          **** 
1278:ff.c          **** 	return FR_OK;
1279:ff.c          **** }
1280:ff.c          **** 
1281:ff.c          **** 
1282:ff.c          **** 
1283:ff.c          **** 
1284:ff.c          **** /*-----------------------------------------------------------------------*/
1285:ff.c          **** /* Get file information from directory entry                             */
1286:ff.c          **** /*-----------------------------------------------------------------------*/
1287:ff.c          **** #if _FS_MINIMIZE <= 1
1288:ff.c          **** static
1289:ff.c          **** void get_fileinfo (		/* No return code */
1290:ff.c          **** 	DIR *dj,			/* Pointer to the directory object */
1291:ff.c          **** 	FILINFO *fno	 	/* Pointer to store the file information */
1292:ff.c          **** )
1293:ff.c          **** {
 170              		.loc 1 1293 1 is_stmt 1 view -0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 0
 173              		@ frame_needed = 0, uses_anonymous_args = 0
1294:ff.c          **** 	int i;
 174              		.loc 1 1294 2 view .LVU42
1295:ff.c          **** 	BYTE c, nt, *dir;
 175              		.loc 1 1295 2 view .LVU43
1296:ff.c          **** 	char *p;
 176              		.loc 1 1296 2 view .LVU44
1297:ff.c          **** #if _USE_LFN
1298:ff.c          **** 	XCHAR *tp;
1299:ff.c          **** #endif
1300:ff.c          **** 
1301:ff.c          **** 
1302:ff.c          **** 	p = fno->fname;
 177              		.loc 1 1302 2 view .LVU45
1303:ff.c          **** 	if (dj->sect) {
 178              		.loc 1 1303 5 is_stmt 0 view .LVU46
 179 0000 0269     		ldr	r2, [r0, #16]
1293:ff.c          **** 	int i;
 180              		.loc 1 1293 1 view .LVU47
 181 0002 F0B5     		push	{r4, r5, r6, r7, lr}
 182              		.cfi_def_cfa_offset 20
 183              		.cfi_offset 4, -20
 184              		.cfi_offset 5, -16
 185              		.cfi_offset 6, -12
 186              		.cfi_offset 7, -8
 187              		.cfi_offset 14, -4
1302:ff.c          **** 	if (dj->sect) {
 188              		.loc 1 1302 4 view .LVU48
 189 0004 01F10903 		add	r3, r1, #9
 190              	.LVL18:
 191              		.loc 1 1303 2 is_stmt 1 view .LVU49
 192              		.loc 1 1303 5 is_stmt 0 view .LVU50
 193 0008 002A     		cmp	r2, #0
 194 000a 41D0     		beq	.L15
1304:ff.c          **** 		dir = dj->dir;
 195              		.loc 1 1304 3 is_stmt 1 view .LVU51
 196              		.loc 1 1304 7 is_stmt 0 view .LVU52
 197 000c 4269     		ldr	r2, [r0, #20]
 198              	.LVL19:
1305:ff.c          **** 		nt = dir[DIR_NTres];		/* NT flag */
 199              		.loc 1 1305 3 is_stmt 1 view .LVU53
 200 000e 01F11106 		add	r6, r1, #17
 201              		.loc 1 1305 6 is_stmt 0 view .LVU54
 202 0012 147B     		ldrb	r4, [r2, #12]	@ zero_extendqisi2
 203              	.LVL20:
1306:ff.c          **** 		for (i = 0; i < 8; i++) {	/* Copy name body */
 204              		.loc 1 1306 3 is_stmt 1 view .LVU55
 205              		.loc 1 1306 15 view .LVU56
 206 0014 551E     		subs	r5, r2, #1
1307:ff.c          **** 			c = dir[i];
1308:ff.c          **** 			if (c == ' ') break;
1309:ff.c          **** 			if (c == 0x05) c = 0xE5;
1310:ff.c          **** 			if ((nt & 0x08) && IsUpper(c)) c += 0x20;
 207              		.loc 1 1310 7 is_stmt 0 view .LVU57
 208 0016 04F00807 		and	r7, r4, #8
 209              	.LVL21:
 210              	.L19:
1307:ff.c          **** 			c = dir[i];
 211              		.loc 1 1307 4 is_stmt 1 view .LVU58
1307:ff.c          **** 			c = dir[i];
 212              		.loc 1 1307 6 is_stmt 0 view .LVU59
 213 001a 15F8010F 		ldrb	r0, [r5, #1]!	@ zero_extendqisi2
 214              	.LVL22:
1308:ff.c          **** 			if (c == 0x05) c = 0xE5;
 215              		.loc 1 1308 4 is_stmt 1 view .LVU60
1308:ff.c          **** 			if (c == 0x05) c = 0xE5;
 216              		.loc 1 1308 7 is_stmt 0 view .LVU61
 217 001e 2028     		cmp	r0, #32
 218 0020 0ED0     		beq	.L16
1309:ff.c          **** 			if ((nt & 0x08) && IsUpper(c)) c += 0x20;
 219              		.loc 1 1309 4 is_stmt 1 view .LVU62
1309:ff.c          **** 			if ((nt & 0x08) && IsUpper(c)) c += 0x20;
 220              		.loc 1 1309 21 is_stmt 0 view .LVU63
 221 0022 0528     		cmp	r0, #5
 222 0024 08BF     		it	eq
 223 0026 E520     		moveq	r0, #229
 224              	.LVL23:
 225              		.loc 1 1310 4 is_stmt 1 view .LVU64
 226              		.loc 1 1310 7 is_stmt 0 view .LVU65
 227 0028 37B1     		cbz	r7, .L18
 228              		.loc 1 1310 20 discriminator 1 view .LVU66
 229 002a A0F1410C 		sub	ip, r0, #65
 230 002e BCF1190F 		cmp	ip, #25
 231              		.loc 1 1310 35 is_stmt 1 discriminator 1 view .LVU67
 232              		.loc 1 1310 37 is_stmt 0 discriminator 1 view .LVU68
 233 0032 9CBF     		itt	ls
 234 0034 2030     		addls	r0, r0, #32
 235              	.LVL24:
 236              		.loc 1 1310 37 discriminator 1 view .LVU69
 237 0036 C0B2     		uxtbls	r0, r0
 238              	.LVL25:
 239              	.L18:
1311:ff.c          **** 			*p++ = c;
 240              		.loc 1 1311 4 is_stmt 1 discriminator 2 view .LVU70
 241              		.loc 1 1311 9 is_stmt 0 discriminator 2 view .LVU71
 242 0038 03F8010B 		strb	r0, [r3], #1
 243              	.LVL26:
1306:ff.c          **** 			c = dir[i];
 244              		.loc 1 1306 22 is_stmt 1 discriminator 2 view .LVU72
1306:ff.c          **** 			c = dir[i];
 245              		.loc 1 1306 15 discriminator 2 view .LVU73
1306:ff.c          **** 			c = dir[i];
 246              		.loc 1 1306 3 is_stmt 0 discriminator 2 view .LVU74
 247 003c B342     		cmp	r3, r6
 248 003e ECD1     		bne	.L19
 249              	.L16:
1312:ff.c          **** 		}
1313:ff.c          **** 		if (dir[8] != ' ') {		/* Copy name extension */
 250              		.loc 1 1313 3 is_stmt 1 view .LVU75
 251              		.loc 1 1313 6 is_stmt 0 view .LVU76
 252 0040 107A     		ldrb	r0, [r2, #8]	@ zero_extendqisi2
 253              	.LVL27:
 254              		.loc 1 1313 6 view .LVU77
 255 0042 2028     		cmp	r0, #32
 256 0044 16D0     		beq	.L20
1314:ff.c          **** 			*p++ = '.';
 257              		.loc 1 1314 4 is_stmt 1 view .LVU78
 258              	.LVL28:
 259              		.loc 1 1314 9 is_stmt 0 view .LVU79
 260 0046 1D46     		mov	r5, r3
 261 0048 2E20     		movs	r0, #46
 262 004a D61D     		adds	r6, r2, #7
 263 004c 05F8040B 		strb	r0, [r5], #4
1315:ff.c          **** 			for (i = 8; i < 11; i++) {
 264              		.loc 1 1315 4 is_stmt 1 view .LVU80
 265              	.LVL29:
 266              		.loc 1 1315 16 view .LVU81
1314:ff.c          **** 			*p++ = '.';
 267              		.loc 1 1314 6 is_stmt 0 view .LVU82
 268 0050 0133     		adds	r3, r3, #1
 269              	.LVL30:
1316:ff.c          **** 				c = dir[i];
1317:ff.c          **** 				if (c == ' ') break;
1318:ff.c          **** 				if ((nt & 0x10) && IsUpper(c)) c += 0x20;
 270              		.loc 1 1318 8 view .LVU83
 271 0052 04F01004 		and	r4, r4, #16
 272              	.LVL31:
 273              	.L22:
1316:ff.c          **** 				c = dir[i];
 274              		.loc 1 1316 5 is_stmt 1 view .LVU84
1316:ff.c          **** 				c = dir[i];
 275              		.loc 1 1316 7 is_stmt 0 view .LVU85
 276 0056 16F8010F 		ldrb	r0, [r6, #1]!	@ zero_extendqisi2
 277              	.LVL32:
1317:ff.c          **** 				if ((nt & 0x10) && IsUpper(c)) c += 0x20;
 278              		.loc 1 1317 5 is_stmt 1 view .LVU86
1317:ff.c          **** 				if ((nt & 0x10) && IsUpper(c)) c += 0x20;
 279              		.loc 1 1317 8 is_stmt 0 view .LVU87
 280 005a 2028     		cmp	r0, #32
 281 005c 0AD0     		beq	.L20
 282              		.loc 1 1318 5 is_stmt 1 view .LVU88
 283              		.loc 1 1318 8 is_stmt 0 view .LVU89
 284 005e 2CB1     		cbz	r4, .L21
 285              		.loc 1 1318 21 discriminator 1 view .LVU90
 286 0060 A0F14107 		sub	r7, r0, #65
 287 0064 192F     		cmp	r7, #25
 288              		.loc 1 1318 36 is_stmt 1 discriminator 1 view .LVU91
 289              		.loc 1 1318 38 is_stmt 0 discriminator 1 view .LVU92
 290 0066 9CBF     		itt	ls
 291 0068 2030     		addls	r0, r0, #32
 292              	.LVL33:
 293              		.loc 1 1318 38 discriminator 1 view .LVU93
 294 006a C0B2     		uxtbls	r0, r0
 295              	.LVL34:
 296              	.L21:
1319:ff.c          **** 				*p++ = c;
 297              		.loc 1 1319 5 is_stmt 1 discriminator 2 view .LVU94
 298              		.loc 1 1319 10 is_stmt 0 discriminator 2 view .LVU95
 299 006c 03F8010B 		strb	r0, [r3], #1
 300              	.LVL35:
1315:ff.c          **** 				c = dir[i];
 301              		.loc 1 1315 24 is_stmt 1 discriminator 2 view .LVU96
1315:ff.c          **** 				c = dir[i];
 302              		.loc 1 1315 16 discriminator 2 view .LVU97
1315:ff.c          **** 				c = dir[i];
 303              		.loc 1 1315 4 is_stmt 0 discriminator 2 view .LVU98
 304 0070 9D42     		cmp	r5, r3
 305 0072 F0D1     		bne	.L22
 306              	.LVL36:
 307              	.L20:
1320:ff.c          **** 			}
1321:ff.c          **** 		}
1322:ff.c          **** 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 308              		.loc 1 1322 3 is_stmt 1 view .LVU99
 309              		.loc 1 1322 16 is_stmt 0 view .LVU100
 310 0074 D07A     		ldrb	r0, [r2, #11]	@ zero_extendqisi2
 311 0076 0872     		strb	r0, [r1, #8]
1323:ff.c          **** 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 312              		.loc 1 1323 3 is_stmt 1 view .LVU101
 313              		.loc 1 1323 16 is_stmt 0 view .LVU102
 314 0078 D069     		ldr	r0, [r2, #28]	@ unaligned
 315              		.loc 1 1323 14 view .LVU103
 316 007a 0860     		str	r0, [r1]
1324:ff.c          **** 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 317              		.loc 1 1324 3 is_stmt 1 view .LVU104
 318              		.loc 1 1324 16 is_stmt 0 view .LVU105
 319 007c 547E     		ldrb	r4, [r2, #25]	@ zero_extendqisi2
 320 007e 107E     		ldrb	r0, [r2, #24]	@ zero_extendqisi2
 321 0080 40EA0420 		orr	r0, r0, r4, lsl #8
 322              		.loc 1 1324 14 view .LVU106
 323 0084 8880     		strh	r0, [r1, #4]	@ movhi
1325:ff.c          **** 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 324              		.loc 1 1325 3 is_stmt 1 view .LVU107
 325              		.loc 1 1325 16 is_stmt 0 view .LVU108
 326 0086 D07D     		ldrb	r0, [r2, #23]	@ zero_extendqisi2
 327 0088 927D     		ldrb	r2, [r2, #22]	@ zero_extendqisi2
 328              	.LVL37:
 329              		.loc 1 1325 16 view .LVU109
 330 008a 42EA0022 		orr	r2, r2, r0, lsl #8
 331              		.loc 1 1325 14 view .LVU110
 332 008e CA80     		strh	r2, [r1, #6]	@ movhi
 333              	.L15:
1326:ff.c          **** 	}
1327:ff.c          **** 	*p = 0;
 334              		.loc 1 1327 2 is_stmt 1 view .LVU111
 335              		.loc 1 1327 5 is_stmt 0 view .LVU112
 336 0090 0022     		movs	r2, #0
 337 0092 1A70     		strb	r2, [r3]
1328:ff.c          **** 
1329:ff.c          **** #if _USE_LFN
1330:ff.c          **** 	tp = fno->lfname;
1331:ff.c          **** 	if (tp) {
1332:ff.c          **** 		WCHAR w, *lfn;
1333:ff.c          **** 
1334:ff.c          **** 		i = 0;
1335:ff.c          **** 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1336:ff.c          **** 			lfn = dj->lfn;
1337:ff.c          **** 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
1338:ff.c          **** #if !_LFN_UNICODE
1339:ff.c          **** //				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
1340:ff.c          **** 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
1341:ff.c          **** 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC */
1342:ff.c          **** 					tp[i++] = (XCHAR)(w >> 8);
1343:ff.c          **** 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
1344:ff.c          **** #endif
1345:ff.c          **** 				tp[i++] = (XCHAR)w;
1346:ff.c          **** 			}
1347:ff.c          **** 		}
1348:ff.c          **** 		tp[i] = 0;	/* Terminator */
1349:ff.c          **** 	}
1350:ff.c          **** #endif
1351:ff.c          **** }
 338              		.loc 1 1351 1 view .LVU113
 339 0094 F0BD     		pop	{r4, r5, r6, r7, pc}
 340              		.cfi_endproc
 341              	.LFE47:
 343              		.section	.text.validate,"ax",%progbits
 344              		.align	1
 345              		.syntax unified
 346              		.thumb
 347              		.thumb_func
 348              		.fpu softvfp
 350              	validate:
 351              	.LVL38:
 352              	.LFB51:
1352:ff.c          **** #endif /* _FS_MINIMIZE <= 1 */
1353:ff.c          **** 
1354:ff.c          **** 
1355:ff.c          **** 
1356:ff.c          **** 
1357:ff.c          **** /*-----------------------------------------------------------------------*/
1358:ff.c          **** /* Follow a file path                                                    */
1359:ff.c          **** /*-----------------------------------------------------------------------*/
1360:ff.c          **** 
1361:ff.c          **** static
1362:ff.c          **** FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
1363:ff.c          **** 	DIR *dj,			/* Directory object to return last directory and found object */
1364:ff.c          **** 	const XCHAR *path	/* Full-path string to find a file or directory */
1365:ff.c          **** )
1366:ff.c          **** {
1367:ff.c          **** 	FRESULT res;
1368:ff.c          **** 	BYTE *dir, last;
1369:ff.c          **** 
1370:ff.c          **** 
1371:ff.c          **** #if _FS_RPATH
1372:ff.c          **** 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1373:ff.c          **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
1374:ff.c          **** 	} else {							/* No heading saparator */
1375:ff.c          **** 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
1376:ff.c          **** 	}
1377:ff.c          **** #else
1378:ff.c          **** 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
1379:ff.c          **** 		path++;
1380:ff.c          **** 	dj->sclust = 0;						/* Start from the root dir */
1381:ff.c          **** #endif
1382:ff.c          **** 
1383:ff.c          **** 	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
1384:ff.c          **** 		res = dir_seek(dj, 0);
1385:ff.c          **** 		dj->dir = NULL;
1386:ff.c          **** 
1387:ff.c          **** 	} else {							/* Follow path */
1388:ff.c          **** 		for (;;) {
1389:ff.c          **** 			res = create_name(dj, &path);	/* Get a segment */
1390:ff.c          **** 			if (res != FR_OK) break;
1391:ff.c          **** 			res = dir_find(dj);				/* Find it */
1392:ff.c          **** 			last = *(dj->fn+11) & NS_LAST;
1393:ff.c          **** 			if (res != FR_OK) {				/* Could not find the object */
1394:ff.c          **** 				if (res == FR_NO_FILE && !last)
1395:ff.c          **** 					res = FR_NO_PATH;
1396:ff.c          **** 				break;
1397:ff.c          **** 			}
1398:ff.c          **** 			if (last) break;				/* Last segment match. Function completed. */
1399:ff.c          **** 			dir = dj->dir;					/* There is next segment. Follow the sub directory */
1400:ff.c          **** 			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
1401:ff.c          **** 				res = FR_NO_PATH; break;
1402:ff.c          **** 			}
1403:ff.c          **** 			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
1404:ff.c          **** 		}
1405:ff.c          **** 	}
1406:ff.c          **** 
1407:ff.c          **** 	return res;
1408:ff.c          **** }
1409:ff.c          **** 
1410:ff.c          **** 
1411:ff.c          **** 
1412:ff.c          **** 
1413:ff.c          **** /*-----------------------------------------------------------------------*/
1414:ff.c          **** /* Load boot record and check if it is an FAT boot record                */
1415:ff.c          **** /*-----------------------------------------------------------------------*/
1416:ff.c          **** 
1417:ff.c          **** static
1418:ff.c          **** BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 
1419:ff.c          **** 	FATFS *fs,	/* File system object */
1420:ff.c          **** 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
1421:ff.c          **** )
1422:ff.c          **** {
1423:ff.c          **** 	static const char fatstr[] = "FAT";
1424:ff.c          **** 
1425:ff.c          **** 
1426:ff.c          **** 	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
1427:ff.c          **** 		return 3;
1428:ff.c          **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
1429:ff.c          **** 		return 2;
1430:ff.c          **** 
1431:ff.c          **** 	if (!mem_cmp(&fs->win[BS_FilSysType], fatstr, 3))	/* Check FAT signature */
1432:ff.c          **** 		return 0;
1433:ff.c          **** 	if (!mem_cmp(&fs->win[BS_FilSysType32], fatstr, 3) && !(fs->win[BPB_ExtFlags] & 0x80))
1434:ff.c          **** 		return 0;
1435:ff.c          **** 
1436:ff.c          **** 	return 1;
1437:ff.c          **** }
1438:ff.c          **** 
1439:ff.c          **** 
1440:ff.c          **** 
1441:ff.c          **** 
1442:ff.c          **** /*-----------------------------------------------------------------------*/
1443:ff.c          **** /* Make sure that the file system is valid                               */
1444:ff.c          **** /*-----------------------------------------------------------------------*/
1445:ff.c          **** 
1446:ff.c          **** static
1447:ff.c          **** FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
1448:ff.c          **** 	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
1449:ff.c          **** 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
1450:ff.c          **** 	BYTE chk_wp			/* !=0: Check media write protection for write access */
1451:ff.c          **** )
1452:ff.c          **** {
1453:ff.c          **** 	FRESULT res;
1454:ff.c          **** 	BYTE fmt, *tbl;
1455:ff.c          **** 	UINT vol;
1456:ff.c          **** 	DSTATUS stat;
1457:ff.c          **** 	DWORD bsect, fsize, tsect, mclst;
1458:ff.c          **** 	const XCHAR *p = *path;
1459:ff.c          **** 	FATFS *fs;
1460:ff.c          **** 
1461:ff.c          **** 
1462:ff.c          **** 	/* Get logical drive number from the path name */
1463:ff.c          **** 	vol = p[0] - '0';				/* Is there a drive number? */
1464:ff.c          **** 	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
1465:ff.c          **** 		p += 2; *path = p;			/* Return pointer to the path name */
1466:ff.c          **** 	} else {						/* No drive number is given */
1467:ff.c          **** #if _FS_RPATH
1468:ff.c          **** 		vol = Drive;				/* Use current drive */
1469:ff.c          **** #else
1470:ff.c          **** 		vol = 0;					/* Use drive 0 */
1471:ff.c          **** #endif
1472:ff.c          **** 	}
1473:ff.c          **** 
1474:ff.c          **** 	/* Check if the logical drive is valid or not */
1475:ff.c          **** 	if (vol >= _DRIVES) 			/* Is the drive number valid? */
1476:ff.c          **** 		return FR_INVALID_DRIVE;
1477:ff.c          **** 	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
1478:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object registered? */
1479:ff.c          **** 
1480:ff.c          **** 	ENTER_FF(fs);					/* Lock file system */
1481:ff.c          **** 
1482:ff.c          **** 	if (fs->fs_type) {				/* If the logical drive has been mounted */
1483:ff.c          **** 		stat = disk_status(fs->drive);
1484:ff.c          **** 		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed),
1485:ff.c          **** #if !_FS_READONLY
1486:ff.c          **** 			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
1487:ff.c          **** 				return FR_WRITE_PROTECTED;
1488:ff.c          **** #endif
1489:ff.c          **** 			return FR_OK;			/* The file system object is valid */
1490:ff.c          **** 		}
1491:ff.c          **** 	}
1492:ff.c          **** 
1493:ff.c          **** 	/* The logical drive must be mounted. Following code attempts to mount the volume */
1494:ff.c          **** 
1495:ff.c          **** 	fs->fs_type = 0;					/* Clear the file system object */
1496:ff.c          **** 	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
1497:ff.c          **** 	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
1498:ff.c          **** 	if (stat & STA_NOINIT)				/* Check if the drive is ready */
1499:ff.c          **** 		return FR_NOT_READY;
1500:ff.c          **** #if _MAX_SS != 512						/* Get disk sector size if needed */
1501:ff.c          **** 	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
1502:ff.c          **** 		return FR_NO_FILESYSTEM;
1503:ff.c          **** #endif
1504:ff.c          **** #if !_FS_READONLY
1505:ff.c          **** 	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
1506:ff.c          **** 		return FR_WRITE_PROTECTED;
1507:ff.c          **** #endif
1508:ff.c          **** 	/* Search FAT partition on the drive */
1509:ff.c          **** 	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
1510:ff.c          **** 	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
1511:ff.c          **** 		/* Check a partition listed in top of the partition table */
1512:ff.c          **** 		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
1513:ff.c          **** 		if (tbl[4]) {									/* Is the partition existing? */
1514:ff.c          **** 			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
1515:ff.c          **** 			fmt = check_fs(fs, bsect);					/* Check the partition */
1516:ff.c          **** 		}
1517:ff.c          **** 	}
1518:ff.c          **** 	if (fmt == 3) return FR_DISK_ERR;
1519:ff.c          **** 	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
1520:ff.c          **** 		return FR_NO_FILESYSTEM;
1521:ff.c          **** 
1522:ff.c          **** 	/* Initialize the file system object */
1523:ff.c          **** 	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
1524:ff.c          **** 	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
1525:ff.c          **** 	fs->sects_fat = fsize;
1526:ff.c          **** 	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
1527:ff.c          **** 	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
1528:ff.c          **** 	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
1529:ff.c          **** 	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
1530:ff.c          **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
1531:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
1532:ff.c          **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
1533:ff.c          **** 	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
1534:ff.c          **** 		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
1535:ff.c          **** 		) / fs->csize + 2;
1536:ff.c          **** 
1537:ff.c          **** 	fmt = FS_FAT12;										/* Determine the FAT sub type */
1538:ff.c          **** 	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
1539:ff.c          **** 	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
1540:ff.c          **** 
1541:ff.c          **** 	if (fmt == FS_FAT32)
1542:ff.c          **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
1543:ff.c          **** 	else
1544:ff.c          **** 		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
1545:ff.c          **** 	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
1546:ff.c          **** 
1547:ff.c          **** #if !_FS_READONLY
1548:ff.c          **** 	/* Initialize allocation information */
1549:ff.c          **** 	fs->free_clust = 0xFFFFFFFF;
1550:ff.c          **** 	fs->wflag = 0;
1551:ff.c          **** 	/* Get fsinfo if needed */
1552:ff.c          **** 	if (fmt == FS_FAT32) {
1553:ff.c          **** 	 	fs->fsi_flag = 0;
1554:ff.c          **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
1555:ff.c          **** 		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
1556:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
1557:ff.c          **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
1558:ff.c          **** 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
1559:ff.c          **** 			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
1560:ff.c          **** 			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
1561:ff.c          **** 		}
1562:ff.c          **** 	}
1563:ff.c          **** #endif
1564:ff.c          **** 	fs->fs_type = fmt;		/* FAT sub-type */
1565:ff.c          **** 	fs->winsect = 0;		/* Invalidate sector cache */
1566:ff.c          **** #if _FS_RPATH
1567:ff.c          **** 	fs->cdir = 0;			/* Current directory (root dir) */
1568:ff.c          **** #endif
1569:ff.c          **** 	fs->id = ++Fsid;		/* File system mount ID */
1570:ff.c          **** 	res = FR_OK;
1571:ff.c          **** 
1572:ff.c          **** 	return res;
1573:ff.c          **** }
1574:ff.c          **** 
1575:ff.c          **** 
1576:ff.c          **** 
1577:ff.c          **** 
1578:ff.c          **** /*-----------------------------------------------------------------------*/
1579:ff.c          **** /* Check if the file/dir object is valid or not                          */
1580:ff.c          **** /*-----------------------------------------------------------------------*/
1581:ff.c          **** 
1582:ff.c          **** static
1583:ff.c          **** FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
1584:ff.c          **** 	FATFS *fs,		/* Pointer to the file system object */
1585:ff.c          **** 	WORD id			/* Member id of the target object to be checked */
1586:ff.c          **** )
1587:ff.c          **** {
 353              		.loc 1 1587 1 is_stmt 1 view -0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
1588:ff.c          **** 	if (!fs || !fs->fs_type || fs->id != id)
 357              		.loc 1 1588 2 view .LVU115
1587:ff.c          **** 	if (!fs || !fs->fs_type || fs->id != id)
 358              		.loc 1 1587 1 is_stmt 0 view .LVU116
 359 0000 08B5     		push	{r3, lr}
 360              		.cfi_def_cfa_offset 8
 361              		.cfi_offset 3, -8
 362              		.cfi_offset 14, -4
 363              		.loc 1 1588 5 view .LVU117
 364 0002 60B1     		cbz	r0, .L47
 365              		.loc 1 1588 10 discriminator 1 view .LVU118
 366 0004 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 367 0006 53B1     		cbz	r3, .L47
 368              		.loc 1 1588 26 discriminator 2 view .LVU119
 369 0008 C388     		ldrh	r3, [r0, #6]
 370 000a 8B42     		cmp	r3, r1
 371 000c 07D1     		bne	.L47
 372              	.LVL39:
 373              	.LBB5:
 374              	.LBI5:
1583:ff.c          **** 	FATFS *fs,		/* Pointer to the file system object */
 375              		.loc 1 1583 9 is_stmt 1 view .LVU120
 376              	.LBB6:
1589:ff.c          **** 		return FR_INVALID_OBJECT;
1590:ff.c          **** 
1591:ff.c          **** 	ENTER_FF(fs);		/* Lock file system */
 377              		.loc 1 1591 14 view .LVU121
1592:ff.c          **** 
1593:ff.c          **** 	if (disk_status(fs->drive) & STA_NOINIT)
 378              		.loc 1 1593 2 view .LVU122
 379              		.loc 1 1593 6 is_stmt 0 view .LVU123
 380 000e 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 381              	.LVL40:
 382              		.loc 1 1593 6 view .LVU124
 383 0010 FFF7FEFF 		bl	disk_status
 384              	.LVL41:
 385              		.loc 1 1593 5 view .LVU125
 386 0014 10F00100 		ands	r0, r0, #1
1594:ff.c          **** 		return FR_NOT_READY;
 387              		.loc 1 1594 10 view .LVU126
 388 0018 18BF     		it	ne
 389 001a 0320     		movne	r0, #3
 390              	.LVL42:
 391              	.L44:
 392              		.loc 1 1594 10 view .LVU127
 393              	.LBE6:
 394              	.LBE5:
1595:ff.c          **** 
1596:ff.c          **** 	return FR_OK;
1597:ff.c          **** }
 395              		.loc 1 1597 1 view .LVU128
 396 001c 08BD     		pop	{r3, pc}
 397              	.LVL43:
 398              	.L47:
1589:ff.c          **** 
 399              		.loc 1 1589 10 view .LVU129
 400 001e 0920     		movs	r0, #9
 401              	.LVL44:
1589:ff.c          **** 
 402              		.loc 1 1589 10 view .LVU130
 403 0020 FCE7     		b	.L44
 404              		.cfi_endproc
 405              	.LFE51:
 407              		.section	.text.check_fs,"ax",%progbits
 408              		.align	1
 409              		.syntax unified
 410              		.thumb
 411              		.thumb_func
 412              		.fpu softvfp
 414              	check_fs:
 415              	.LVL45:
 416              	.LFB49:
1422:ff.c          **** 	static const char fatstr[] = "FAT";
 417              		.loc 1 1422 1 is_stmt 1 view -0
 418              		.cfi_startproc
 419              		@ args = 0, pretend = 0, frame = 0
 420              		@ frame_needed = 0, uses_anonymous_args = 0
1422:ff.c          **** 	static const char fatstr[] = "FAT";
 421              		.loc 1 1422 1 is_stmt 0 view .LVU132
 422 0000 38B5     		push	{r3, r4, r5, lr}
 423              		.cfi_def_cfa_offset 16
 424              		.cfi_offset 3, -16
 425              		.cfi_offset 4, -12
 426              		.cfi_offset 5, -8
 427              		.cfi_offset 14, -4
1422:ff.c          **** 	static const char fatstr[] = "FAT";
 428              		.loc 1 1422 1 view .LVU133
 429 0002 0A46     		mov	r2, r1
 430 0004 0546     		mov	r5, r0
1423:ff.c          **** 
 431              		.loc 1 1423 2 is_stmt 1 view .LVU134
1426:ff.c          **** 		return 3;
 432              		.loc 1 1426 2 view .LVU135
1426:ff.c          **** 		return 3;
 433              		.loc 1 1426 6 is_stmt 0 view .LVU136
 434 0006 00F13401 		add	r1, r0, #52
 435              	.LVL46:
1426:ff.c          **** 		return 3;
 436              		.loc 1 1426 6 view .LVU137
 437 000a 0123     		movs	r3, #1
 438 000c 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 439              	.LVL47:
1426:ff.c          **** 		return 3;
 440              		.loc 1 1426 6 view .LVU138
 441 000e FFF7FEFF 		bl	disk_read
 442              	.LVL48:
1426:ff.c          **** 		return 3;
 443              		.loc 1 1426 5 view .LVU139
 444 0012 0446     		mov	r4, r0
 445 0014 E0B9     		cbnz	r0, .L52
1428:ff.c          **** 		return 2;
 446              		.loc 1 1428 2 is_stmt 1 view .LVU140
1428:ff.c          **** 		return 2;
 447              		.loc 1 1428 6 is_stmt 0 view .LVU141
 448 0016 95F83322 		ldrb	r2, [r5, #563]	@ zero_extendqisi2
 449 001a 95F83232 		ldrb	r3, [r5, #562]	@ zero_extendqisi2
 450 001e 43EA0223 		orr	r3, r3, r2, lsl #8
1428:ff.c          **** 		return 2;
 451              		.loc 1 1428 5 view .LVU142
 452 0022 4AF65522 		movw	r2, #43605
 453 0026 9342     		cmp	r3, r2
 454 0028 14D1     		bne	.L53
1431:ff.c          **** 		return 0;
 455              		.loc 1 1431 2 is_stmt 1 view .LVU143
1431:ff.c          **** 		return 0;
 456              		.loc 1 1431 7 is_stmt 0 view .LVU144
 457 002a 0322     		movs	r2, #3
 458 002c 0B49     		ldr	r1, .L58
 459 002e 05F16A00 		add	r0, r5, #106
 460 0032 FFF7FEFF 		bl	mem_cmp
 461              	.LVL49:
1431:ff.c          **** 		return 0;
 462              		.loc 1 1431 5 view .LVU145
 463 0036 48B1     		cbz	r0, .L51
 464              	.LVL50:
 465              	.LBB9:
 466              	.LBI9:
1418:ff.c          **** 	FATFS *fs,	/* File system object */
 467              		.loc 1 1418 6 is_stmt 1 view .LVU146
 468              	.LBB10:
1433:ff.c          **** 		return 0;
 469              		.loc 1 1433 2 view .LVU147
1433:ff.c          **** 		return 0;
 470              		.loc 1 1433 7 is_stmt 0 view .LVU148
 471 0038 0322     		movs	r2, #3
 472 003a 0849     		ldr	r1, .L58
 473 003c 05F18600 		add	r0, r5, #134
 474 0040 FFF7FEFF 		bl	mem_cmp
 475              	.LVL51:
1433:ff.c          **** 		return 0;
 476              		.loc 1 1433 5 view .LVU149
 477 0044 40B9     		cbnz	r0, .L54
1433:ff.c          **** 		return 0;
 478              		.loc 1 1433 53 view .LVU150
 479 0046 95F85C40 		ldrb	r4, [r5, #92]	@ zero_extendqisi2
 480              	.LBE10:
 481              	.LBE9:
1427:ff.c          **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
 482              		.loc 1 1427 10 view .LVU151
 483 004a E409     		lsrs	r4, r4, #7
 484              	.LVL52:
 485              	.L51:
1437:ff.c          **** 
 486              		.loc 1 1437 1 view .LVU152
 487 004c 2046     		mov	r0, r4
 488 004e 38BD     		pop	{r3, r4, r5, pc}
 489              	.LVL53:
 490              	.L52:
1427:ff.c          **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
 491              		.loc 1 1427 10 view .LVU153
 492 0050 0324     		movs	r4, #3
 493 0052 FBE7     		b	.L51
 494              	.L53:
1429:ff.c          **** 
 495              		.loc 1 1429 10 view .LVU154
 496 0054 0224     		movs	r4, #2
 497 0056 F9E7     		b	.L51
 498              	.LVL54:
 499              	.L54:
 500              	.LBB12:
 501              	.LBB11:
1436:ff.c          **** }
 502              		.loc 1 1436 9 view .LVU155
 503 0058 0124     		movs	r4, #1
 504 005a F7E7     		b	.L51
 505              	.L59:
 506              		.align	2
 507              	.L58:
 508 005c 00000000 		.word	.LANCHOR0
 509              	.LBE11:
 510              	.LBE12:
 511              		.cfi_endproc
 512              	.LFE49:
 514              		.section	.text.auto_mount,"ax",%progbits
 515              		.align	1
 516              		.syntax unified
 517              		.thumb
 518              		.thumb_func
 519              		.fpu softvfp
 521              	auto_mount:
 522              	.LVL55:
 523              	.LFB50:
1452:ff.c          **** 	FRESULT res;
 524              		.loc 1 1452 1 is_stmt 1 view -0
 525              		.cfi_startproc
 526              		@ args = 0, pretend = 0, frame = 0
 527              		@ frame_needed = 0, uses_anonymous_args = 0
1453:ff.c          **** 	BYTE fmt, *tbl;
 528              		.loc 1 1453 2 view .LVU157
1454:ff.c          **** 	UINT vol;
 529              		.loc 1 1454 2 view .LVU158
1455:ff.c          **** 	DSTATUS stat;
 530              		.loc 1 1455 2 view .LVU159
1456:ff.c          **** 	DWORD bsect, fsize, tsect, mclst;
 531              		.loc 1 1456 2 view .LVU160
1457:ff.c          **** 	const XCHAR *p = *path;
 532              		.loc 1 1457 2 view .LVU161
1458:ff.c          **** 	FATFS *fs;
 533              		.loc 1 1458 2 view .LVU162
1452:ff.c          **** 	FRESULT res;
 534              		.loc 1 1452 1 is_stmt 0 view .LVU163
 535 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 536              		.cfi_def_cfa_offset 24
 537              		.cfi_offset 3, -24
 538              		.cfi_offset 4, -20
 539              		.cfi_offset 5, -16
 540              		.cfi_offset 6, -12
 541              		.cfi_offset 7, -8
 542              		.cfi_offset 14, -4
1458:ff.c          **** 	FATFS *fs;
 543              		.loc 1 1458 15 view .LVU164
 544 0002 0368     		ldr	r3, [r0]
 545              	.LVL56:
1459:ff.c          **** 
 546              		.loc 1 1459 2 is_stmt 1 view .LVU165
1463:ff.c          **** 	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
 547              		.loc 1 1463 2 view .LVU166
1452:ff.c          **** 	FRESULT res;
 548              		.loc 1 1452 1 is_stmt 0 view .LVU167
 549 0004 1546     		mov	r5, r2
1463:ff.c          **** 	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
 550              		.loc 1 1463 9 view .LVU168
 551 0006 1E78     		ldrb	r6, [r3]	@ zero_extendqisi2
1463:ff.c          **** 	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
 552              		.loc 1 1463 13 view .LVU169
 553 0008 303E     		subs	r6, r6, #48
 554              	.LVL57:
1464:ff.c          **** 		p += 2; *path = p;			/* Return pointer to the path name */
 555              		.loc 1 1464 2 is_stmt 1 view .LVU170
1464:ff.c          **** 		p += 2; *path = p;			/* Return pointer to the path name */
 556              		.loc 1 1464 5 is_stmt 0 view .LVU171
 557 000a 092E     		cmp	r6, #9
 558 000c 1BD8     		bhi	.L61
1464:ff.c          **** 		p += 2; *path = p;			/* Return pointer to the path name */
 559              		.loc 1 1464 15 discriminator 1 view .LVU172
 560 000e 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 561              	.LVL58:
1464:ff.c          **** 		p += 2; *path = p;			/* Return pointer to the path name */
 562              		.loc 1 1464 15 discriminator 1 view .LVU173
 563 0010 3A2A     		cmp	r2, #58
 564 0012 18D1     		bne	.L61
1465:ff.c          **** 	} else {						/* No drive number is given */
 565              		.loc 1 1465 3 is_stmt 1 view .LVU174
 566              	.LVL59:
1465:ff.c          **** 	} else {						/* No drive number is given */
 567              		.loc 1 1465 11 view .LVU175
1465:ff.c          **** 	} else {						/* No drive number is given */
 568              		.loc 1 1465 5 is_stmt 0 view .LVU176
 569 0014 0233     		adds	r3, r3, #2
 570              	.LVL60:
1465:ff.c          **** 	} else {						/* No drive number is given */
 571              		.loc 1 1465 17 view .LVU177
 572 0016 0360     		str	r3, [r0]
 573              	.LVL61:
 574              	.L62:
1475:ff.c          **** 		return FR_INVALID_DRIVE;
 575              		.loc 1 1475 2 is_stmt 1 view .LVU178
1475:ff.c          **** 		return FR_INVALID_DRIVE;
 576              		.loc 1 1475 5 is_stmt 0 view .LVU179
 577 0018 002E     		cmp	r6, #0
 578 001a 40F0C980 		bne	.L79
1477:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object registered? */
 579              		.loc 1 1477 2 is_stmt 1 view .LVU180
1477:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object registered? */
 580              		.loc 1 1477 12 is_stmt 0 view .LVU181
 581 001e 684B     		ldr	r3, .L97
 582 0020 1C68     		ldr	r4, [r3]
 583              	.LVL62:
1477:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object registered? */
 584              		.loc 1 1477 7 view .LVU182
 585 0022 0C60     		str	r4, [r1]
1478:ff.c          **** 
 586              		.loc 1 1478 2 is_stmt 1 view .LVU183
1478:ff.c          **** 
 587              		.loc 1 1478 5 is_stmt 0 view .LVU184
 588 0024 002C     		cmp	r4, #0
 589 0026 00F0C580 		beq	.L80
1480:ff.c          **** 
 590              		.loc 1 1480 14 is_stmt 1 view .LVU185
1482:ff.c          **** 		stat = disk_status(fs->drive);
 591              		.loc 1 1482 2 view .LVU186
1482:ff.c          **** 		stat = disk_status(fs->drive);
 592              		.loc 1 1482 5 is_stmt 0 view .LVU187
 593 002a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 594 002c 73B1     		cbz	r3, .L64
1483:ff.c          **** 		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed),
 595              		.loc 1 1483 3 is_stmt 1 view .LVU188
1483:ff.c          **** 		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed),
 596              		.loc 1 1483 10 is_stmt 0 view .LVU189
 597 002e 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 598              	.LVL63:
1483:ff.c          **** 		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed),
 599              		.loc 1 1483 10 view .LVU190
 600 0030 FFF7FEFF 		bl	disk_status
 601              	.LVL64:
1484:ff.c          **** #if !_FS_READONLY
 602              		.loc 1 1484 3 is_stmt 1 view .LVU191
1484:ff.c          **** #if !_FS_READONLY
 603              		.loc 1 1484 6 is_stmt 0 view .LVU192
 604 0034 C107     		lsls	r1, r0, #31
 605 0036 09D4     		bmi	.L64
1486:ff.c          **** 				return FR_WRITE_PROTECTED;
 606              		.loc 1 1486 4 is_stmt 1 view .LVU193
1486:ff.c          **** 				return FR_WRITE_PROTECTED;
 607              		.loc 1 1486 7 is_stmt 0 view .LVU194
 608 0038 1DB1     		cbz	r5, .L63
1486:ff.c          **** 				return FR_WRITE_PROTECTED;
 609              		.loc 1 1486 15 discriminator 1 view .LVU195
 610 003a 10F00405 		ands	r5, r0, #4
 611 003e 00D0     		beq	.L63
 612              	.L66:
1487:ff.c          **** #endif
 613              		.loc 1 1487 12 view .LVU196
 614 0040 0A25     		movs	r5, #10
 615              	.LVL65:
 616              	.L63:
1573:ff.c          **** 
 617              		.loc 1 1573 1 view .LVU197
 618 0042 2846     		mov	r0, r5
 619 0044 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 620              	.LVL66:
 621              	.L61:
1468:ff.c          **** #else
 622              		.loc 1 1468 3 is_stmt 1 view .LVU198
1468:ff.c          **** #else
 623              		.loc 1 1468 7 is_stmt 0 view .LVU199
 624 0046 5F4B     		ldr	r3, .L97+4
 625              	.LVL67:
1468:ff.c          **** #else
 626              		.loc 1 1468 7 view .LVU200
 627 0048 1E78     		ldrb	r6, [r3]	@ zero_extendqisi2
 628              	.LVL68:
1468:ff.c          **** #else
 629              		.loc 1 1468 7 view .LVU201
 630 004a E5E7     		b	.L62
 631              	.LVL69:
 632              	.L64:
1495:ff.c          **** 	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
 633              		.loc 1 1495 2 is_stmt 1 view .LVU202
1496:ff.c          **** 	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
 634              		.loc 1 1496 2 view .LVU203
1495:ff.c          **** 	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
 635              		.loc 1 1495 14 is_stmt 0 view .LVU204
 636 004c 0020     		movs	r0, #0
 637 004e 2080     		strh	r0, [r4]	@ movhi
1497:ff.c          **** 	if (stat & STA_NOINIT)				/* Check if the drive is ready */
 638              		.loc 1 1497 2 is_stmt 1 view .LVU205
1497:ff.c          **** 	if (stat & STA_NOINIT)				/* Check if the drive is ready */
 639              		.loc 1 1497 9 is_stmt 0 view .LVU206
 640 0050 FFF7FEFF 		bl	disk_initialize
 641              	.LVL70:
1498:ff.c          **** 		return FR_NOT_READY;
 642              		.loc 1 1498 2 is_stmt 1 view .LVU207
1498:ff.c          **** 		return FR_NOT_READY;
 643              		.loc 1 1498 5 is_stmt 0 view .LVU208
 644 0054 C207     		lsls	r2, r0, #31
 645 0056 00F1AF80 		bmi	.L81
1505:ff.c          **** 		return FR_WRITE_PROTECTED;
 646              		.loc 1 1505 2 is_stmt 1 view .LVU209
1505:ff.c          **** 		return FR_WRITE_PROTECTED;
 647              		.loc 1 1505 5 is_stmt 0 view .LVU210
 648 005a 0DB1     		cbz	r5, .L65
1505:ff.c          **** 		return FR_WRITE_PROTECTED;
 649              		.loc 1 1505 13 discriminator 1 view .LVU211
 650 005c 4307     		lsls	r3, r0, #29
 651 005e EFD4     		bmi	.L66
 652              	.L65:
1509:ff.c          **** 	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
 653              		.loc 1 1509 2 is_stmt 1 view .LVU212
 654              	.LVL71:
1509:ff.c          **** 	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
 655              		.loc 1 1509 8 is_stmt 0 view .LVU213
 656 0060 0021     		movs	r1, #0
 657 0062 2046     		mov	r0, r4
 658              	.LVL72:
1509:ff.c          **** 	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
 659              		.loc 1 1509 8 view .LVU214
 660 0064 FFF7FEFF 		bl	check_fs
 661              	.LVL73:
1510:ff.c          **** 		/* Check a partition listed in top of the partition table */
 662              		.loc 1 1510 5 view .LVU215
 663 0068 0128     		cmp	r0, #1
1509:ff.c          **** 	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
 664              		.loc 1 1509 8 view .LVU216
 665 006a 0546     		mov	r5, r0
 666              	.LVL74:
1510:ff.c          **** 		/* Check a partition listed in top of the partition table */
 667              		.loc 1 1510 2 is_stmt 1 view .LVU217
1510:ff.c          **** 		/* Check a partition listed in top of the partition table */
 668              		.loc 1 1510 5 is_stmt 0 view .LVU218
 669 006c 0BD1     		bne	.L67
1512:ff.c          **** 		if (tbl[4]) {									/* Is the partition existing? */
 670              		.loc 1 1512 3 is_stmt 1 view .LVU219
 671              	.LVL75:
1513:ff.c          **** 			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
 672              		.loc 1 1513 3 view .LVU220
1513:ff.c          **** 			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
 673              		.loc 1 1513 6 is_stmt 0 view .LVU221
 674 006e 94F8F631 		ldrb	r3, [r4, #502]	@ zero_extendqisi2
 675 0072 0BB9     		cbnz	r3, .L68
 676              	.LVL76:
 677              	.L69:
1520:ff.c          **** 
 678              		.loc 1 1520 10 view .LVU222
 679 0074 0D25     		movs	r5, #13
 680 0076 E4E7     		b	.L63
 681              	.LVL77:
 682              	.L68:
1514:ff.c          **** 			fmt = check_fs(fs, bsect);					/* Check the partition */
 683              		.loc 1 1514 4 is_stmt 1 view .LVU223
1514:ff.c          **** 			fmt = check_fs(fs, bsect);					/* Check the partition */
 684              		.loc 1 1514 10 is_stmt 0 view .LVU224
 685 0078 D4F8FA61 		ldr	r6, [r4, #506]	@ unaligned
 686              	.LVL78:
1515:ff.c          **** 		}
 687              		.loc 1 1515 4 is_stmt 1 view .LVU225
1515:ff.c          **** 		}
 688              		.loc 1 1515 10 is_stmt 0 view .LVU226
 689 007c 2046     		mov	r0, r4
 690              	.LVL79:
1515:ff.c          **** 		}
 691              		.loc 1 1515 10 view .LVU227
 692 007e 3146     		mov	r1, r6
 693 0080 FFF7FEFF 		bl	check_fs
 694              	.LVL80:
1515:ff.c          **** 		}
 695              		.loc 1 1515 10 view .LVU228
 696 0084 0546     		mov	r5, r0
 697              	.LVL81:
 698              	.L67:
1518:ff.c          **** 	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
 699              		.loc 1 1518 2 is_stmt 1 view .LVU229
1518:ff.c          **** 	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
 700              		.loc 1 1518 5 is_stmt 0 view .LVU230
 701 0086 032D     		cmp	r5, #3
 702 0088 00F09880 		beq	.L82
1519:ff.c          **** 		return FR_NO_FILESYSTEM;
 703              		.loc 1 1519 2 is_stmt 1 view .LVU231
1519:ff.c          **** 		return FR_NO_FILESYSTEM;
 704              		.loc 1 1519 5 is_stmt 0 view .LVU232
 705 008c 002D     		cmp	r5, #0
 706 008e F1D1     		bne	.L69
1519:ff.c          **** 		return FR_NO_FILESYSTEM;
 707              		.loc 1 1519 13 discriminator 1 view .LVU233
 708 0090 94F84020 		ldrb	r2, [r4, #64]	@ zero_extendqisi2
 709 0094 94F83F30 		ldrb	r3, [r4, #63]	@ zero_extendqisi2
 710 0098 43EA0223 		orr	r3, r3, r2, lsl #8
1519:ff.c          **** 		return FR_NO_FILESYSTEM;
 711              		.loc 1 1519 10 discriminator 1 view .LVU234
 712 009c B3F5007F 		cmp	r3, #512
 713 00a0 E8D1     		bne	.L69
1523:ff.c          **** 	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
 714              		.loc 1 1523 2 is_stmt 1 view .LVU235
1523:ff.c          **** 	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
 715              		.loc 1 1523 10 is_stmt 0 view .LVU236
 716 00a2 94F84B30 		ldrb	r3, [r4, #75]	@ zero_extendqisi2
 717 00a6 94F84A00 		ldrb	r0, [r4, #74]	@ zero_extendqisi2
 718              	.LVL82:
1524:ff.c          **** 	fs->sects_fat = fsize;
 719              		.loc 1 1524 2 is_stmt 1 view .LVU237
1528:ff.c          **** 	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 720              		.loc 1 1528 24 is_stmt 0 view .LVU238
 721 00aa 94F84220 		ldrb	r2, [r4, #66]	@ zero_extendqisi2
1524:ff.c          **** 	fs->sects_fat = fsize;
 722              		.loc 1 1524 5 view .LVU239
 723 00ae 50EA0320 		orrs	r0, r0, r3, lsl #8
 724              	.LVL83:
1524:ff.c          **** 	fs->sects_fat = fsize;
 725              		.loc 1 1524 14 is_stmt 1 view .LVU240
1524:ff.c          **** 	fs->sects_fat = fsize;
 726              		.loc 1 1524 20 is_stmt 0 view .LVU241
 727 00b2 08BF     		it	eq
 728 00b4 A06D     		ldreq	r0, [r4, #88]
 729              	.LVL84:
1525:ff.c          **** 	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 730              		.loc 1 1525 2 is_stmt 1 view .LVU242
1526:ff.c          **** 	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
 731              		.loc 1 1526 22 is_stmt 0 view .LVU243
 732 00b6 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
1525:ff.c          **** 	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 733              		.loc 1 1525 16 view .LVU244
 734 00ba E061     		str	r0, [r4, #28]
1526:ff.c          **** 	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
 735              		.loc 1 1526 2 is_stmt 1 view .LVU245
1526:ff.c          **** 	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
 736              		.loc 1 1526 13 is_stmt 0 view .LVU246
 737 00bc E370     		strb	r3, [r4, #3]
1527:ff.c          **** 	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
 738              		.loc 1 1527 2 is_stmt 1 view .LVU247
1527:ff.c          **** 	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
 739              		.loc 1 1527 8 is_stmt 0 view .LVU248
 740 00be 5843     		muls	r0, r3, r0
 741              	.LVL85:
1528:ff.c          **** 	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 742              		.loc 1 1528 2 is_stmt 1 view .LVU249
1528:ff.c          **** 	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 743              		.loc 1 1528 24 is_stmt 0 view .LVU250
 744 00c0 94F84330 		ldrb	r3, [r4, #67]	@ zero_extendqisi2
1530:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
 745              		.loc 1 1530 18 view .LVU251
 746 00c4 94F84610 		ldrb	r1, [r4, #70]	@ zero_extendqisi2
1528:ff.c          **** 	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 747              		.loc 1 1528 24 view .LVU252
 748 00c8 42EA0322 		orr	r2, r2, r3, lsl #8
1530:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
 749              		.loc 1 1530 18 view .LVU253
 750 00cc 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
1531:ff.c          **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 751              		.loc 1 1531 10 view .LVU254
 752 00d0 94F848E0 		ldrb	lr, [r4, #72]	@ zero_extendqisi2
1530:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
 753              		.loc 1 1530 18 view .LVU255
 754 00d4 43EA0123 		orr	r3, r3, r1, lsl #8
1531:ff.c          **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 755              		.loc 1 1531 10 view .LVU256
 756 00d8 94F84710 		ldrb	r1, [r4, #71]	@ zero_extendqisi2
1530:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
 757              		.loc 1 1530 16 view .LVU257
 758 00dc 2381     		strh	r3, [r4, #8]	@ movhi
1532:ff.c          **** 	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
 759              		.loc 1 1532 5 view .LVU258
 760 00de 51EA0E21 		orrs	r1, r1, lr, lsl #8
1532:ff.c          **** 	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
 761              		.loc 1 1532 20 view .LVU259
 762 00e2 08BF     		it	eq
 763 00e4 616D     		ldreq	r1, [r4, #84]
1534:ff.c          **** 		) / fs->csize + 2;
 764              		.loc 1 1534 61 view .LVU260
 765 00e6 4FEA131E 		lsr	lr, r3, #4
1534:ff.c          **** 		) / fs->csize + 2;
 766              		.loc 1 1534 45 view .LVU261
 767 00ea 02EB1313 		add	r3, r2, r3, lsr #4
1529:ff.c          **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
 768              		.loc 1 1529 21 view .LVU262
 769 00ee 94F84170 		ldrb	r7, [r4, #65]	@ zero_extendqisi2
1534:ff.c          **** 		) / fs->csize + 2;
 770              		.loc 1 1534 45 view .LVU263
 771 00f2 0344     		add	r3, r3, r0
 772 00f4 CB1A     		subs	r3, r1, r3
1535:ff.c          **** 
 773              		.loc 1 1535 5 view .LVU264
 774 00f6 B3FBF7F3 		udiv	r3, r3, r7
1528:ff.c          **** 	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 775              		.loc 1 1528 22 view .LVU265
 776 00fa 02EB060C 		add	ip, r2, r6
1538:ff.c          **** 	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 777              		.loc 1 1538 5 view .LVU266
 778 00fe 40F6F672 		movw	r2, #4086
1533:ff.c          **** 		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
 779              		.loc 1 1533 24 view .LVU267
 780 0102 0233     		adds	r3, r3, #2
1538:ff.c          **** 	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 781              		.loc 1 1538 5 view .LVU268
 782 0104 9342     		cmp	r3, r2
1528:ff.c          **** 	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 783              		.loc 1 1528 14 view .LVU269
 784 0106 C4F824C0 		str	ip, [r4, #36]
1529:ff.c          **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
 785              		.loc 1 1529 2 is_stmt 1 view .LVU270
1529:ff.c          **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
 786              		.loc 1 1529 12 is_stmt 0 view .LVU271
 787 010a A770     		strb	r7, [r4, #2]
1530:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
 788              		.loc 1 1530 2 is_stmt 1 view .LVU272
1531:ff.c          **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 789              		.loc 1 1531 2 view .LVU273
 790              	.LVL86:
1532:ff.c          **** 	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
 791              		.loc 1 1532 2 view .LVU274
1532:ff.c          **** 	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
 792              		.loc 1 1532 14 view .LVU275
1533:ff.c          **** 		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
 793              		.loc 1 1533 2 view .LVU276
1533:ff.c          **** 		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
 794              		.loc 1 1533 16 is_stmt 0 view .LVU277
 795 010c 2362     		str	r3, [r4, #32]
1537:ff.c          **** 	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
 796              		.loc 1 1537 2 is_stmt 1 view .LVU278
 797              	.LVL87:
1538:ff.c          **** 	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 798              		.loc 1 1538 2 view .LVU279
1538:ff.c          **** 	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 799              		.loc 1 1538 5 is_stmt 0 view .LVU280
 800 010e 49D9     		bls	.L83
1538:ff.c          **** 	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 801              		.loc 1 1538 22 is_stmt 1 view .LVU281
 802              	.LVL88:
1539:ff.c          **** 
 803              		.loc 1 1539 2 view .LVU282
1539:ff.c          **** 
 804              		.loc 1 1539 5 is_stmt 0 view .LVU283
 805 0110 4FF6F672 		movw	r2, #65526
 806 0114 9342     		cmp	r3, r2
 807 0116 49D9     		bls	.L84
 808              	.LVL89:
1542:ff.c          **** 	else
 809              		.loc 1 1542 3 is_stmt 1 view .LVU284
 810 0118 0327     		movs	r7, #3
1542:ff.c          **** 	else
 811              		.loc 1 1542 17 is_stmt 0 view .LVU285
 812 011a 236E     		ldr	r3, [r4, #96]
 813              	.LVL90:
 814              	.L75:
1542:ff.c          **** 	else
 815              		.loc 1 1542 17 view .LVU286
 816 011c A362     		str	r3, [r4, #40]
1545:ff.c          **** 
 817              		.loc 1 1545 2 is_stmt 1 view .LVU287
1545:ff.c          **** 
 818              		.loc 1 1545 37 is_stmt 0 view .LVU288
 819 011e 0CEB0E03 		add	r3, ip, lr
 820 0122 1844     		add	r0, r0, r3
 821              	.LVL91:
1549:ff.c          **** 	fs->wflag = 0;
 822              		.loc 1 1549 17 view .LVU289
 823 0124 4FF0FF33 		mov	r3, #-1
 824 0128 2361     		str	r3, [r4, #16]
1550:ff.c          **** 	/* Get fsinfo if needed */
 825              		.loc 1 1550 12 view .LVU290
 826 012a 0023     		movs	r3, #0
1552:ff.c          **** 	 	fs->fsi_flag = 0;
 827              		.loc 1 1552 5 view .LVU291
 828 012c 032F     		cmp	r7, #3
1545:ff.c          **** 
 829              		.loc 1 1545 15 view .LVU292
 830 012e E062     		str	r0, [r4, #44]
1549:ff.c          **** 	fs->wflag = 0;
 831              		.loc 1 1549 2 is_stmt 1 view .LVU293
1550:ff.c          **** 	/* Get fsinfo if needed */
 832              		.loc 1 1550 2 view .LVU294
1550:ff.c          **** 	/* Get fsinfo if needed */
 833              		.loc 1 1550 12 is_stmt 0 view .LVU295
 834 0130 2371     		strb	r3, [r4, #4]
1552:ff.c          **** 	 	fs->fsi_flag = 0;
 835              		.loc 1 1552 2 is_stmt 1 view .LVU296
1552:ff.c          **** 	 	fs->fsi_flag = 0;
 836              		.loc 1 1552 5 is_stmt 0 view .LVU297
 837 0132 2CD1     		bne	.L77
1553:ff.c          **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 838              		.loc 1 1553 4 is_stmt 1 view .LVU298
1554:ff.c          **** 		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 839              		.loc 1 1554 28 is_stmt 0 view .LVU299
 840 0134 94F86420 		ldrb	r2, [r4, #100]	@ zero_extendqisi2
1553:ff.c          **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 841              		.loc 1 1553 17 view .LVU300
 842 0138 A372     		strb	r3, [r4, #10]
1554:ff.c          **** 		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 843              		.loc 1 1554 3 is_stmt 1 view .LVU301
1554:ff.c          **** 		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 844              		.loc 1 1554 28 is_stmt 0 view .LVU302
 845 013a 94F86530 		ldrb	r3, [r4, #101]	@ zero_extendqisi2
1555:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 846              		.loc 1 1555 7 view .LVU303
 847 013e 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
1554:ff.c          **** 		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 848              		.loc 1 1554 28 view .LVU304
 849 0140 42EA0322 		orr	r2, r2, r3, lsl #8
1554:ff.c          **** 		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 850              		.loc 1 1554 26 view .LVU305
 851 0144 3244     		add	r2, r2, r6
1555:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 852              		.loc 1 1555 7 view .LVU306
 853 0146 0123     		movs	r3, #1
1554:ff.c          **** 		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 854              		.loc 1 1554 18 view .LVU307
 855 0148 6261     		str	r2, [r4, #20]
1555:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 856              		.loc 1 1555 3 is_stmt 1 view .LVU308
1555:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 857              		.loc 1 1555 7 is_stmt 0 view .LVU309
 858 014a 04F13401 		add	r1, r4, #52
 859              	.LVL92:
1555:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 860              		.loc 1 1555 7 view .LVU310
 861 014e FFF7FEFF 		bl	disk_read
 862              	.LVL93:
1555:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 863              		.loc 1 1555 6 view .LVU311
 864 0152 E0B9     		cbnz	r0, .L77
1556:ff.c          **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 865              		.loc 1 1556 4 discriminator 1 view .LVU312
 866 0154 94F83322 		ldrb	r2, [r4, #563]	@ zero_extendqisi2
 867 0158 94F83232 		ldrb	r3, [r4, #562]	@ zero_extendqisi2
 868 015c 43EA0223 		orr	r3, r3, r2, lsl #8
1555:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 869              		.loc 1 1555 66 discriminator 1 view .LVU313
 870 0160 4AF65522 		movw	r2, #43605
 871 0164 9342     		cmp	r3, r2
 872 0166 12D1     		bne	.L77
1556:ff.c          **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 873              		.loc 1 1556 39 view .LVU314
 874 0168 626B     		ldr	r2, [r4, #52]
 875 016a 174B     		ldr	r3, .L97+8
 876 016c 9A42     		cmp	r2, r3
 877 016e 0ED1     		bne	.L77
1557:ff.c          **** 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
 878              		.loc 1 1557 48 view .LVU315
 879 0170 03F1FF53 		add	r3, r3, #534773760
 880 0174 D4F81822 		ldr	r2, [r4, #536]
 881 0178 03F50053 		add	r3, r3, #8192
 882 017c 2033     		adds	r3, r3, #32
 883 017e 9A42     		cmp	r2, r3
1559:ff.c          **** 			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 884              		.loc 1 1559 4 is_stmt 1 view .LVU316
1559:ff.c          **** 			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 885              		.loc 1 1559 19 is_stmt 0 view .LVU317
 886 0180 01BF     		itttt	eq
 887 0182 D4F82032 		ldreq	r3, [r4, #544]
 888 0186 E360     		streq	r3, [r4, #12]
1560:ff.c          **** 		}
 889              		.loc 1 1560 4 is_stmt 1 view .LVU318
1560:ff.c          **** 		}
 890              		.loc 1 1560 19 is_stmt 0 view .LVU319
 891 0188 D4F81C32 		ldreq	r3, [r4, #540]
 892 018c 2361     		streq	r3, [r4, #16]
 893              	.L77:
1564:ff.c          **** 	fs->winsect = 0;		/* Invalidate sector cache */
 894              		.loc 1 1564 2 is_stmt 1 view .LVU320
1565:ff.c          **** #if _FS_RPATH
 895              		.loc 1 1565 14 is_stmt 0 view .LVU321
 896 018e 0023     		movs	r3, #0
1569:ff.c          **** 	res = FR_OK;
 897              		.loc 1 1569 11 view .LVU322
 898 0190 0E4A     		ldr	r2, .L97+12
1565:ff.c          **** #if _FS_RPATH
 899              		.loc 1 1565 14 view .LVU323
 900 0192 2363     		str	r3, [r4, #48]
1567:ff.c          **** #endif
 901              		.loc 1 1567 11 view .LVU324
 902 0194 A361     		str	r3, [r4, #24]
1569:ff.c          **** 	res = FR_OK;
 903              		.loc 1 1569 11 view .LVU325
 904 0196 1388     		ldrh	r3, [r2]
1564:ff.c          **** 	fs->winsect = 0;		/* Invalidate sector cache */
 905              		.loc 1 1564 14 view .LVU326
 906 0198 2770     		strb	r7, [r4]
1565:ff.c          **** #if _FS_RPATH
 907              		.loc 1 1565 2 is_stmt 1 view .LVU327
1567:ff.c          **** #endif
 908              		.loc 1 1567 2 view .LVU328
1569:ff.c          **** 	res = FR_OK;
 909              		.loc 1 1569 2 view .LVU329
1569:ff.c          **** 	res = FR_OK;
 910              		.loc 1 1569 11 is_stmt 0 view .LVU330
 911 019a 0133     		adds	r3, r3, #1
 912 019c 9BB2     		uxth	r3, r3
1569:ff.c          **** 	res = FR_OK;
 913              		.loc 1 1569 9 view .LVU331
 914 019e 1380     		strh	r3, [r2]	@ movhi
 915 01a0 E380     		strh	r3, [r4, #6]	@ movhi
1570:ff.c          **** 
 916              		.loc 1 1570 2 is_stmt 1 view .LVU332
 917              	.LVL94:
1572:ff.c          **** }
 918              		.loc 1 1572 2 view .LVU333
1572:ff.c          **** }
 919              		.loc 1 1572 9 is_stmt 0 view .LVU334
 920 01a2 4EE7     		b	.L63
 921              	.LVL95:
 922              	.L83:
1537:ff.c          **** 	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
 923              		.loc 1 1537 6 view .LVU335
 924 01a4 0127     		movs	r7, #1
 925              	.LVL96:
 926              	.L74:
1541:ff.c          **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 927              		.loc 1 1541 2 is_stmt 1 view .LVU336
1544:ff.c          **** 	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
 928              		.loc 1 1544 3 view .LVU337
1544:ff.c          **** 	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
 929              		.loc 1 1544 29 is_stmt 0 view .LVU338
 930 01a6 0CEB0003 		add	r3, ip, r0
 931              	.LVL97:
1544:ff.c          **** 	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
 932              		.loc 1 1544 29 view .LVU339
 933 01aa B7E7     		b	.L75
 934              	.LVL98:
 935              	.L84:
1538:ff.c          **** 	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 936              		.loc 1 1538 26 view .LVU340
 937 01ac 0227     		movs	r7, #2
 938 01ae FAE7     		b	.L74
 939              	.LVL99:
 940              	.L79:
1476:ff.c          **** 	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
 941              		.loc 1 1476 10 view .LVU341
 942 01b0 0B25     		movs	r5, #11
 943 01b2 46E7     		b	.L63
 944              	.LVL100:
 945              	.L80:
1478:ff.c          **** 
 946              		.loc 1 1478 18 view .LVU342
 947 01b4 0C25     		movs	r5, #12
 948 01b6 44E7     		b	.L63
 949              	.LVL101:
 950              	.L81:
1499:ff.c          **** #if _MAX_SS != 512						/* Get disk sector size if needed */
 951              		.loc 1 1499 10 view .LVU343
 952 01b8 0325     		movs	r5, #3
 953 01ba 42E7     		b	.L63
 954              	.LVL102:
 955              	.L82:
1518:ff.c          **** 	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
 956              		.loc 1 1518 23 view .LVU344
 957 01bc 0125     		movs	r5, #1
 958              	.LVL103:
1518:ff.c          **** 	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
 959              		.loc 1 1518 23 view .LVU345
 960 01be 40E7     		b	.L63
 961              	.L98:
 962              		.align	2
 963              	.L97:
 964 01c0 00000000 		.word	.LANCHOR2
 965 01c4 00000000 		.word	.LANCHOR1
 966 01c8 52526141 		.word	1096897106
 967 01cc 00000000 		.word	.LANCHOR3
 968              		.cfi_endproc
 969              	.LFE50:
 971              		.section	.text.move_window,"ax",%progbits
 972              		.align	1
 973              		.syntax unified
 974              		.thumb
 975              		.thumb_func
 976              		.fpu softvfp
 978              	move_window:
 979              	.LVL104:
 980              	.LFB33:
 233:ff.c          **** 	DWORD wsect;
 981              		.loc 1 233 1 is_stmt 1 view -0
 982              		.cfi_startproc
 983              		@ args = 0, pretend = 0, frame = 0
 984              		@ frame_needed = 0, uses_anonymous_args = 0
 234:ff.c          **** 
 985              		.loc 1 234 2 view .LVU347
 237:ff.c          **** 	if (wsect != sector) {	/* Changed current window */
 986              		.loc 1 237 2 view .LVU348
 233:ff.c          **** 	DWORD wsect;
 987              		.loc 1 233 1 is_stmt 0 view .LVU349
 988 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 989              		.cfi_def_cfa_offset 24
 990              		.cfi_offset 4, -24
 991              		.cfi_offset 5, -20
 992              		.cfi_offset 6, -16
 993              		.cfi_offset 7, -12
 994              		.cfi_offset 8, -8
 995              		.cfi_offset 14, -4
 237:ff.c          **** 	if (wsect != sector) {	/* Changed current window */
 996              		.loc 1 237 8 view .LVU350
 997 0004 066B     		ldr	r6, [r0, #48]
 998              	.LVL105:
 238:ff.c          **** #if !_FS_READONLY
 999              		.loc 1 238 2 is_stmt 1 view .LVU351
 233:ff.c          **** 	DWORD wsect;
 1000              		.loc 1 233 1 is_stmt 0 view .LVU352
 1001 0006 0446     		mov	r4, r0
 238:ff.c          **** #if !_FS_READONLY
 1002              		.loc 1 238 5 view .LVU353
 1003 0008 8E42     		cmp	r6, r1
 233:ff.c          **** 	DWORD wsect;
 1004              		.loc 1 233 1 view .LVU354
 1005 000a 0D46     		mov	r5, r1
 238:ff.c          **** #if !_FS_READONLY
 1006              		.loc 1 238 5 view .LVU355
 1007 000c 02D1     		bne	.L100
 1008              	.LVL106:
 1009              	.L104:
 260:ff.c          **** }
 1010              		.loc 1 260 9 view .LVU356
 1011 000e 0020     		movs	r0, #0
 1012              	.L101:
 261:ff.c          **** 
 1013              		.loc 1 261 1 view .LVU357
 1014 0010 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1015              	.LVL107:
 1016              	.L100:
 240:ff.c          **** 			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
 1017              		.loc 1 240 3 is_stmt 1 view .LVU358
 240:ff.c          **** 			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
 1018              		.loc 1 240 6 is_stmt 0 view .LVU359
 1019 0014 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 1020 0016 5BB9     		cbnz	r3, .L102
 1021              	.LVL108:
 1022              	.L106:
 1023              	.LBB17:
 1024              	.LBI17:
 229:ff.c          **** 	FATFS *fs,		/* File system object */
 1025              		.loc 1 229 9 is_stmt 1 view .LVU360
 1026              	.LBB18:
 253:ff.c          **** 			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
 1027              		.loc 1 253 3 view .LVU361
 253:ff.c          **** 			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
 1028              		.loc 1 253 6 is_stmt 0 view .LVU362
 1029 0018 002D     		cmp	r5, #0
 1030 001a F8D0     		beq	.L104
 254:ff.c          **** 				return FR_DISK_ERR;
 1031              		.loc 1 254 4 is_stmt 1 view .LVU363
 254:ff.c          **** 				return FR_DISK_ERR;
 1032              		.loc 1 254 8 is_stmt 0 view .LVU364
 1033 001c 0123     		movs	r3, #1
 1034 001e 2A46     		mov	r2, r5
 1035 0020 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 1036 0022 04F13401 		add	r1, r4, #52
 1037 0026 FFF7FEFF 		bl	disk_read
 1038              	.LVL109:
 254:ff.c          **** 				return FR_DISK_ERR;
 1039              		.loc 1 254 7 view .LVU365
 1040 002a 50B9     		cbnz	r0, .L109
 256:ff.c          **** 		}
 1041              		.loc 1 256 4 is_stmt 1 view .LVU366
 256:ff.c          **** 		}
 1042              		.loc 1 256 16 is_stmt 0 view .LVU367
 1043 002c 2563     		str	r5, [r4, #48]
 1044 002e EFE7     		b	.L101
 1045              	.LVL110:
 1046              	.L102:
 256:ff.c          **** 		}
 1047              		.loc 1 256 16 view .LVU368
 1048              	.LBE18:
 1049              	.LBE17:
 241:ff.c          **** 				return FR_DISK_ERR;
 1050              		.loc 1 241 4 is_stmt 1 view .LVU369
 241:ff.c          **** 				return FR_DISK_ERR;
 1051              		.loc 1 241 32 is_stmt 0 view .LVU370
 1052 0030 00F13408 		add	r8, r0, #52
 241:ff.c          **** 				return FR_DISK_ERR;
 1053              		.loc 1 241 8 view .LVU371
 1054 0034 0123     		movs	r3, #1
 1055 0036 3246     		mov	r2, r6
 1056 0038 4146     		mov	r1, r8
 1057              	.LVL111:
 241:ff.c          **** 				return FR_DISK_ERR;
 1058              		.loc 1 241 8 view .LVU372
 1059 003a 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 1060              	.LVL112:
 241:ff.c          **** 				return FR_DISK_ERR;
 1061              		.loc 1 241 8 view .LVU373
 1062 003c FFF7FEFF 		bl	disk_write
 1063              	.LVL113:
 241:ff.c          **** 				return FR_DISK_ERR;
 1064              		.loc 1 241 7 view .LVU374
 1065 0040 08B1     		cbz	r0, .L105
 1066              	.L109:
 242:ff.c          **** 			fs->wflag = 0;
 1067              		.loc 1 242 12 view .LVU375
 1068 0042 0120     		movs	r0, #1
 1069 0044 E4E7     		b	.L101
 1070              	.L105:
 243:ff.c          **** 			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
 1071              		.loc 1 243 4 is_stmt 1 view .LVU376
 244:ff.c          **** 				BYTE nf;
 1072              		.loc 1 244 29 is_stmt 0 view .LVU377
 1073 0046 636A     		ldr	r3, [r4, #36]
 1074 0048 E269     		ldr	r2, [r4, #28]
 243:ff.c          **** 			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
 1075              		.loc 1 243 14 view .LVU378
 1076 004a 2071     		strb	r0, [r4, #4]
 244:ff.c          **** 				BYTE nf;
 1077              		.loc 1 244 4 is_stmt 1 view .LVU379
 244:ff.c          **** 				BYTE nf;
 1078              		.loc 1 244 29 is_stmt 0 view .LVU380
 1079 004c 1344     		add	r3, r3, r2
 244:ff.c          **** 				BYTE nf;
 1080              		.loc 1 244 7 view .LVU381
 1081 004e B342     		cmp	r3, r6
 1082 0050 E2D9     		bls	.L106
 1083              	.LBB19:
 245:ff.c          **** 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
 1084              		.loc 1 245 5 is_stmt 1 view .LVU382
 246:ff.c          **** 					wsect += fs->sects_fat;
 1085              		.loc 1 246 5 view .LVU383
 246:ff.c          **** 					wsect += fs->sects_fat;
 1086              		.loc 1 246 13 is_stmt 0 view .LVU384
 1087 0052 E778     		ldrb	r7, [r4, #3]	@ zero_extendqisi2
 1088              	.LVL114:
 1089              	.L107:
 246:ff.c          **** 					wsect += fs->sects_fat;
 1090              		.loc 1 246 27 is_stmt 1 discriminator 1 view .LVU385
 246:ff.c          **** 					wsect += fs->sects_fat;
 1091              		.loc 1 246 5 is_stmt 0 discriminator 1 view .LVU386
 1092 0054 012F     		cmp	r7, #1
 1093 0056 DFD9     		bls	.L106
 247:ff.c          **** 					disk_write(fs->drive, fs->win, wsect, 1);
 1094              		.loc 1 247 6 is_stmt 1 discriminator 3 view .LVU387
 247:ff.c          **** 					disk_write(fs->drive, fs->win, wsect, 1);
 1095              		.loc 1 247 12 is_stmt 0 discriminator 3 view .LVU388
 1096 0058 E369     		ldr	r3, [r4, #28]
 248:ff.c          **** 				}
 1097              		.loc 1 248 6 discriminator 3 view .LVU389
 1098 005a 4146     		mov	r1, r8
 247:ff.c          **** 					disk_write(fs->drive, fs->win, wsect, 1);
 1099              		.loc 1 247 12 discriminator 3 view .LVU390
 1100 005c 1E44     		add	r6, r6, r3
 1101              	.LVL115:
 248:ff.c          **** 				}
 1102              		.loc 1 248 6 is_stmt 1 discriminator 3 view .LVU391
 1103 005e 3246     		mov	r2, r6
 1104 0060 0123     		movs	r3, #1
 1105 0062 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 246:ff.c          **** 					wsect += fs->sects_fat;
 1106              		.loc 1 246 37 is_stmt 0 discriminator 3 view .LVU392
 1107 0064 013F     		subs	r7, r7, #1
 1108              	.LVL116:
 248:ff.c          **** 				}
 1109              		.loc 1 248 6 discriminator 3 view .LVU393
 1110 0066 FFF7FEFF 		bl	disk_write
 1111              	.LVL117:
 246:ff.c          **** 					wsect += fs->sects_fat;
 1112              		.loc 1 246 35 is_stmt 1 discriminator 3 view .LVU394
 246:ff.c          **** 					wsect += fs->sects_fat;
 1113              		.loc 1 246 37 is_stmt 0 discriminator 3 view .LVU395
 1114 006a FFB2     		uxtb	r7, r7
 1115              	.LVL118:
 246:ff.c          **** 					wsect += fs->sects_fat;
 1116              		.loc 1 246 37 discriminator 3 view .LVU396
 1117 006c F2E7     		b	.L107
 1118              	.LBE19:
 1119              		.cfi_endproc
 1120              	.LFE33:
 1122              		.section	.text.get_fat,"ax",%progbits
 1123              		.align	1
 1124              		.syntax unified
 1125              		.thumb
 1126              		.thumb_func
 1127              		.fpu softvfp
 1129              	get_fat:
 1130              	.LVL119:
 1131              	.LFB35:
 313:ff.c          **** 	UINT wc, bc;
 1132              		.loc 1 313 1 is_stmt 1 view -0
 1133              		.cfi_startproc
 1134              		@ args = 0, pretend = 0, frame = 0
 1135              		@ frame_needed = 0, uses_anonymous_args = 0
 314:ff.c          **** 	DWORD fsect;
 1136              		.loc 1 314 2 view .LVU398
 315:ff.c          **** 
 1137              		.loc 1 315 2 view .LVU399
 318:ff.c          **** 		return 1;
 1138              		.loc 1 318 2 view .LVU400
 318:ff.c          **** 		return 1;
 1139              		.loc 1 318 5 is_stmt 0 view .LVU401
 1140 0000 0129     		cmp	r1, #1
 313:ff.c          **** 	UINT wc, bc;
 1141              		.loc 1 313 1 view .LVU402
 1142 0002 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1143              		.cfi_def_cfa_offset 24
 1144              		.cfi_offset 4, -24
 1145              		.cfi_offset 5, -20
 1146              		.cfi_offset 6, -16
 1147              		.cfi_offset 7, -12
 1148              		.cfi_offset 8, -8
 1149              		.cfi_offset 14, -4
 313:ff.c          **** 	UINT wc, bc;
 1150              		.loc 1 313 1 view .LVU403
 1151 0006 0646     		mov	r6, r0
 1152 0008 0D46     		mov	r5, r1
 318:ff.c          **** 		return 1;
 1153              		.loc 1 318 5 view .LVU404
 1154 000a 5CD9     		bls	.L118
 318:ff.c          **** 		return 1;
 1155              		.loc 1 318 15 discriminator 1 view .LVU405
 1156 000c 036A     		ldr	r3, [r0, #32]
 1157 000e 8B42     		cmp	r3, r1
 1158 0010 59D9     		bls	.L118
 1159              	.LVL120:
 1160              	.LBB22:
 1161              	.LBI22:
 309:ff.c          **** 	FATFS *fs,	/* File system object */
 1162              		.loc 1 309 7 is_stmt 1 view .LVU406
 1163              	.LBB23:
 321:ff.c          **** 	switch (fs->fs_type) {
 1164              		.loc 1 321 2 view .LVU407
 322:ff.c          **** 	case FS_FAT12 :
 1165              		.loc 1 322 12 is_stmt 0 view .LVU408
 1166 0012 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 321:ff.c          **** 	switch (fs->fs_type) {
 1167              		.loc 1 321 8 view .LVU409
 1168 0014 D0F82480 		ldr	r8, [r0, #36]
 1169              	.LVL121:
 322:ff.c          **** 	case FS_FAT12 :
 1170              		.loc 1 322 2 is_stmt 1 view .LVU410
 1171 0018 022B     		cmp	r3, #2
 1172 001a 28D0     		beq	.L112
 1173 001c 032B     		cmp	r3, #3
 1174 001e 37D0     		beq	.L113
 1175 0020 012B     		cmp	r3, #1
 1176 0022 06D1     		bne	.L119
 324:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1177              		.loc 1 324 3 view .LVU411
 1178              	.LVL122:
 324:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1179              		.loc 1 324 14 view .LVU412
 324:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1180              		.loc 1 324 17 is_stmt 0 view .LVU413
 1181 0024 01EB5107 		add	r7, r1, r1, lsr #1
 1182              	.LVL123:
 325:ff.c          **** 		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 1183              		.loc 1 325 3 is_stmt 1 view .LVU414
 325:ff.c          **** 		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 1184              		.loc 1 325 7 is_stmt 0 view .LVU415
 1185 0028 08EB5721 		add	r1, r8, r7, lsr #9
 1186              	.LVL124:
 325:ff.c          **** 		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 1187              		.loc 1 325 7 view .LVU416
 1188 002c FFF7FEFF 		bl	move_window
 1189              	.LVL125:
 325:ff.c          **** 		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 1190              		.loc 1 325 6 view .LVU417
 1191 0030 10B1     		cbz	r0, .L114
 1192              	.LVL126:
 1193              	.L119:
 322:ff.c          **** 	case FS_FAT12 :
 1194              		.loc 1 322 2 view .LVU418
 1195 0032 4FF0FF30 		mov	r0, #-1
 1196              	.LVL127:
 322:ff.c          **** 	case FS_FAT12 :
 1197              		.loc 1 322 2 view .LVU419
 1198 0036 18E0     		b	.L110
 1199              	.LVL128:
 1200              	.L114:
 326:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1201              		.loc 1 326 3 is_stmt 1 view .LVU420
 326:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1202              		.loc 1 326 19 is_stmt 0 view .LVU421
 1203 0038 C7F30803 		ubfx	r3, r7, #0, #9
 326:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1204              		.loc 1 326 38 view .LVU422
 1205 003c 0137     		adds	r7, r7, #1
 1206              	.LVL129:
 326:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1207              		.loc 1 326 15 view .LVU423
 1208 003e 3344     		add	r3, r3, r6
 327:ff.c          **** 		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 1209              		.loc 1 327 7 view .LVU424
 1210 0040 3046     		mov	r0, r6
 1211 0042 08EB5721 		add	r1, r8, r7, lsr #9
 326:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1212              		.loc 1 326 15 view .LVU425
 1213 0046 93F83440 		ldrb	r4, [r3, #52]	@ zero_extendqisi2
 1214              	.LVL130:
 326:ff.c          **** 		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 1215              		.loc 1 326 36 is_stmt 1 view .LVU426
 327:ff.c          **** 		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 1216              		.loc 1 327 3 view .LVU427
 327:ff.c          **** 		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 1217              		.loc 1 327 7 is_stmt 0 view .LVU428
 1218 004a FFF7FEFF 		bl	move_window
 1219              	.LVL131:
 327:ff.c          **** 		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 1220              		.loc 1 327 6 view .LVU429
 1221 004e 0028     		cmp	r0, #0
 1222 0050 EFD1     		bne	.L119
 328:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 1223              		.loc 1 328 3 is_stmt 1 view .LVU430
 328:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 1224              		.loc 1 328 26 is_stmt 0 view .LVU431
 1225 0052 C7F30807 		ubfx	r7, r7, #0, #9
 1226              	.LVL132:
 328:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 1227              		.loc 1 328 22 view .LVU432
 1228 0056 3E44     		add	r6, r6, r7
 1229              	.LVL133:
 328:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 1230              		.loc 1 328 9 view .LVU433
 1231 0058 96F83400 		ldrb	r0, [r6, #52]	@ zero_extendqisi2
 329:ff.c          **** 
 1232              		.loc 1 329 33 view .LVU434
 1233 005c EB07     		lsls	r3, r5, #31
 328:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 1234              		.loc 1 328 6 view .LVU435
 1235 005e 44EA0020 		orr	r0, r4, r0, lsl #8
 1236              	.LVL134:
 329:ff.c          **** 
 1237              		.loc 1 329 3 is_stmt 1 view .LVU436
 329:ff.c          **** 
 1238              		.loc 1 329 33 is_stmt 0 view .LVU437
 1239 0062 4CBF     		ite	mi
 1240 0064 0009     		lsrmi	r0, r0, #4
 1241              	.LVL135:
 329:ff.c          **** 
 1242              		.loc 1 329 33 view .LVU438
 1243 0066 C0F30B00 		ubfxpl	r0, r0, #0, #12
 1244              	.LVL136:
 1245              	.L110:
 329:ff.c          **** 
 1246              		.loc 1 329 33 view .LVU439
 1247              	.LBE23:
 1248              	.LBE22:
 341:ff.c          **** 
 1249              		.loc 1 341 1 view .LVU440
 1250 006a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1251              	.LVL137:
 1252              	.L112:
 1253              	.LBB25:
 1254              	.LBB24:
 332:ff.c          **** 		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 1255              		.loc 1 332 3 is_stmt 1 view .LVU441
 332:ff.c          **** 		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 1256              		.loc 1 332 7 is_stmt 0 view .LVU442
 1257 006e 08EB1121 		add	r1, r8, r1, lsr #8
 1258              	.LVL138:
 332:ff.c          **** 		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 1259              		.loc 1 332 7 view .LVU443
 1260 0072 FFF7FEFF 		bl	move_window
 1261              	.LVL139:
 332:ff.c          **** 		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 1262              		.loc 1 332 6 view .LVU444
 1263 0076 0028     		cmp	r0, #0
 1264 0078 DBD1     		bne	.L119
 333:ff.c          **** 
 1265              		.loc 1 333 3 is_stmt 1 view .LVU445
 333:ff.c          **** 
 1266              		.loc 1 333 10 is_stmt 0 view .LVU446
 1267 007a 6D00     		lsls	r5, r5, #1
 1268              	.LVL140:
 333:ff.c          **** 
 1269              		.loc 1 333 10 view .LVU447
 1270 007c 05F4FF75 		and	r5, r5, #510
 1271 0080 2E44     		add	r6, r6, r5
 1272              	.LVL141:
 333:ff.c          **** 
 1273              		.loc 1 333 10 view .LVU448
 1274 0082 96F83530 		ldrb	r3, [r6, #53]	@ zero_extendqisi2
 1275 0086 96F83400 		ldrb	r0, [r6, #52]	@ zero_extendqisi2
 1276 008a 40EA0320 		orr	r0, r0, r3, lsl #8
 1277 008e ECE7     		b	.L110
 1278              	.LVL142:
 1279              	.L113:
 336:ff.c          **** 		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 1280              		.loc 1 336 3 is_stmt 1 view .LVU449
 336:ff.c          **** 		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 1281              		.loc 1 336 7 is_stmt 0 view .LVU450
 1282 0090 08EBD111 		add	r1, r8, r1, lsr #7
 1283              	.LVL143:
 336:ff.c          **** 		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 1284              		.loc 1 336 7 view .LVU451
 1285 0094 FFF7FEFF 		bl	move_window
 1286              	.LVL144:
 336:ff.c          **** 		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 1287              		.loc 1 336 6 view .LVU452
 1288 0098 0028     		cmp	r0, #0
 1289 009a CAD1     		bne	.L119
 337:ff.c          **** 	}
 1290              		.loc 1 337 3 is_stmt 1 view .LVU453
 337:ff.c          **** 	}
 1291              		.loc 1 337 10 is_stmt 0 view .LVU454
 1292 009c AD00     		lsls	r5, r5, #2
 1293              	.LVL145:
 337:ff.c          **** 	}
 1294              		.loc 1 337 10 view .LVU455
 1295 009e 05F4FE75 		and	r5, r5, #508
 1296 00a2 05F13403 		add	r3, r5, #52
 1297 00a6 3344     		add	r3, r3, r6
 1298 00a8 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 1299 00aa DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1300 00ac 0004     		lsls	r0, r0, #16
 1301 00ae 3544     		add	r5, r5, r6
 1302 00b0 40EA0260 		orr	r0, r0, r2, lsl #24
 1303 00b4 95F83420 		ldrb	r2, [r5, #52]	@ zero_extendqisi2
 1304 00b8 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1305 00ba 1043     		orrs	r0, r0, r2
 1306 00bc 40EA0320 		orr	r0, r0, r3, lsl #8
 337:ff.c          **** 	}
 1307              		.loc 1 337 62 view .LVU456
 1308 00c0 20F07040 		bic	r0, r0, #-268435456
 1309 00c4 D1E7     		b	.L110
 1310              	.LVL146:
 1311              	.L118:
 337:ff.c          **** 	}
 1312              		.loc 1 337 62 view .LVU457
 1313              	.LBE24:
 1314              	.LBE25:
 319:ff.c          **** 
 1315              		.loc 1 319 10 view .LVU458
 1316 00c6 0120     		movs	r0, #1
 1317              	.LVL147:
 319:ff.c          **** 
 1318              		.loc 1 319 10 view .LVU459
 1319 00c8 CFE7     		b	.L110
 1320              		.cfi_endproc
 1321              	.LFE35:
 1323              		.section	.text.dir_seek,"ax",%progbits
 1324              		.align	1
 1325              		.syntax unified
 1326              		.thumb
 1327              		.thumb_func
 1328              		.fpu softvfp
 1330              	dir_seek:
 1331              	.LVL148:
 1332              	.LFB40:
 535:ff.c          **** 	DWORD clst;
 1333              		.loc 1 535 1 is_stmt 1 view -0
 1334              		.cfi_startproc
 1335              		@ args = 0, pretend = 0, frame = 0
 1336              		@ frame_needed = 0, uses_anonymous_args = 0
 536:ff.c          **** 	WORD ic;
 1337              		.loc 1 536 2 view .LVU461
 537:ff.c          **** 
 1338              		.loc 1 537 2 view .LVU462
 540:ff.c          **** 	clst = dj->sclust;
 1339              		.loc 1 540 2 view .LVU463
 535:ff.c          **** 	DWORD clst;
 1340              		.loc 1 535 1 is_stmt 0 view .LVU464
 1341 0000 70B5     		push	{r4, r5, r6, lr}
 1342              		.cfi_def_cfa_offset 16
 1343              		.cfi_offset 4, -16
 1344              		.cfi_offset 5, -12
 1345              		.cfi_offset 6, -8
 1346              		.cfi_offset 14, -4
 535:ff.c          **** 	DWORD clst;
 1347              		.loc 1 535 1 view .LVU465
 1348 0002 0C46     		mov	r4, r1
 540:ff.c          **** 	clst = dj->sclust;
 1349              		.loc 1 540 12 view .LVU466
 1350 0004 C180     		strh	r1, [r0, #6]	@ movhi
 541:ff.c          **** 	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
 1351              		.loc 1 541 2 is_stmt 1 view .LVU467
 541:ff.c          **** 	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
 1352              		.loc 1 541 7 is_stmt 0 view .LVU468
 1353 0006 8168     		ldr	r1, [r0, #8]
 1354              	.LVL149:
 542:ff.c          **** 		return FR_INT_ERR;
 1355              		.loc 1 542 2 is_stmt 1 view .LVU469
 535:ff.c          **** 	DWORD clst;
 1356              		.loc 1 535 1 is_stmt 0 view .LVU470
 1357 0008 0546     		mov	r5, r0
 542:ff.c          **** 		return FR_INT_ERR;
 1358              		.loc 1 542 5 view .LVU471
 1359 000a 0129     		cmp	r1, #1
 1360 000c 01D1     		bne	.L121
 1361              	.LVL150:
 1362              	.L123:
 543:ff.c          **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 1363              		.loc 1 543 10 view .LVU472
 1364 000e 0220     		movs	r0, #2
 1365              	.L122:
 569:ff.c          **** 
 1366              		.loc 1 569 1 view .LVU473
 1367 0010 70BD     		pop	{r4, r5, r6, pc}
 1368              	.LVL151:
 1369              	.L121:
 542:ff.c          **** 		return FR_INT_ERR;
 1370              		.loc 1 542 29 discriminator 1 view .LVU474
 1371 0012 0368     		ldr	r3, [r0]
 542:ff.c          **** 		return FR_INT_ERR;
 1372              		.loc 1 542 16 discriminator 1 view .LVU475
 1373 0014 1A6A     		ldr	r2, [r3, #32]
 1374 0016 8A42     		cmp	r2, r1
 1375 0018 F9D9     		bls	.L123
 544:ff.c          **** 		clst = dj->fs->dirbase;
 1376              		.loc 1 544 2 is_stmt 1 view .LVU476
 544:ff.c          **** 		clst = dj->fs->dirbase;
 1377              		.loc 1 544 5 is_stmt 0 view .LVU477
 1378 001a B1B9     		cbnz	r1, .L124
 544:ff.c          **** 		clst = dj->fs->dirbase;
 1379              		.loc 1 544 12 discriminator 1 view .LVU478
 1380 001c 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1381 001e 032A     		cmp	r2, #3
 1382 0020 01D1     		bne	.L125
 545:ff.c          **** 
 1383              		.loc 1 545 3 is_stmt 1 view .LVU479
 545:ff.c          **** 
 1384              		.loc 1 545 8 is_stmt 0 view .LVU480
 1385 0022 996A     		ldr	r1, [r3, #40]
 1386              	.LVL152:
 547:ff.c          **** 		dj->clust = clst;
 1387              		.loc 1 547 2 is_stmt 1 view .LVU481
 547:ff.c          **** 		dj->clust = clst;
 1388              		.loc 1 547 5 is_stmt 0 view .LVU482
 1389 0024 89B9     		cbnz	r1, .L124
 1390              	.L125:
 1391              	.LVL153:
 548:ff.c          **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 1392              		.loc 1 548 3 is_stmt 1 view .LVU483
 548:ff.c          **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 1393              		.loc 1 548 13 is_stmt 0 view .LVU484
 1394 0026 0022     		movs	r2, #0
 1395 0028 EA60     		str	r2, [r5, #12]
 549:ff.c          **** 			return FR_INT_ERR;
 1396              		.loc 1 549 3 is_stmt 1 view .LVU485
 549:ff.c          **** 			return FR_INT_ERR;
 1397              		.loc 1 549 6 is_stmt 0 view .LVU486
 1398 002a 1A89     		ldrh	r2, [r3, #8]
 1399 002c A242     		cmp	r2, r4
 1400 002e EED9     		bls	.L123
 551:ff.c          **** 	}
 1401              		.loc 1 551 3 is_stmt 1 view .LVU487
 551:ff.c          **** 	}
 1402              		.loc 1 551 30 is_stmt 0 view .LVU488
 1403 0030 9B6A     		ldr	r3, [r3, #40]
 1404 0032 03EB1413 		add	r3, r3, r4, lsr #4
 551:ff.c          **** 	}
 1405              		.loc 1 551 12 view .LVU489
 1406 0036 2B61     		str	r3, [r5, #16]
 1407              	.LVL154:
 1408              	.L126:
 566:ff.c          **** 
 1409              		.loc 1 566 2 is_stmt 1 view .LVU490
 566:ff.c          **** 
 1410              		.loc 1 566 12 is_stmt 0 view .LVU491
 1411 0038 2B68     		ldr	r3, [r5]
 566:ff.c          **** 
 1412              		.loc 1 566 31 view .LVU492
 1413 003a 04F00F04 		and	r4, r4, #15
 1414              	.LVL155:
 566:ff.c          **** 
 1415              		.loc 1 566 12 view .LVU493
 1416 003e 3433     		adds	r3, r3, #52
 566:ff.c          **** 
 1417              		.loc 1 566 24 view .LVU494
 1418 0040 03EB4414 		add	r4, r3, r4, lsl #5
 568:ff.c          **** }
 1419              		.loc 1 568 9 view .LVU495
 1420 0044 0020     		movs	r0, #0
 566:ff.c          **** 
 1421              		.loc 1 566 10 view .LVU496
 1422 0046 6C61     		str	r4, [r5, #20]
 568:ff.c          **** }
 1423              		.loc 1 568 2 is_stmt 1 view .LVU497
 568:ff.c          **** }
 1424              		.loc 1 568 9 is_stmt 0 view .LVU498
 1425 0048 E2E7     		b	.L122
 1426              	.LVL156:
 1427              	.L124:
 554:ff.c          **** 		while (idx >= ic) {	/* Follow cluster chain */
 1428              		.loc 1 554 3 is_stmt 1 view .LVU499
 554:ff.c          **** 		while (idx >= ic) {	/* Follow cluster chain */
 1429              		.loc 1 554 32 is_stmt 0 view .LVU500
 1430 004a 9E78     		ldrb	r6, [r3, #2]	@ zero_extendqisi2
 554:ff.c          **** 		while (idx >= ic) {	/* Follow cluster chain */
 1431              		.loc 1 554 6 view .LVU501
 1432 004c 3601     		lsls	r6, r6, #4
 1433              	.LVL157:
 555:ff.c          **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 1434              		.loc 1 555 3 is_stmt 1 view .LVU502
 1435              	.L127:
 555:ff.c          **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 1436              		.loc 1 555 9 view .LVU503
 1437 004e B442     		cmp	r4, r6
 1438 0050 2868     		ldr	r0, [r5]
 1439 0052 06D2     		bcs	.L128
 562:ff.c          **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
 1440              		.loc 1 562 3 view .LVU504
 562:ff.c          **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
 1441              		.loc 1 562 13 is_stmt 0 view .LVU505
 1442 0054 E960     		str	r1, [r5, #12]
 563:ff.c          **** 	}
 1443              		.loc 1 563 3 is_stmt 1 view .LVU506
 563:ff.c          **** 	}
 1444              		.loc 1 563 14 is_stmt 0 view .LVU507
 1445 0056 FFF7FEFF 		bl	clust2sect
 1446              	.LVL158:
 563:ff.c          **** 	}
 1447              		.loc 1 563 39 view .LVU508
 1448 005a 00EB1410 		add	r0, r0, r4, lsr #4
 563:ff.c          **** 	}
 1449              		.loc 1 563 12 view .LVU509
 1450 005e 2861     		str	r0, [r5, #16]
 1451 0060 EAE7     		b	.L126
 1452              	.LVL159:
 1453              	.L128:
 556:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1454              		.loc 1 556 4 is_stmt 1 view .LVU510
 556:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1455              		.loc 1 556 11 is_stmt 0 view .LVU511
 1456 0062 FFF7FEFF 		bl	get_fat
 1457              	.LVL160:
 557:ff.c          **** 			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 1458              		.loc 1 557 7 view .LVU512
 1459 0066 431C     		adds	r3, r0, #1
 556:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1460              		.loc 1 556 11 view .LVU513
 1461 0068 0146     		mov	r1, r0
 1462              	.LVL161:
 557:ff.c          **** 			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 1463              		.loc 1 557 4 is_stmt 1 view .LVU514
 557:ff.c          **** 			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 1464              		.loc 1 557 7 is_stmt 0 view .LVU515
 1465 006a 08D0     		beq	.L129
 558:ff.c          **** 				return FR_INT_ERR;
 1466              		.loc 1 558 4 is_stmt 1 view .LVU516
 558:ff.c          **** 				return FR_INT_ERR;
 1467              		.loc 1 558 7 is_stmt 0 view .LVU517
 1468 006c 0128     		cmp	r0, #1
 1469 006e CED9     		bls	.L123
 558:ff.c          **** 				return FR_INT_ERR;
 1470              		.loc 1 558 34 discriminator 1 view .LVU518
 1471 0070 2B68     		ldr	r3, [r5]
 558:ff.c          **** 				return FR_INT_ERR;
 1472              		.loc 1 558 17 discriminator 1 view .LVU519
 1473 0072 1B6A     		ldr	r3, [r3, #32]
 1474 0074 8342     		cmp	r3, r0
 1475 0076 CAD9     		bls	.L123
 560:ff.c          **** 		}
 1476              		.loc 1 560 4 is_stmt 1 view .LVU520
 560:ff.c          **** 		}
 1477              		.loc 1 560 8 is_stmt 0 view .LVU521
 1478 0078 A41B     		subs	r4, r4, r6
 1479              	.LVL162:
 560:ff.c          **** 		}
 1480              		.loc 1 560 8 view .LVU522
 1481 007a A4B2     		uxth	r4, r4
 1482              	.LVL163:
 560:ff.c          **** 		}
 1483              		.loc 1 560 8 view .LVU523
 1484 007c E7E7     		b	.L127
 1485              	.L129:
 557:ff.c          **** 			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 1486              		.loc 1 557 35 view .LVU524
 1487 007e 0120     		movs	r0, #1
 1488              	.LVL164:
 557:ff.c          **** 			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 1489              		.loc 1 557 35 view .LVU525
 1490 0080 C6E7     		b	.L122
 1491              		.cfi_endproc
 1492              	.LFE40:
 1494              		.section	.text.put_fat,"ax",%progbits
 1495              		.align	1
 1496              		.syntax unified
 1497              		.thumb
 1498              		.thumb_func
 1499              		.fpu softvfp
 1501              	put_fat:
 1502              	.LVL165:
 1503              	.LFB36:
 356:ff.c          **** 	UINT bc;
 1504              		.loc 1 356 1 is_stmt 1 view -0
 1505              		.cfi_startproc
 1506              		@ args = 0, pretend = 0, frame = 0
 1507              		@ frame_needed = 0, uses_anonymous_args = 0
 357:ff.c          **** 	BYTE *p;
 1508              		.loc 1 357 2 view .LVU527
 358:ff.c          **** 	DWORD fsect;
 1509              		.loc 1 358 2 view .LVU528
 359:ff.c          **** 	FRESULT res;
 1510              		.loc 1 359 2 view .LVU529
 360:ff.c          **** 
 1511              		.loc 1 360 2 view .LVU530
 363:ff.c          **** 		res = FR_INT_ERR;
 1512              		.loc 1 363 2 view .LVU531
 363:ff.c          **** 		res = FR_INT_ERR;
 1513              		.loc 1 363 5 is_stmt 0 view .LVU532
 1514 0000 0129     		cmp	r1, #1
 356:ff.c          **** 	UINT bc;
 1515              		.loc 1 356 1 view .LVU533
 1516 0002 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1517              		.cfi_def_cfa_offset 24
 1518              		.cfi_offset 4, -24
 1519              		.cfi_offset 5, -20
 1520              		.cfi_offset 6, -16
 1521              		.cfi_offset 7, -12
 1522              		.cfi_offset 8, -8
 1523              		.cfi_offset 14, -4
 356:ff.c          **** 	UINT bc;
 1524              		.loc 1 356 1 view .LVU534
 1525 0006 0646     		mov	r6, r0
 1526 0008 0C46     		mov	r4, r1
 1527 000a 1546     		mov	r5, r2
 363:ff.c          **** 		res = FR_INT_ERR;
 1528              		.loc 1 363 5 view .LVU535
 1529 000c 6AD9     		bls	.L140
 363:ff.c          **** 		res = FR_INT_ERR;
 1530              		.loc 1 363 15 discriminator 1 view .LVU536
 1531 000e 036A     		ldr	r3, [r0, #32]
 1532 0010 8B42     		cmp	r3, r1
 1533 0012 67D9     		bls	.L140
 1534              	.LVL166:
 1535              	.LBB28:
 1536              	.LBI28:
 351:ff.c          **** 	FATFS *fs,	/* File system object */
 1537              		.loc 1 351 9 is_stmt 1 view .LVU537
 1538              	.LBB29:
 367:ff.c          **** 		switch (fs->fs_type) {
 1539              		.loc 1 367 3 view .LVU538
 368:ff.c          **** 		case FS_FAT12 :
 1540              		.loc 1 368 13 is_stmt 0 view .LVU539
 1541 0014 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 367:ff.c          **** 		switch (fs->fs_type) {
 1542              		.loc 1 367 9 view .LVU540
 1543 0016 D0F82480 		ldr	r8, [r0, #36]
 1544              	.LVL167:
 368:ff.c          **** 		case FS_FAT12 :
 1545              		.loc 1 368 3 is_stmt 1 view .LVU541
 1546 001a 022B     		cmp	r3, #2
 1547 001c 39D0     		beq	.L132
 1548 001e 032B     		cmp	r3, #3
 1549 0020 48D0     		beq	.L133
 1550 0022 012B     		cmp	r3, #1
 1551 0024 5CD1     		bne	.L141
 370:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 1552              		.loc 1 370 4 view .LVU542
 1553              	.LVL168:
 370:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 1554              		.loc 1 370 15 view .LVU543
 370:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 1555              		.loc 1 370 18 is_stmt 0 view .LVU544
 1556 0026 01EB5107 		add	r7, r1, r1, lsr #1
 1557              	.LVL169:
 371:ff.c          **** 			if (res != FR_OK) break;
 1558              		.loc 1 371 4 is_stmt 1 view .LVU545
 371:ff.c          **** 			if (res != FR_OK) break;
 1559              		.loc 1 371 10 is_stmt 0 view .LVU546
 1560 002a 08EB5721 		add	r1, r8, r7, lsr #9
 1561              	.LVL170:
 371:ff.c          **** 			if (res != FR_OK) break;
 1562              		.loc 1 371 10 view .LVU547
 1563 002e FFF7FEFF 		bl	move_window
 1564              	.LVL171:
 372:ff.c          **** 			p = &fs->win[bc & (SS(fs) - 1)];
 1565              		.loc 1 372 4 is_stmt 1 view .LVU548
 372:ff.c          **** 			p = &fs->win[bc & (SS(fs) - 1)];
 1566              		.loc 1 372 7 is_stmt 0 view .LVU549
 1567 0032 10BB     		cbnz	r0, .L134
 373:ff.c          **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 1568              		.loc 1 373 4 is_stmt 1 view .LVU550
 373:ff.c          **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 1569              		.loc 1 373 20 is_stmt 0 view .LVU551
 1570 0034 C7F30803 		ubfx	r3, r7, #0, #9
 1571              	.LVL172:
 374:ff.c          **** 			bc++;
 1572              		.loc 1 374 4 is_stmt 1 view .LVU552
 374:ff.c          **** 			bc++;
 1573              		.loc 1 374 7 is_stmt 0 view .LVU553
 1574 0038 14F00104 		ands	r4, r4, #1
 1575              	.LVL173:
 374:ff.c          **** 			bc++;
 1576              		.loc 1 374 7 view .LVU554
 1577 003c 3344     		add	r3, r3, r6
 374:ff.c          **** 			bc++;
 1578              		.loc 1 374 27 view .LVU555
 1579 003e 17BF     		itett	ne
 1580 0040 93F83420 		ldrbne	r2, [r3, #52]	@ zero_extendqisi2
 374:ff.c          **** 			bc++;
 1581              		.loc 1 374 7 view .LVU556
 1582 0044 EAB2     		uxtbeq	r2, r5
 374:ff.c          **** 			bc++;
 1583              		.loc 1 374 27 view .LVU557
 1584 0046 02F00F01 		andne	r1, r2, #15
 374:ff.c          **** 			bc++;
 1585              		.loc 1 374 48 view .LVU558
 1586 004a 2A01     		lslne	r2, r5, #4
 374:ff.c          **** 			bc++;
 1587              		.loc 1 374 35 view .LVU559
 1588 004c 1CBF     		itt	ne
 1589 004e 02F0F002 		andne	r2, r2, #240
 374:ff.c          **** 			bc++;
 1590              		.loc 1 374 7 view .LVU560
 1591 0052 0A43     		orrne	r2, r2, r1
 1592 0054 83F83420 		strb	r2, [r3, #52]
 375:ff.c          **** 			fs->wflag = 1;
 1593              		.loc 1 375 4 is_stmt 1 view .LVU561
 376:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 1594              		.loc 1 376 14 is_stmt 0 view .LVU562
 1595 0058 0123     		movs	r3, #1
 375:ff.c          **** 			fs->wflag = 1;
 1596              		.loc 1 375 6 view .LVU563
 1597 005a 0137     		adds	r7, r7, #1
 1598              	.LVL174:
 376:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 1599              		.loc 1 376 4 is_stmt 1 view .LVU564
 377:ff.c          **** 			if (res != FR_OK) break;
 1600              		.loc 1 377 10 is_stmt 0 view .LVU565
 1601 005c 3046     		mov	r0, r6
 1602              	.LVL175:
 376:ff.c          **** 			res = move_window(fs, fsect + (bc / SS(fs)));
 1603              		.loc 1 376 14 view .LVU566
 1604 005e 3371     		strb	r3, [r6, #4]
 377:ff.c          **** 			if (res != FR_OK) break;
 1605              		.loc 1 377 4 is_stmt 1 view .LVU567
 377:ff.c          **** 			if (res != FR_OK) break;
 1606              		.loc 1 377 10 is_stmt 0 view .LVU568
 1607 0060 08EB5721 		add	r1, r8, r7, lsr #9
 1608 0064 FFF7FEFF 		bl	move_window
 1609              	.LVL176:
 378:ff.c          **** 			p = &fs->win[bc & (SS(fs) - 1)];
 1610              		.loc 1 378 4 is_stmt 1 view .LVU569
 378:ff.c          **** 			p = &fs->win[bc & (SS(fs) - 1)];
 1611              		.loc 1 378 7 is_stmt 0 view .LVU570
 1612 0068 38B9     		cbnz	r0, .L134
 379:ff.c          **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 1613              		.loc 1 379 4 is_stmt 1 view .LVU571
 379:ff.c          **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 1614              		.loc 1 379 20 is_stmt 0 view .LVU572
 1615 006a C7F30807 		ubfx	r7, r7, #0, #9
 1616              	.LVL177:
 380:ff.c          **** 			break;
 1617              		.loc 1 380 4 is_stmt 1 view .LVU573
 1618 006e 3744     		add	r7, r7, r6
 380:ff.c          **** 			break;
 1619              		.loc 1 380 7 is_stmt 0 view .LVU574
 1620 0070 3CB1     		cbz	r4, .L137
 380:ff.c          **** 			break;
 1621              		.loc 1 380 7 view .LVU575
 1622 0072 C5F30715 		ubfx	r5, r5, #4, #8
 1623              	.LVL178:
 1624              	.L138:
 380:ff.c          **** 			break;
 1625              		.loc 1 380 7 view .LVU576
 1626 0076 87F83450 		strb	r5, [r7, #52]
 381:ff.c          **** 
 1627              		.loc 1 381 4 is_stmt 1 view .LVU577
 1628              	.LVL179:
 1629              	.L134:
 398:ff.c          **** 	}
 1630              		.loc 1 398 3 view .LVU578
 398:ff.c          **** 	}
 1631              		.loc 1 398 13 is_stmt 0 view .LVU579
 1632 007a 0123     		movs	r3, #1
 1633 007c 3371     		strb	r3, [r6, #4]
 401:ff.c          **** }
 1634              		.loc 1 401 2 is_stmt 1 view .LVU580
 1635              	.LVL180:
 1636              	.L131:
 401:ff.c          **** }
 1637              		.loc 1 401 2 is_stmt 0 view .LVU581
 1638              	.LBE29:
 1639              	.LBE28:
 401:ff.c          **** }
 1640              		.loc 1 401 2 is_stmt 1 view .LVU582
 402:ff.c          **** #endif /* !_FS_READONLY */
 1641              		.loc 1 402 1 is_stmt 0 view .LVU583
 1642 007e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1643              	.LVL181:
 1644              	.L137:
 1645              	.LBB31:
 1646              	.LBB30:
 380:ff.c          **** 			break;
 1647              		.loc 1 380 46 view .LVU584
 1648 0082 97F83430 		ldrb	r3, [r7, #52]	@ zero_extendqisi2
 380:ff.c          **** 			break;
 1649              		.loc 1 380 74 view .LVU585
 1650 0086 C5F30325 		ubfx	r5, r5, #8, #4
 1651              	.LVL182:
 380:ff.c          **** 			break;
 1652              		.loc 1 380 46 view .LVU586
 1653 008a 23F00F03 		bic	r3, r3, #15
 380:ff.c          **** 			break;
 1654              		.loc 1 380 7 view .LVU587
 1655 008e 1D43     		orrs	r5, r5, r3
 1656 0090 F1E7     		b	.L138
 1657              	.LVL183:
 1658              	.L132:
 384:ff.c          **** 			if (res != FR_OK) break;
 1659              		.loc 1 384 4 is_stmt 1 view .LVU588
 384:ff.c          **** 			if (res != FR_OK) break;
 1660              		.loc 1 384 10 is_stmt 0 view .LVU589
 1661 0092 08EB1121 		add	r1, r8, r1, lsr #8
 1662              	.LVL184:
 384:ff.c          **** 			if (res != FR_OK) break;
 1663              		.loc 1 384 10 view .LVU590
 1664 0096 FFF7FEFF 		bl	move_window
 1665              	.LVL185:
 385:ff.c          **** 			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
 1666              		.loc 1 385 4 is_stmt 1 view .LVU591
 385:ff.c          **** 			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
 1667              		.loc 1 385 7 is_stmt 0 view .LVU592
 1668 009a 0028     		cmp	r0, #0
 1669 009c EDD1     		bne	.L134
 386:ff.c          **** 			break;
 1670              		.loc 1 386 4 is_stmt 1 view .LVU593
 1671 009e 6400     		lsls	r4, r4, #1
 1672              	.LVL186:
 386:ff.c          **** 			break;
 1673              		.loc 1 386 4 is_stmt 0 view .LVU594
 1674 00a0 04F4FF74 		and	r4, r4, #510
 1675 00a4 3444     		add	r4, r4, r6
 1676 00a6 84F83450 		strb	r5, [r4, #52]
 386:ff.c          **** 			break;
 1677              		.loc 1 386 4 is_stmt 1 view .LVU595
 1678 00aa C5F30725 		ubfx	r5, r5, #8, #8
 1679              	.LVL187:
 386:ff.c          **** 			break;
 1680              		.loc 1 386 4 is_stmt 0 view .LVU596
 1681 00ae 84F83550 		strb	r5, [r4, #53]
 387:ff.c          **** 
 1682              		.loc 1 387 4 is_stmt 1 view .LVU597
 1683 00b2 E2E7     		b	.L134
 1684              	.LVL188:
 1685              	.L133:
 390:ff.c          **** 			if (res != FR_OK) break;
 1686              		.loc 1 390 4 view .LVU598
 390:ff.c          **** 			if (res != FR_OK) break;
 1687              		.loc 1 390 10 is_stmt 0 view .LVU599
 1688 00b4 08EBD111 		add	r1, r8, r1, lsr #7
 1689              	.LVL189:
 390:ff.c          **** 			if (res != FR_OK) break;
 1690              		.loc 1 390 10 view .LVU600
 1691 00b8 FFF7FEFF 		bl	move_window
 1692              	.LVL190:
 391:ff.c          **** 			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
 1693              		.loc 1 391 4 is_stmt 1 view .LVU601
 391:ff.c          **** 			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
 1694              		.loc 1 391 7 is_stmt 0 view .LVU602
 1695 00bc 0028     		cmp	r0, #0
 1696 00be DCD1     		bne	.L134
 392:ff.c          **** 			break;
 1697              		.loc 1 392 4 is_stmt 1 view .LVU603
 1698 00c0 A400     		lsls	r4, r4, #2
 1699              	.LVL191:
 392:ff.c          **** 			break;
 1700              		.loc 1 392 4 is_stmt 0 view .LVU604
 1701 00c2 04F4FE74 		and	r4, r4, #508
 1702 00c6 3319     		adds	r3, r6, r4
 1703 00c8 3434     		adds	r4, r4, #52
 1704 00ca 83F83450 		strb	r5, [r3, #52]
 392:ff.c          **** 			break;
 1705              		.loc 1 392 4 is_stmt 1 view .LVU605
 1706 00ce 3444     		add	r4, r4, r6
 1707 00d0 C5F30723 		ubfx	r3, r5, #8, #8
 1708 00d4 6370     		strb	r3, [r4, #1]
 392:ff.c          **** 			break;
 1709              		.loc 1 392 4 view .LVU606
 1710 00d6 2B0C     		lsrs	r3, r5, #16
 1711 00d8 2D0E     		lsrs	r5, r5, #24
 1712              	.LVL192:
 392:ff.c          **** 			break;
 1713              		.loc 1 392 4 is_stmt 0 view .LVU607
 1714 00da A370     		strb	r3, [r4, #2]
 392:ff.c          **** 			break;
 1715              		.loc 1 392 4 is_stmt 1 view .LVU608
 1716 00dc E570     		strb	r5, [r4, #3]
 393:ff.c          **** 
 1717              		.loc 1 393 4 view .LVU609
 1718 00de CCE7     		b	.L134
 1719              	.LVL193:
 1720              	.L141:
 368:ff.c          **** 		case FS_FAT12 :
 1721              		.loc 1 368 3 is_stmt 0 view .LVU610
 1722 00e0 0220     		movs	r0, #2
 1723              	.LVL194:
 368:ff.c          **** 		case FS_FAT12 :
 1724              		.loc 1 368 3 view .LVU611
 1725 00e2 CAE7     		b	.L134
 1726              	.LVL195:
 1727              	.L140:
 368:ff.c          **** 		case FS_FAT12 :
 1728              		.loc 1 368 3 view .LVU612
 1729              	.LBE30:
 1730              	.LBE31:
 364:ff.c          **** 
 1731              		.loc 1 364 7 view .LVU613
 1732 00e4 0220     		movs	r0, #2
 1733              	.LVL196:
 364:ff.c          **** 
 1734              		.loc 1 364 7 view .LVU614
 1735 00e6 CAE7     		b	.L131
 1736              		.cfi_endproc
 1737              	.LFE36:
 1739              		.section	.text.create_chain,"ax",%progbits
 1740              		.align	1
 1741              		.syntax unified
 1742              		.thumb
 1743              		.thumb_func
 1744              		.fpu softvfp
 1746              	create_chain:
 1747              	.LVL197:
 1748              	.LFB38:
 458:ff.c          **** 	DWORD cs, ncl, scl, mcl;
 1749              		.loc 1 458 1 is_stmt 1 view -0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 0
 1752              		@ frame_needed = 0, uses_anonymous_args = 0
 459:ff.c          **** 
 1753              		.loc 1 459 2 view .LVU616
 462:ff.c          **** 	if (clst == 0) {		/* Create new chain */
 1754              		.loc 1 462 2 view .LVU617
 458:ff.c          **** 	DWORD cs, ncl, scl, mcl;
 1755              		.loc 1 458 1 is_stmt 0 view .LVU618
 1756 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1757              		.cfi_def_cfa_offset 24
 1758              		.cfi_offset 4, -24
 1759              		.cfi_offset 5, -20
 1760              		.cfi_offset 6, -16
 1761              		.cfi_offset 7, -12
 1762              		.cfi_offset 8, -8
 1763              		.cfi_offset 14, -4
 458:ff.c          **** 	DWORD cs, ncl, scl, mcl;
 1764              		.loc 1 458 1 view .LVU619
 1765 0004 0546     		mov	r5, r0
 463:ff.c          **** 		scl = fs->last_clust;			/* Get suggested start point */
 1766              		.loc 1 463 5 view .LVU620
 1767 0006 0F46     		mov	r7, r1
 462:ff.c          **** 	if (clst == 0) {		/* Create new chain */
 1768              		.loc 1 462 6 view .LVU621
 1769 0008 D0F82080 		ldr	r8, [r0, #32]
 1770              	.LVL198:
 463:ff.c          **** 		scl = fs->last_clust;			/* Get suggested start point */
 1771              		.loc 1 463 2 is_stmt 1 view .LVU622
 463:ff.c          **** 		scl = fs->last_clust;			/* Get suggested start point */
 1772              		.loc 1 463 5 is_stmt 0 view .LVU623
 1773 000c 61B9     		cbnz	r1, .L143
 464:ff.c          **** 		if (scl == 0 || scl >= mcl) scl = 1;
 1774              		.loc 1 464 3 is_stmt 1 view .LVU624
 464:ff.c          **** 		if (scl == 0 || scl >= mcl) scl = 1;
 1775              		.loc 1 464 7 is_stmt 0 view .LVU625
 1776 000e C668     		ldr	r6, [r0, #12]
 1777              	.LVL199:
 465:ff.c          **** 	}
 1778              		.loc 1 465 3 is_stmt 1 view .LVU626
 465:ff.c          **** 	}
 1779              		.loc 1 465 6 is_stmt 0 view .LVU627
 1780 0010 BEB1     		cbz	r6, .L157
 465:ff.c          **** 	}
 1781              		.loc 1 465 35 discriminator 2 view .LVU628
 1782 0012 B045     		cmp	r8, r6
 1783 0014 98BF     		it	ls
 1784 0016 0126     		movls	r6, #1
 1785              	.LVL200:
 1786              	.L144:
 474:ff.c          **** 	for (;;) {
 1787              		.loc 1 474 2 is_stmt 1 view .LVU629
 474:ff.c          **** 	for (;;) {
 1788              		.loc 1 474 2 is_stmt 0 view .LVU630
 1789 0018 3446     		mov	r4, r6
 1790              	.LVL201:
 1791              	.L152:
 475:ff.c          **** 		ncl++;							/* Next cluster */
 1792              		.loc 1 475 2 is_stmt 1 view .LVU631
 476:ff.c          **** 		if (ncl >= mcl) {				/* Wrap around */
 1793              		.loc 1 476 3 view .LVU632
 476:ff.c          **** 		if (ncl >= mcl) {				/* Wrap around */
 1794              		.loc 1 476 6 is_stmt 0 view .LVU633
 1795 001a 0134     		adds	r4, r4, #1
 1796              	.LVL202:
 477:ff.c          **** 			ncl = 2;
 1797              		.loc 1 477 3 is_stmt 1 view .LVU634
 477:ff.c          **** 			ncl = 2;
 1798              		.loc 1 477 6 is_stmt 0 view .LVU635
 1799 001c A045     		cmp	r8, r4
 1800 001e 13D8     		bhi	.L147
 478:ff.c          **** 			if (ncl > scl) return 0;	/* No free custer */
 1801              		.loc 1 478 4 is_stmt 1 view .LVU636
 1802              	.LVL203:
 479:ff.c          **** 		}
 1803              		.loc 1 479 4 view .LVU637
 479:ff.c          **** 		}
 1804              		.loc 1 479 7 is_stmt 0 view .LVU638
 1805 0020 012E     		cmp	r6, #1
 1806 0022 10D8     		bhi	.L158
 1807              	.LVL204:
 1808              	.L151:
 479:ff.c          **** 		}
 1809              		.loc 1 479 26 view .LVU639
 1810 0024 0024     		movs	r4, #0
 1811 0026 05E0     		b	.L142
 1812              	.LVL205:
 1813              	.L143:
 468:ff.c          **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 1814              		.loc 1 468 3 is_stmt 1 view .LVU640
 468:ff.c          **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 1815              		.loc 1 468 8 is_stmt 0 view .LVU641
 1816 0028 FFF7FEFF 		bl	get_fat
 1817              	.LVL206:
 469:ff.c          **** 		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 1818              		.loc 1 469 6 view .LVU642
 1819 002c 0128     		cmp	r0, #1
 468:ff.c          **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 1820              		.loc 1 468 8 view .LVU643
 1821 002e 0446     		mov	r4, r0
 1822              	.LVL207:
 469:ff.c          **** 		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 1823              		.loc 1 469 3 is_stmt 1 view .LVU644
 469:ff.c          **** 		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 1824              		.loc 1 469 6 is_stmt 0 view .LVU645
 1825 0030 03D8     		bhi	.L145
 1826              	.L150:
 469:ff.c          **** 		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 1827              		.loc 1 469 22 view .LVU646
 1828 0032 0124     		movs	r4, #1
 1829              	.LVL208:
 1830              	.L142:
 502:ff.c          **** #endif /* !_FS_READONLY */
 1831              		.loc 1 502 1 view .LVU647
 1832 0034 2046     		mov	r0, r4
 1833 0036 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1834              	.LVL209:
 1835              	.L145:
 470:ff.c          **** 		scl = clst;
 1836              		.loc 1 470 3 is_stmt 1 view .LVU648
 470:ff.c          **** 		scl = clst;
 1837              		.loc 1 470 6 is_stmt 0 view .LVU649
 1838 003a 8045     		cmp	r8, r0
 1839 003c FAD8     		bhi	.L142
 1840 003e 3E46     		mov	r6, r7
 1841 0040 EAE7     		b	.L144
 1842              	.LVL210:
 1843              	.L157:
 465:ff.c          **** 	}
 1844              		.loc 1 465 35 view .LVU650
 1845 0042 0126     		movs	r6, #1
 1846              	.LVL211:
 465:ff.c          **** 	}
 1847              		.loc 1 465 35 view .LVU651
 1848 0044 E8E7     		b	.L144
 1849              	.LVL212:
 1850              	.L158:
 478:ff.c          **** 			if (ncl > scl) return 0;	/* No free custer */
 1851              		.loc 1 478 8 view .LVU652
 1852 0046 0224     		movs	r4, #2
 1853              	.LVL213:
 1854              	.L147:
 481:ff.c          **** 		if (cs == 0) break;				/* Found a free cluster */
 1855              		.loc 1 481 3 is_stmt 1 view .LVU653
 481:ff.c          **** 		if (cs == 0) break;				/* Found a free cluster */
 1856              		.loc 1 481 8 is_stmt 0 view .LVU654
 1857 0048 2146     		mov	r1, r4
 1858 004a 2846     		mov	r0, r5
 1859 004c FFF7FEFF 		bl	get_fat
 1860              	.LVL214:
 482:ff.c          **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
 1861              		.loc 1 482 3 is_stmt 1 view .LVU655
 482:ff.c          **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
 1862              		.loc 1 482 6 is_stmt 0 view .LVU656
 1863 0050 48B1     		cbz	r0, .L148
 483:ff.c          **** 			return cs;
 1864              		.loc 1 483 3 is_stmt 1 view .LVU657
 483:ff.c          **** 			return cs;
 1865              		.loc 1 483 6 is_stmt 0 view .LVU658
 1866 0052 411C     		adds	r1, r0, #1
 1867 0054 02D1     		bne	.L149
 1868              	.LVL215:
 1869              	.L153:
 469:ff.c          **** 		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 1870              		.loc 1 469 22 view .LVU659
 1871 0056 4FF0FF34 		mov	r4, #-1
 1872              	.LVL216:
 469:ff.c          **** 		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 1873              		.loc 1 469 22 view .LVU660
 1874 005a EBE7     		b	.L142
 1875              	.LVL217:
 1876              	.L149:
 483:ff.c          **** 			return cs;
 1877              		.loc 1 483 24 discriminator 1 view .LVU661
 1878 005c 0128     		cmp	r0, #1
 1879 005e E8D0     		beq	.L150
 485:ff.c          **** 	}
 1880              		.loc 1 485 3 is_stmt 1 view .LVU662
 485:ff.c          **** 	}
 1881              		.loc 1 485 6 is_stmt 0 view .LVU663
 1882 0060 B442     		cmp	r4, r6
 1883 0062 DAD1     		bne	.L152
 1884 0064 DEE7     		b	.L151
 1885              	.L148:
 488:ff.c          **** 		return 0xFFFFFFFF;
 1886              		.loc 1 488 2 is_stmt 1 view .LVU664
 488:ff.c          **** 		return 0xFFFFFFFF;
 1887              		.loc 1 488 6 is_stmt 0 view .LVU665
 1888 0066 6FF07042 		mvn	r2, #-268435456
 1889 006a 2146     		mov	r1, r4
 1890 006c 2846     		mov	r0, r5
 1891              	.LVL218:
 488:ff.c          **** 		return 0xFFFFFFFF;
 1892              		.loc 1 488 6 view .LVU666
 1893 006e FFF7FEFF 		bl	put_fat
 1894              	.LVL219:
 488:ff.c          **** 		return 0xFFFFFFFF;
 1895              		.loc 1 488 5 view .LVU667
 1896 0072 0028     		cmp	r0, #0
 1897 0074 EFD1     		bne	.L153
 490:ff.c          **** 		if (put_fat(fs, clst, ncl))
 1898              		.loc 1 490 2 is_stmt 1 view .LVU668
 490:ff.c          **** 		if (put_fat(fs, clst, ncl))
 1899              		.loc 1 490 5 is_stmt 0 view .LVU669
 1900 0076 47B9     		cbnz	r7, .L154
 1901              	.L156:
 495:ff.c          **** 	if (fs->free_clust != 0xFFFFFFFF) {
 1902              		.loc 1 495 2 is_stmt 1 view .LVU670
 496:ff.c          **** 		fs->free_clust--;
 1903              		.loc 1 496 8 is_stmt 0 view .LVU671
 1904 0078 2B69     		ldr	r3, [r5, #16]
 495:ff.c          **** 	if (fs->free_clust != 0xFFFFFFFF) {
 1905              		.loc 1 495 17 view .LVU672
 1906 007a EC60     		str	r4, [r5, #12]
 496:ff.c          **** 		fs->free_clust--;
 1907              		.loc 1 496 2 is_stmt 1 view .LVU673
 496:ff.c          **** 		fs->free_clust--;
 1908              		.loc 1 496 5 is_stmt 0 view .LVU674
 1909 007c 5A1C     		adds	r2, r3, #1
 1910 007e D9D0     		beq	.L142
 497:ff.c          **** 		fs->fsi_flag = 1;
 1911              		.loc 1 497 3 is_stmt 1 view .LVU675
 497:ff.c          **** 		fs->fsi_flag = 1;
 1912              		.loc 1 497 17 is_stmt 0 view .LVU676
 1913 0080 013B     		subs	r3, r3, #1
 1914 0082 2B61     		str	r3, [r5, #16]
 498:ff.c          **** 	}
 1915              		.loc 1 498 3 is_stmt 1 view .LVU677
 498:ff.c          **** 	}
 1916              		.loc 1 498 16 is_stmt 0 view .LVU678
 1917 0084 0123     		movs	r3, #1
 1918 0086 AB72     		strb	r3, [r5, #10]
 1919 0088 D4E7     		b	.L142
 1920              	.L154:
 491:ff.c          **** 			return 0xFFFFFFFF;
 1921              		.loc 1 491 3 is_stmt 1 view .LVU679
 491:ff.c          **** 			return 0xFFFFFFFF;
 1922              		.loc 1 491 7 is_stmt 0 view .LVU680
 1923 008a 2246     		mov	r2, r4
 1924 008c 3946     		mov	r1, r7
 1925 008e 2846     		mov	r0, r5
 1926 0090 FFF7FEFF 		bl	put_fat
 1927              	.LVL220:
 491:ff.c          **** 			return 0xFFFFFFFF;
 1928              		.loc 1 491 6 view .LVU681
 1929 0094 0028     		cmp	r0, #0
 1930 0096 EFD0     		beq	.L156
 1931 0098 DDE7     		b	.L153
 1932              		.cfi_endproc
 1933              	.LFE38:
 1935              		.section	.text.dir_next,"ax",%progbits
 1936              		.align	1
 1937              		.syntax unified
 1938              		.thumb
 1939              		.thumb_func
 1940              		.fpu softvfp
 1942              	dir_next:
 1943              	.LVL221:
 1944              	.LFB41:
 583:ff.c          **** 	DWORD clst;
 1945              		.loc 1 583 1 is_stmt 1 view -0
 1946              		.cfi_startproc
 1947              		@ args = 0, pretend = 0, frame = 0
 1948              		@ frame_needed = 0, uses_anonymous_args = 0
 584:ff.c          **** 	WORD i;
 1949              		.loc 1 584 2 view .LVU683
 585:ff.c          **** 
 1950              		.loc 1 585 2 view .LVU684
 588:ff.c          **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 1951              		.loc 1 588 2 view .LVU685
 583:ff.c          **** 	DWORD clst;
 1952              		.loc 1 583 1 is_stmt 0 view .LVU686
 1953 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1954              		.cfi_def_cfa_offset 32
 1955              		.cfi_offset 3, -32
 1956              		.cfi_offset 4, -28
 1957              		.cfi_offset 5, -24
 1958              		.cfi_offset 6, -20
 1959              		.cfi_offset 7, -16
 1960              		.cfi_offset 8, -12
 1961              		.cfi_offset 9, -8
 1962              		.cfi_offset 14, -4
 588:ff.c          **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 1963              		.loc 1 588 4 view .LVU687
 1964 0004 C688     		ldrh	r6, [r0, #6]
 583:ff.c          **** 	DWORD clst;
 1965              		.loc 1 583 1 view .LVU688
 1966 0006 0446     		mov	r4, r0
 588:ff.c          **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 1967              		.loc 1 588 4 view .LVU689
 1968 0008 0136     		adds	r6, r6, #1
 1969 000a B6B2     		uxth	r6, r6
 1970              	.LVL222:
 589:ff.c          **** 		return FR_NO_FILE;
 1971              		.loc 1 589 2 is_stmt 1 view .LVU690
 583:ff.c          **** 	DWORD clst;
 1972              		.loc 1 583 1 is_stmt 0 view .LVU691
 1973 000c 8946     		mov	r9, r1
 589:ff.c          **** 		return FR_NO_FILE;
 1974              		.loc 1 589 5 view .LVU692
 1975 000e 16B9     		cbnz	r6, .L163
 1976              	.LVL223:
 1977              	.L165:
 590:ff.c          **** 
 1978              		.loc 1 590 10 view .LVU693
 1979 0010 0420     		movs	r0, #4
 1980              	.L164:
 636:ff.c          **** 
 1981              		.loc 1 636 1 view .LVU694
 1982 0012 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1983              	.LVL224:
 1984              	.L163:
 589:ff.c          **** 		return FR_NO_FILE;
 1985              		.loc 1 589 15 discriminator 1 view .LVU695
 1986 0016 0369     		ldr	r3, [r0, #16]
 589:ff.c          **** 		return FR_NO_FILE;
 1987              		.loc 1 589 9 discriminator 1 view .LVU696
 1988 0018 002B     		cmp	r3, #0
 1989 001a F9D0     		beq	.L165
 592:ff.c          **** 		dj->sect++;					/* Next sector */
 1990              		.loc 1 592 2 is_stmt 1 view .LVU697
 592:ff.c          **** 		dj->sect++;					/* Next sector */
 1991              		.loc 1 592 5 is_stmt 0 view .LVU698
 1992 001c 16F00F08 		ands	r8, r6, #15
 1993 0020 07D1     		bne	.L167
 595:ff.c          **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 1994              		.loc 1 595 9 view .LVU699
 1995 0022 E168     		ldr	r1, [r4, #12]
 1996              	.LVL225:
 593:ff.c          **** 
 1997              		.loc 1 593 11 view .LVU700
 1998 0024 0133     		adds	r3, r3, #1
 1999 0026 0068     		ldr	r0, [r0]
 2000              	.LVL226:
 593:ff.c          **** 
 2001              		.loc 1 593 3 is_stmt 1 view .LVU701
 593:ff.c          **** 
 2002              		.loc 1 593 11 is_stmt 0 view .LVU702
 2003 0028 2361     		str	r3, [r4, #16]
 595:ff.c          **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 2004              		.loc 1 595 3 is_stmt 1 view .LVU703
 595:ff.c          **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 2005              		.loc 1 595 6 is_stmt 0 view .LVU704
 2006 002a 51B9     		cbnz	r1, .L168
 596:ff.c          **** 				return FR_NO_FILE;
 2007              		.loc 1 596 4 is_stmt 1 view .LVU705
 596:ff.c          **** 				return FR_NO_FILE;
 2008              		.loc 1 596 7 is_stmt 0 view .LVU706
 2009 002c 0389     		ldrh	r3, [r0, #8]
 2010 002e B342     		cmp	r3, r6
 2011 0030 EED9     		bls	.L165
 2012              	.L167:
 632:ff.c          **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
 2013              		.loc 1 632 2 is_stmt 1 view .LVU707
 633:ff.c          **** 
 2014              		.loc 1 633 12 is_stmt 0 view .LVU708
 2015 0032 2368     		ldr	r3, [r4]
 635:ff.c          **** }
 2016              		.loc 1 635 9 view .LVU709
 2017 0034 0020     		movs	r0, #0
 633:ff.c          **** 
 2018              		.loc 1 633 12 view .LVU710
 2019 0036 3433     		adds	r3, r3, #52
 633:ff.c          **** 
 2020              		.loc 1 633 24 view .LVU711
 2021 0038 03EB4813 		add	r3, r3, r8, lsl #5
 632:ff.c          **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
 2022              		.loc 1 632 12 view .LVU712
 2023 003c E680     		strh	r6, [r4, #6]	@ movhi
 633:ff.c          **** 
 2024              		.loc 1 633 2 is_stmt 1 view .LVU713
 633:ff.c          **** 
 2025              		.loc 1 633 10 is_stmt 0 view .LVU714
 2026 003e 6361     		str	r3, [r4, #20]
 635:ff.c          **** }
 2027              		.loc 1 635 2 is_stmt 1 view .LVU715
 635:ff.c          **** }
 2028              		.loc 1 635 9 is_stmt 0 view .LVU716
 2029 0040 E7E7     		b	.L164
 2030              	.L168:
 600:ff.c          **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 2031              		.loc 1 600 4 is_stmt 1 view .LVU717
 600:ff.c          **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 2032              		.loc 1 600 42 is_stmt 0 view .LVU718
 2033 0042 8778     		ldrb	r7, [r0, #2]	@ zero_extendqisi2
 600:ff.c          **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 2034              		.loc 1 600 50 view .LVU719
 2035 0044 013F     		subs	r7, r7, #1
 600:ff.c          **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 2036              		.loc 1 600 7 view .LVU720
 2037 0046 17EA1617 		ands	r7, r7, r6, lsr #4
 2038 004a F2D1     		bne	.L167
 601:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;
 2039              		.loc 1 601 5 is_stmt 1 view .LVU721
 601:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;
 2040              		.loc 1 601 12 is_stmt 0 view .LVU722
 2041 004c FFF7FEFF 		bl	get_fat
 2042              	.LVL227:
 602:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 2043              		.loc 1 602 8 view .LVU723
 2044 0050 0128     		cmp	r0, #1
 601:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;
 2045              		.loc 1 601 12 view .LVU724
 2046 0052 0546     		mov	r5, r0
 2047              	.LVL228:
 602:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 2048              		.loc 1 602 5 is_stmt 1 view .LVU725
 602:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 2049              		.loc 1 602 8 is_stmt 0 view .LVU726
 2050 0054 01D8     		bhi	.L170
 2051              	.L173:
 602:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 2052              		.loc 1 602 27 view .LVU727
 2053 0056 0220     		movs	r0, #2
 2054              	.LVL229:
 602:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 2055              		.loc 1 602 27 view .LVU728
 2056 0058 DBE7     		b	.L164
 2057              	.LVL230:
 2058              	.L170:
 603:ff.c          **** 				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
 2059              		.loc 1 603 5 is_stmt 1 view .LVU729
 603:ff.c          **** 				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
 2060              		.loc 1 603 8 is_stmt 0 view .LVU730
 2061 005a 421C     		adds	r2, r0, #1
 2062 005c 01D1     		bne	.L171
 2063              	.LVL231:
 2064              	.L174:
 603:ff.c          **** 				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
 2065              		.loc 1 603 36 view .LVU731
 2066 005e 0120     		movs	r0, #1
 2067 0060 D7E7     		b	.L164
 2068              	.LVL232:
 2069              	.L171:
 604:ff.c          **** #if !_FS_READONLY
 2070              		.loc 1 604 5 is_stmt 1 view .LVU732
 604:ff.c          **** #if !_FS_READONLY
 2071              		.loc 1 604 19 is_stmt 0 view .LVU733
 2072 0062 2068     		ldr	r0, [r4]
 2073              	.LVL233:
 604:ff.c          **** #if !_FS_READONLY
 2074              		.loc 1 604 8 view .LVU734
 2075 0064 036A     		ldr	r3, [r0, #32]
 2076 0066 AB42     		cmp	r3, r5
 2077 0068 29D8     		bhi	.L172
 2078              	.LBB35:
 606:ff.c          **** 					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
 2079              		.loc 1 606 6 is_stmt 1 view .LVU735
 607:ff.c          **** 					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
 2080              		.loc 1 607 6 view .LVU736
 607:ff.c          **** 					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
 2081              		.loc 1 607 9 is_stmt 0 view .LVU737
 2082 006a B9F1000F 		cmp	r9, #0
 2083 006e CFD0     		beq	.L165
 608:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 2084              		.loc 1 608 6 is_stmt 1 view .LVU738
 608:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 2085              		.loc 1 608 13 is_stmt 0 view .LVU739
 2086 0070 E168     		ldr	r1, [r4, #12]
 2087 0072 FFF7FEFF 		bl	create_chain
 2088              	.LVL234:
 609:ff.c          **** 					if (clst == 1) return FR_INT_ERR;
 2089              		.loc 1 609 6 is_stmt 1 view .LVU740
 609:ff.c          **** 					if (clst == 1) return FR_INT_ERR;
 2090              		.loc 1 609 9 is_stmt 0 view .LVU741
 2091 0076 0546     		mov	r5, r0
 2092 0078 0028     		cmp	r0, #0
 2093 007a 37D0     		beq	.L179
 610:ff.c          **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 2094              		.loc 1 610 6 is_stmt 1 view .LVU742
 610:ff.c          **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 2095              		.loc 1 610 9 is_stmt 0 view .LVU743
 2096 007c 0128     		cmp	r0, #1
 2097 007e EAD0     		beq	.L173
 611:ff.c          **** 					/* Clean-up streached table */
 2098              		.loc 1 611 6 is_stmt 1 view .LVU744
 611:ff.c          **** 					/* Clean-up streached table */
 2099              		.loc 1 611 9 is_stmt 0 view .LVU745
 2100 0080 431C     		adds	r3, r0, #1
 2101 0082 ECD0     		beq	.L174
 613:ff.c          **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 2102              		.loc 1 613 6 is_stmt 1 view .LVU746
 613:ff.c          **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 2103              		.loc 1 613 10 is_stmt 0 view .LVU747
 2104 0084 0021     		movs	r1, #0
 2105 0086 2068     		ldr	r0, [r4]
 2106              	.LVL235:
 613:ff.c          **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 2107              		.loc 1 613 10 view .LVU748
 2108 0088 FFF7FEFF 		bl	move_window
 2109              	.LVL236:
 613:ff.c          **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 2110              		.loc 1 613 9 view .LVU749
 2111 008c 0028     		cmp	r0, #0
 2112 008e E6D1     		bne	.L174
 614:ff.c          **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 2113              		.loc 1 614 6 is_stmt 1 view .LVU750
 614:ff.c          **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 2114              		.loc 1 614 16 is_stmt 0 view .LVU751
 2115 0090 2368     		ldr	r3, [r4]
 614:ff.c          **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 2116              		.loc 1 614 20 view .LVU752
 2117 0092 03F13402 		add	r2, r3, #52
 2118              	.LVL237:
 2119              	.LBB36:
 2120              	.LBI36:
 170:ff.c          **** 	char *d = (char*)dst;
 2121              		.loc 1 170 6 is_stmt 1 view .LVU753
 2122              	.LBB37:
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 2123              		.loc 1 171 2 view .LVU754
 172:ff.c          **** }
 2124              		.loc 1 172 2 view .LVU755
 2125 0096 03F50D73 		add	r3, r3, #564
 2126              	.LVL238:
 2127              	.L175:
 172:ff.c          **** }
 2128              		.loc 1 172 8 view .LVU756
 172:ff.c          **** }
 2129              		.loc 1 172 8 is_stmt 0 view .LVU757
 2130 009a 9342     		cmp	r3, r2
 2131 009c 16D1     		bne	.L176
 2132              	.LVL239:
 172:ff.c          **** }
 2133              		.loc 1 172 8 view .LVU758
 2134              	.LBE37:
 2135              	.LBE36:
 615:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 2136              		.loc 1 615 6 is_stmt 1 view .LVU759
 615:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 2137              		.loc 1 615 24 is_stmt 0 view .LVU760
 2138 009e 2268     		ldr	r2, [r4]
 2139 00a0 2946     		mov	r1, r5
 2140 00a2 1046     		mov	r0, r2
 2141 00a4 FFF7FEFF 		bl	clust2sect
 2142              	.LVL240:
 617:ff.c          **** 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 2143              		.loc 1 617 21 view .LVU761
 2144 00a8 4FF00109 		mov	r9, #1
 615:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 2145              		.loc 1 615 22 view .LVU762
 2146 00ac 1063     		str	r0, [r2, #48]
 616:ff.c          **** 						dj->fs->wflag = 1;
 2147              		.loc 1 616 6 is_stmt 1 view .LVU763
 2148              	.LVL241:
 2149              	.L177:
 616:ff.c          **** 						dj->fs->wflag = 1;
 2150              		.loc 1 616 18 discriminator 1 view .LVU764
 616:ff.c          **** 						dj->fs->wflag = 1;
 2151              		.loc 1 616 24 is_stmt 0 discriminator 1 view .LVU765
 2152 00ae 2068     		ldr	r0, [r4]
 616:ff.c          **** 						dj->fs->wflag = 1;
 2153              		.loc 1 616 6 discriminator 1 view .LVU766
 2154 00b0 FAB2     		uxtb	r2, r7
 2155 00b2 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 2156 00b4 9342     		cmp	r3, r2
 2157 00b6 0CD8     		bhi	.L178
 621:ff.c          **** #else
 2158              		.loc 1 621 6 is_stmt 1 view .LVU767
 621:ff.c          **** #else
 2159              		.loc 1 621 22 is_stmt 0 view .LVU768
 2160 00b8 036B     		ldr	r3, [r0, #48]
 2161 00ba 9B1A     		subs	r3, r3, r2
 2162 00bc 0363     		str	r3, [r0, #48]
 2163              	.LVL242:
 2164              	.L172:
 621:ff.c          **** #else
 2165              		.loc 1 621 22 view .LVU769
 2166              	.LBE35:
 626:ff.c          **** 				dj->sect = clust2sect(dj->fs, clst);
 2167              		.loc 1 626 5 is_stmt 1 view .LVU770
 627:ff.c          **** 			}
 2168              		.loc 1 627 16 is_stmt 0 view .LVU771
 2169 00be 2946     		mov	r1, r5
 2170 00c0 2068     		ldr	r0, [r4]
 626:ff.c          **** 				dj->sect = clust2sect(dj->fs, clst);
 2171              		.loc 1 626 15 view .LVU772
 2172 00c2 E560     		str	r5, [r4, #12]
 627:ff.c          **** 			}
 2173              		.loc 1 627 5 is_stmt 1 view .LVU773
 627:ff.c          **** 			}
 2174              		.loc 1 627 16 is_stmt 0 view .LVU774
 2175 00c4 FFF7FEFF 		bl	clust2sect
 2176              	.LVL243:
 627:ff.c          **** 			}
 2177              		.loc 1 627 14 view .LVU775
 2178 00c8 2061     		str	r0, [r4, #16]
 2179 00ca B2E7     		b	.L167
 2180              	.LVL244:
 2181              	.L176:
 2182              	.LBB40:
 2183              	.LBB39:
 2184              	.LBB38:
 172:ff.c          **** }
 2185              		.loc 1 172 16 is_stmt 1 view .LVU776
 172:ff.c          **** }
 2186              		.loc 1 172 21 is_stmt 0 view .LVU777
 2187 00cc 02F8010B 		strb	r0, [r2], #1
 2188              	.LVL245:
 172:ff.c          **** }
 2189              		.loc 1 172 21 view .LVU778
 2190 00d0 E3E7     		b	.L175
 2191              	.LVL246:
 2192              	.L178:
 172:ff.c          **** }
 2193              		.loc 1 172 21 view .LVU779
 2194              	.LBE38:
 2195              	.LBE39:
 617:ff.c          **** 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 2196              		.loc 1 617 7 is_stmt 1 view .LVU780
 618:ff.c          **** 						dj->fs->winsect++;
 2197              		.loc 1 618 11 is_stmt 0 view .LVU781
 2198 00d2 0021     		movs	r1, #0
 617:ff.c          **** 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 2199              		.loc 1 617 21 view .LVU782
 2200 00d4 80F80490 		strb	r9, [r0, #4]
 618:ff.c          **** 						dj->fs->winsect++;
 2201              		.loc 1 618 7 is_stmt 1 view .LVU783
 618:ff.c          **** 						dj->fs->winsect++;
 2202              		.loc 1 618 11 is_stmt 0 view .LVU784
 2203 00d8 FFF7FEFF 		bl	move_window
 2204              	.LVL247:
 2205 00dc 0137     		adds	r7, r7, #1
 2206              	.LVL248:
 618:ff.c          **** 						dj->fs->winsect++;
 2207              		.loc 1 618 10 view .LVU785
 2208 00de 0028     		cmp	r0, #0
 2209 00e0 BDD1     		bne	.L174
 619:ff.c          **** 					}
 2210              		.loc 1 619 7 is_stmt 1 discriminator 2 view .LVU786
 619:ff.c          **** 					}
 2211              		.loc 1 619 9 is_stmt 0 discriminator 2 view .LVU787
 2212 00e2 2268     		ldr	r2, [r4]
 619:ff.c          **** 					}
 2213              		.loc 1 619 22 discriminator 2 view .LVU788
 2214 00e4 136B     		ldr	r3, [r2, #48]
 2215 00e6 0133     		adds	r3, r3, #1
 2216 00e8 1363     		str	r3, [r2, #48]
 616:ff.c          **** 						dj->fs->wflag = 1;
 2217              		.loc 1 616 37 is_stmt 1 discriminator 2 view .LVU789
 2218              	.LVL249:
 616:ff.c          **** 						dj->fs->wflag = 1;
 2219              		.loc 1 616 37 is_stmt 0 discriminator 2 view .LVU790
 2220 00ea E0E7     		b	.L177
 2221              	.LVL250:
 2222              	.L179:
 609:ff.c          **** 					if (clst == 1) return FR_INT_ERR;
 2223              		.loc 1 609 28 view .LVU791
 2224 00ec 0720     		movs	r0, #7
 2225              	.LVL251:
 609:ff.c          **** 					if (clst == 1) return FR_INT_ERR;
 2226              		.loc 1 609 28 view .LVU792
 2227 00ee 90E7     		b	.L164
 2228              	.LBE40:
 2229              		.cfi_endproc
 2230              	.LFE41:
 2232              		.section	.text.dir_read,"ax",%progbits
 2233              		.align	1
 2234              		.syntax unified
 2235              		.thumb
 2236              		.thumb_func
 2237              		.fpu softvfp
 2239              	dir_read:
 2240              	.LVL252:
 2241              	.LFB43:
 874:ff.c          **** 	FRESULT res;
 2242              		.loc 1 874 1 is_stmt 1 view -0
 2243              		.cfi_startproc
 2244              		@ args = 0, pretend = 0, frame = 0
 2245              		@ frame_needed = 0, uses_anonymous_args = 0
 875:ff.c          **** 	BYTE c, *dir;
 2246              		.loc 1 875 2 view .LVU794
 876:ff.c          **** #if _USE_LFN
 2247              		.loc 1 876 2 view .LVU795
 881:ff.c          **** 	while (dj->sect) {
 2248              		.loc 1 881 2 view .LVU796
 882:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2249              		.loc 1 882 2 view .LVU797
 874:ff.c          **** 	FRESULT res;
 2250              		.loc 1 874 1 is_stmt 0 view .LVU798
 2251 0000 10B5     		push	{r4, lr}
 2252              		.cfi_def_cfa_offset 8
 2253              		.cfi_offset 4, -8
 2254              		.cfi_offset 14, -4
 874:ff.c          **** 	FRESULT res;
 2255              		.loc 1 874 1 view .LVU799
 2256 0002 0446     		mov	r4, r0
 881:ff.c          **** 	while (dj->sect) {
 2257              		.loc 1 881 6 view .LVU800
 2258 0004 0420     		movs	r0, #4
 2259              	.LVL253:
 2260              	.L193:
 882:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2261              		.loc 1 882 8 is_stmt 1 view .LVU801
 882:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2262              		.loc 1 882 11 is_stmt 0 view .LVU802
 2263 0006 2169     		ldr	r1, [r4, #16]
 882:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2264              		.loc 1 882 8 view .LVU803
 2265 0008 09B9     		cbnz	r1, .L197
 2266              	.LVL254:
 915:ff.c          **** 
 2267              		.loc 1 915 2 is_stmt 1 view .LVU804
 915:ff.c          **** 
 2268              		.loc 1 915 5 is_stmt 0 view .LVU805
 2269 000a 60B1     		cbz	r0, .L198
 2270 000c 13E0     		b	.L194
 2271              	.LVL255:
 2272              	.L197:
 883:ff.c          **** 		if (res != FR_OK) break;
 2273              		.loc 1 883 3 is_stmt 1 view .LVU806
 883:ff.c          **** 		if (res != FR_OK) break;
 2274              		.loc 1 883 9 is_stmt 0 view .LVU807
 2275 000e 2068     		ldr	r0, [r4]
 2276 0010 FFF7FEFF 		bl	move_window
 2277              	.LVL256:
 884:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 2278              		.loc 1 884 3 is_stmt 1 view .LVU808
 884:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 2279              		.loc 1 884 6 is_stmt 0 view .LVU809
 2280 0014 78B9     		cbnz	r0, .L194
 885:ff.c          **** 		c = dir[DIR_Name];
 2281              		.loc 1 885 3 is_stmt 1 view .LVU810
 885:ff.c          **** 		c = dir[DIR_Name];
 2282              		.loc 1 885 7 is_stmt 0 view .LVU811
 2283 0016 6369     		ldr	r3, [r4, #20]
 2284              	.LVL257:
 886:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2285              		.loc 1 886 3 is_stmt 1 view .LVU812
 886:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2286              		.loc 1 886 5 is_stmt 0 view .LVU813
 2287 0018 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2288              	.LVL258:
 887:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2289              		.loc 1 887 3 is_stmt 1 view .LVU814
 887:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2290              		.loc 1 887 6 is_stmt 0 view .LVU815
 2291 001a 7AB1     		cbz	r2, .L199
 908:ff.c          **** 			break;
 2292              		.loc 1 908 3 is_stmt 1 view .LVU816
 908:ff.c          **** 			break;
 2293              		.loc 1 908 6 is_stmt 0 view .LVU817
 2294 001c E52A     		cmp	r2, #229
 2295 001e 04D0     		beq	.L195
 908:ff.c          **** 			break;
 2296              		.loc 1 908 44 discriminator 1 view .LVU818
 2297 0020 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 2298              	.LVL259:
 908:ff.c          **** 			break;
 2299              		.loc 1 908 44 discriminator 1 view .LVU819
 2300 0022 1B07     		lsls	r3, r3, #28
 2301 0024 01D4     		bmi	.L195
 2302              	.LVL260:
 2303              	.L198:
 883:ff.c          **** 		if (res != FR_OK) break;
 2304              		.loc 1 883 9 view .LVU820
 2305 0026 0020     		movs	r0, #0
 2306              	.LVL261:
 2307              	.L196:
 917:ff.c          **** }
 2308              		.loc 1 917 2 is_stmt 1 view .LVU821
 918:ff.c          **** #endif
 2309              		.loc 1 918 1 is_stmt 0 view .LVU822
 2310 0028 10BD     		pop	{r4, pc}
 2311              	.LVL262:
 2312              	.L195:
 911:ff.c          **** 		if (res != FR_OK) break;
 2313              		.loc 1 911 3 is_stmt 1 view .LVU823
 911:ff.c          **** 		if (res != FR_OK) break;
 2314              		.loc 1 911 9 is_stmt 0 view .LVU824
 2315 002a 0021     		movs	r1, #0
 2316 002c 2046     		mov	r0, r4
 2317              	.LVL263:
 911:ff.c          **** 		if (res != FR_OK) break;
 2318              		.loc 1 911 9 view .LVU825
 2319 002e FFF7FEFF 		bl	dir_next
 2320              	.LVL264:
 912:ff.c          **** 	}
 2321              		.loc 1 912 3 is_stmt 1 view .LVU826
 912:ff.c          **** 	}
 2322              		.loc 1 912 6 is_stmt 0 view .LVU827
 2323 0032 0028     		cmp	r0, #0
 2324 0034 E7D0     		beq	.L193
 2325              	.LVL265:
 2326              	.L194:
 915:ff.c          **** 
 2327              		.loc 1 915 20 is_stmt 1 discriminator 1 view .LVU828
 915:ff.c          **** 
 2328              		.loc 1 915 29 is_stmt 0 discriminator 1 view .LVU829
 2329 0036 0023     		movs	r3, #0
 2330 0038 2361     		str	r3, [r4, #16]
 2331 003a F5E7     		b	.L196
 2332              	.LVL266:
 2333              	.L199:
 887:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2334              		.loc 1 887 21 view .LVU830
 2335 003c 0420     		movs	r0, #4
 2336              	.LVL267:
 887:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2337              		.loc 1 887 21 view .LVU831
 2338 003e FAE7     		b	.L194
 2339              		.cfi_endproc
 2340              	.LFE43:
 2342              		.section	.text.remove_chain,"ax",%progbits
 2343              		.align	1
 2344              		.syntax unified
 2345              		.thumb
 2346              		.thumb_func
 2347              		.fpu softvfp
 2349              	remove_chain:
 2350              	.LVL268:
 2351              	.LFB37:
 417:ff.c          **** 	FRESULT res;
 2352              		.loc 1 417 1 is_stmt 1 view -0
 2353              		.cfi_startproc
 2354              		@ args = 0, pretend = 0, frame = 0
 2355              		@ frame_needed = 0, uses_anonymous_args = 0
 418:ff.c          **** 	DWORD nxt;
 2356              		.loc 1 418 2 view .LVU833
 419:ff.c          **** 
 2357              		.loc 1 419 2 view .LVU834
 422:ff.c          **** 		res = FR_INT_ERR;
 2358              		.loc 1 422 2 view .LVU835
 422:ff.c          **** 		res = FR_INT_ERR;
 2359              		.loc 1 422 5 is_stmt 0 view .LVU836
 2360 0000 0129     		cmp	r1, #1
 417:ff.c          **** 	FRESULT res;
 2361              		.loc 1 417 1 view .LVU837
 2362 0002 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2363              		.cfi_def_cfa_offset 24
 2364              		.cfi_offset 3, -24
 2365              		.cfi_offset 4, -20
 2366              		.cfi_offset 5, -16
 2367              		.cfi_offset 6, -12
 2368              		.cfi_offset 7, -8
 2369              		.cfi_offset 14, -4
 417:ff.c          **** 	FRESULT res;
 2370              		.loc 1 417 1 view .LVU838
 2371 0004 0546     		mov	r5, r0
 2372 0006 0C46     		mov	r4, r1
 422:ff.c          **** 		res = FR_INT_ERR;
 2373              		.loc 1 422 5 view .LVU839
 2374 0008 22D9     		bls	.L207
 422:ff.c          **** 		res = FR_INT_ERR;
 2375              		.loc 1 422 15 discriminator 1 view .LVU840
 2376 000a 036A     		ldr	r3, [r0, #32]
 2377 000c 8B42     		cmp	r3, r1
 2378 000e 1FD9     		bls	.L207
 2379              	.LBB43:
 2380              	.LBB44:
 436:ff.c          **** 			}
 2381              		.loc 1 436 18 view .LVU841
 2382 0010 0127     		movs	r7, #1
 2383              	.LVL269:
 2384              	.L211:
 428:ff.c          **** 			if (nxt == 0) break;				/* Empty cluster? */
 2385              		.loc 1 428 4 is_stmt 1 view .LVU842
 428:ff.c          **** 			if (nxt == 0) break;				/* Empty cluster? */
 2386              		.loc 1 428 10 is_stmt 0 view .LVU843
 2387 0012 2146     		mov	r1, r4
 2388 0014 2846     		mov	r0, r5
 2389 0016 FFF7FEFF 		bl	get_fat
 2390              	.LVL270:
 429:ff.c          **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 2391              		.loc 1 429 4 is_stmt 1 view .LVU844
 2392 001a 2646     		mov	r6, r4
 429:ff.c          **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 2393              		.loc 1 429 7 is_stmt 0 view .LVU845
 2394 001c 0446     		mov	r4, r0
 2395              	.LVL271:
 429:ff.c          **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 2396              		.loc 1 429 7 view .LVU846
 2397 001e 08B9     		cbnz	r0, .L208
 2398              	.LVL272:
 2399              	.L212:
 429:ff.c          **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 2400              		.loc 1 429 7 view .LVU847
 2401              	.LBE44:
 2402              	.LBE43:
 423:ff.c          **** 
 2403              		.loc 1 423 7 view .LVU848
 2404 0020 0020     		movs	r0, #0
 2405              	.LVL273:
 2406              	.L209:
 442:ff.c          **** }
 2407              		.loc 1 442 2 is_stmt 1 view .LVU849
 443:ff.c          **** #endif
 2408              		.loc 1 443 1 is_stmt 0 view .LVU850
 2409 0022 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2410              	.LVL274:
 2411              	.L208:
 2412              	.LBB47:
 2413              	.LBB45:
 430:ff.c          **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 2414              		.loc 1 430 4 is_stmt 1 view .LVU851
 430:ff.c          **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 2415              		.loc 1 430 7 is_stmt 0 view .LVU852
 2416 0024 0128     		cmp	r0, #1
 2417 0026 13D0     		beq	.L207
 431:ff.c          **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 2418              		.loc 1 431 4 is_stmt 1 view .LVU853
 431:ff.c          **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 2419              		.loc 1 431 7 is_stmt 0 view .LVU854
 2420 0028 411C     		adds	r1, r0, #1
 2421 002a 13D0     		beq	.L213
 432:ff.c          **** 			if (res != FR_OK) break;
 2422              		.loc 1 432 4 is_stmt 1 view .LVU855
 432:ff.c          **** 			if (res != FR_OK) break;
 2423              		.loc 1 432 10 is_stmt 0 view .LVU856
 2424 002c 0022     		movs	r2, #0
 2425 002e 3146     		mov	r1, r6
 2426 0030 2846     		mov	r0, r5
 2427              	.LVL275:
 432:ff.c          **** 			if (res != FR_OK) break;
 2428              		.loc 1 432 10 view .LVU857
 2429 0032 FFF7FEFF 		bl	put_fat
 2430              	.LVL276:
 433:ff.c          **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 2431              		.loc 1 433 4 is_stmt 1 view .LVU858
 433:ff.c          **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 2432              		.loc 1 433 7 is_stmt 0 view .LVU859
 2433 0036 0028     		cmp	r0, #0
 2434 0038 F3D1     		bne	.L209
 434:ff.c          **** 				fs->free_clust++;
 2435              		.loc 1 434 4 is_stmt 1 view .LVU860
 434:ff.c          **** 				fs->free_clust++;
 2436              		.loc 1 434 10 is_stmt 0 view .LVU861
 2437 003a 2B69     		ldr	r3, [r5, #16]
 434:ff.c          **** 				fs->free_clust++;
 2438              		.loc 1 434 7 view .LVU862
 2439 003c 5A1C     		adds	r2, r3, #1
 435:ff.c          **** 				fs->fsi_flag = 1;
 2440              		.loc 1 435 5 is_stmt 1 view .LVU863
 435:ff.c          **** 				fs->fsi_flag = 1;
 2441              		.loc 1 435 19 is_stmt 0 view .LVU864
 2442 003e 1CBF     		itt	ne
 2443 0040 0133     		addne	r3, r3, #1
 2444 0042 2B61     		strne	r3, [r5, #16]
 436:ff.c          **** 			}
 2445              		.loc 1 436 5 is_stmt 1 view .LVU865
 427:ff.c          **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 2446              		.loc 1 427 9 is_stmt 0 view .LVU866
 2447 0044 2B6A     		ldr	r3, [r5, #32]
 436:ff.c          **** 			}
 2448              		.loc 1 436 18 view .LVU867
 2449 0046 18BF     		it	ne
 2450 0048 AF72     		strbne	r7, [r5, #10]
 2451              	.LVL277:
 427:ff.c          **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 2452              		.loc 1 427 9 is_stmt 1 view .LVU868
 2453 004a 9C42     		cmp	r4, r3
 2454 004c E1D3     		bcc	.L211
 2455 004e E7E7     		b	.L212
 2456              	.LVL278:
 2457              	.L207:
 427:ff.c          **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 2458              		.loc 1 427 9 is_stmt 0 view .LVU869
 2459              	.LBE45:
 2460              	.LBE47:
 423:ff.c          **** 
 2461              		.loc 1 423 7 view .LVU870
 2462 0050 0220     		movs	r0, #2
 2463 0052 E6E7     		b	.L209
 2464              	.LVL279:
 2465              	.L213:
 2466              	.LBB48:
 2467              	.LBB46:
 431:ff.c          **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 2468              		.loc 1 431 33 view .LVU871
 2469 0054 0120     		movs	r0, #1
 2470              	.LVL280:
 431:ff.c          **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 2471              		.loc 1 431 33 view .LVU872
 2472 0056 E4E7     		b	.L209
 2473              	.LBE46:
 2474              	.LBE48:
 2475              		.cfi_endproc
 2476              	.LFE37:
 2478              		.section	.text.dir_remove,"ax",%progbits
 2479              		.align	1
 2480              		.syntax unified
 2481              		.thumb
 2482              		.thumb_func
 2483              		.fpu softvfp
 2485              	dir_remove:
 2486              	.LVL281:
 2487              	.LFB45:
1035:ff.c          **** 	FRESULT res;
 2488              		.loc 1 1035 1 is_stmt 1 view -0
 2489              		.cfi_startproc
 2490              		@ args = 0, pretend = 0, frame = 0
 2491              		@ frame_needed = 0, uses_anonymous_args = 0
1036:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2492              		.loc 1 1036 2 view .LVU874
1055:ff.c          **** 	if (res == FR_OK) {
 2493              		.loc 1 1055 2 view .LVU875
1035:ff.c          **** 	FRESULT res;
 2494              		.loc 1 1035 1 is_stmt 0 view .LVU876
 2495 0000 10B5     		push	{r4, lr}
 2496              		.cfi_def_cfa_offset 8
 2497              		.cfi_offset 4, -8
 2498              		.cfi_offset 14, -4
1055:ff.c          **** 	if (res == FR_OK) {
 2499              		.loc 1 1055 8 view .LVU877
 2500 0002 C188     		ldrh	r1, [r0, #6]
1035:ff.c          **** 	FRESULT res;
 2501              		.loc 1 1035 1 view .LVU878
 2502 0004 0446     		mov	r4, r0
1055:ff.c          **** 	if (res == FR_OK) {
 2503              		.loc 1 1055 8 view .LVU879
 2504 0006 FFF7FEFF 		bl	dir_seek
 2505              	.LVL282:
1056:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2506              		.loc 1 1056 2 is_stmt 1 view .LVU880
1056:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2507              		.loc 1 1056 5 is_stmt 0 view .LVU881
 2508 000a 50B9     		cbnz	r0, .L222
1057:ff.c          **** 		if (res == FR_OK) {
 2509              		.loc 1 1057 3 is_stmt 1 view .LVU882
1057:ff.c          **** 		if (res == FR_OK) {
 2510              		.loc 1 1057 9 is_stmt 0 view .LVU883
 2511 000c 2169     		ldr	r1, [r4, #16]
 2512 000e 2068     		ldr	r0, [r4]
 2513              	.LVL283:
1057:ff.c          **** 		if (res == FR_OK) {
 2514              		.loc 1 1057 9 view .LVU884
 2515 0010 FFF7FEFF 		bl	move_window
 2516              	.LVL284:
1058:ff.c          **** 			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
 2517              		.loc 1 1058 3 is_stmt 1 view .LVU885
1058:ff.c          **** 			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
 2518              		.loc 1 1058 6 is_stmt 0 view .LVU886
 2519 0014 28B9     		cbnz	r0, .L222
 2520              	.LVL285:
 2521              	.LBB51:
 2522              	.LBI51:
1032:ff.c          **** 	DIR *dj				/* Directory object pointing the entry to be removed */
 2523              		.loc 1 1032 9 is_stmt 1 view .LVU887
 2524              	.LBB52:
1059:ff.c          **** 			dj->fs->wflag = 1;
 2525              		.loc 1 1059 4 view .LVU888
1059:ff.c          **** 			dj->fs->wflag = 1;
 2526              		.loc 1 1059 13 is_stmt 0 view .LVU889
 2527 0016 E522     		movs	r2, #229
1059:ff.c          **** 			dj->fs->wflag = 1;
 2528              		.loc 1 1059 7 view .LVU890
 2529 0018 6369     		ldr	r3, [r4, #20]
1059:ff.c          **** 			dj->fs->wflag = 1;
 2530              		.loc 1 1059 13 view .LVU891
 2531 001a 1A70     		strb	r2, [r3]
1060:ff.c          **** 		}
 2532              		.loc 1 1060 4 is_stmt 1 view .LVU892
1060:ff.c          **** 		}
 2533              		.loc 1 1060 18 is_stmt 0 view .LVU893
 2534 001c 0122     		movs	r2, #1
 2535 001e 2368     		ldr	r3, [r4]
 2536 0020 1A71     		strb	r2, [r3, #4]
 2537              	.LVL286:
1065:ff.c          **** }
 2538              		.loc 1 1065 2 is_stmt 1 view .LVU894
 2539              	.L222:
1065:ff.c          **** }
 2540              		.loc 1 1065 2 is_stmt 0 view .LVU895
 2541              	.LBE52:
 2542              	.LBE51:
1065:ff.c          **** }
 2543              		.loc 1 1065 2 is_stmt 1 view .LVU896
1066:ff.c          **** #endif /* !_FS_READONLY */
 2544              		.loc 1 1066 1 is_stmt 0 view .LVU897
 2545 0022 10BD     		pop	{r4, pc}
1066:ff.c          **** #endif /* !_FS_READONLY */
 2546              		.loc 1 1066 1 view .LVU898
 2547              		.cfi_endproc
 2548              	.LFE45:
 2550              		.section	.text.dir_register,"ax",%progbits
 2551              		.align	1
 2552              		.syntax unified
 2553              		.thumb
 2554              		.thumb_func
 2555              		.fpu softvfp
 2557              	dir_register:
 2558              	.LVL287:
 2559              	.LFB44:
 931:ff.c          **** 	FRESULT res;
 2560              		.loc 1 931 1 is_stmt 1 view -0
 2561              		.cfi_startproc
 2562              		@ args = 0, pretend = 0, frame = 0
 2563              		@ frame_needed = 0, uses_anonymous_args = 0
 932:ff.c          **** 	BYTE c, *dir;
 2564              		.loc 1 932 2 view .LVU900
 933:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2565              		.loc 1 933 2 view .LVU901
 997:ff.c          **** 	if (res == FR_OK) {
 2566              		.loc 1 997 2 view .LVU902
 931:ff.c          **** 	FRESULT res;
 2567              		.loc 1 931 1 is_stmt 0 view .LVU903
 2568 0000 70B5     		push	{r4, r5, r6, lr}
 2569              		.cfi_def_cfa_offset 16
 2570              		.cfi_offset 4, -16
 2571              		.cfi_offset 5, -12
 2572              		.cfi_offset 6, -8
 2573              		.cfi_offset 14, -4
 997:ff.c          **** 	if (res == FR_OK) {
 2574              		.loc 1 997 8 view .LVU904
 2575 0002 0021     		movs	r1, #0
 931:ff.c          **** 	FRESULT res;
 2576              		.loc 1 931 1 view .LVU905
 2577 0004 0646     		mov	r6, r0
 997:ff.c          **** 	if (res == FR_OK) {
 2578              		.loc 1 997 8 view .LVU906
 2579 0006 FFF7FEFF 		bl	dir_seek
 2580              	.LVL288:
 2581              	.L239:
 998:ff.c          **** 		do {	/* Find a blank entry for the SFN */
 2582              		.loc 1 998 2 is_stmt 1 view .LVU907
 998:ff.c          **** 		do {	/* Find a blank entry for the SFN */
 2583              		.loc 1 998 5 is_stmt 0 view .LVU908
 2584 000a 0446     		mov	r4, r0
 2585 000c 60BB     		cbnz	r0, .L230
 999:ff.c          **** 			res = move_window(dj->fs, dj->sect);
 2586              		.loc 1 999 3 is_stmt 1 view .LVU909
1000:ff.c          **** 			if (res != FR_OK) break;
 2587              		.loc 1 1000 4 view .LVU910
1000:ff.c          **** 			if (res != FR_OK) break;
 2588              		.loc 1 1000 10 is_stmt 0 view .LVU911
 2589 000e 3169     		ldr	r1, [r6, #16]
 2590 0010 3068     		ldr	r0, [r6]
 2591              	.LVL289:
1000:ff.c          **** 			if (res != FR_OK) break;
 2592              		.loc 1 1000 10 view .LVU912
 2593 0012 FFF7FEFF 		bl	move_window
 2594              	.LVL290:
1001:ff.c          **** 			c = *dj->dir;
 2595              		.loc 1 1001 4 is_stmt 1 view .LVU913
1001:ff.c          **** 			c = *dj->dir;
 2596              		.loc 1 1001 7 is_stmt 0 view .LVU914
 2597 0016 0446     		mov	r4, r0
 2598 0018 30BB     		cbnz	r0, .L230
1002:ff.c          **** 			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
 2599              		.loc 1 1002 4 is_stmt 1 view .LVU915
1002:ff.c          **** 			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
 2600              		.loc 1 1002 6 is_stmt 0 view .LVU916
 2601 001a 7369     		ldr	r3, [r6, #20]
 2602 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2603              	.LVL291:
1003:ff.c          **** 			res = dir_next(dj, TRUE);		/* Next entry with table streach */
 2604              		.loc 1 1003 4 is_stmt 1 view .LVU917
1003:ff.c          **** 			res = dir_next(dj, TRUE);		/* Next entry with table streach */
 2605              		.loc 1 1003 7 is_stmt 0 view .LVU918
 2606 001e E52B     		cmp	r3, #229
 2607 0020 08D0     		beq	.L225
1003:ff.c          **** 			res = dir_next(dj, TRUE);		/* Next entry with table streach */
 2608              		.loc 1 1003 18 discriminator 1 view .LVU919
 2609 0022 3BB1     		cbz	r3, .L225
1004:ff.c          **** 		} while (res == FR_OK);
 2610              		.loc 1 1004 4 is_stmt 1 view .LVU920
1004:ff.c          **** 		} while (res == FR_OK);
 2611              		.loc 1 1004 10 is_stmt 0 view .LVU921
 2612 0024 0121     		movs	r1, #1
 2613 0026 3046     		mov	r0, r6
 2614              	.LVL292:
1004:ff.c          **** 		} while (res == FR_OK);
 2615              		.loc 1 1004 10 view .LVU922
 2616 0028 FFF7FEFF 		bl	dir_next
 2617              	.LVL293:
1004:ff.c          **** 		} while (res == FR_OK);
 2618              		.loc 1 1004 10 view .LVU923
 2619 002c EDE7     		b	.L239
 2620              	.LVL294:
 2621              	.L228:
 2622              	.LBB57:
 2623              	.LBB58:
 2624              	.LBB59:
 2625              	.LBB60:
 172:ff.c          **** }
 2626              		.loc 1 172 16 is_stmt 1 view .LVU924
 172:ff.c          **** }
 2627              		.loc 1 172 21 is_stmt 0 view .LVU925
 2628 002e 03F8011B 		strb	r1, [r3], #1
 2629              	.LVL295:
 172:ff.c          **** }
 2630              		.loc 1 172 21 view .LVU926
 2631 0032 0AE0     		b	.L227
 2632              	.LVL296:
 2633              	.L225:
 172:ff.c          **** }
 2634              		.loc 1 172 21 view .LVU927
 2635              	.LBE60:
 2636              	.LBE59:
 2637              	.LBE58:
 2638              	.LBE57:
1009:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2639              		.loc 1 1009 2 is_stmt 1 view .LVU928
 2640              	.LBB64:
 2641              	.LBI57:
 928:ff.c          **** 	DIR *dj				/* Target directory with object name to be created */
 2642              		.loc 1 928 9 view .LVU929
 2643              	.LBB63:
1010:ff.c          **** 		if (res == FR_OK) {
 2644              		.loc 1 1010 3 view .LVU930
1010:ff.c          **** 		if (res == FR_OK) {
 2645              		.loc 1 1010 9 is_stmt 0 view .LVU931
 2646 0034 3169     		ldr	r1, [r6, #16]
 2647 0036 3068     		ldr	r0, [r6]
 2648 0038 FFF7FEFF 		bl	move_window
 2649              	.LVL297:
1011:ff.c          **** 			dir = dj->dir;
 2650              		.loc 1 1011 3 is_stmt 1 view .LVU932
1011:ff.c          **** 			dir = dj->dir;
 2651              		.loc 1 1011 6 is_stmt 0 view .LVU933
 2652 003c 0446     		mov	r4, r0
 2653 003e 98B9     		cbnz	r0, .L230
1012:ff.c          **** 			mem_set(dir, 0, 32);		/* Clean the entry */
 2654              		.loc 1 1012 4 is_stmt 1 view .LVU934
1012:ff.c          **** 			mem_set(dir, 0, 32);		/* Clean the entry */
 2655              		.loc 1 1012 8 is_stmt 0 view .LVU935
 2656 0040 7569     		ldr	r5, [r6, #20]
 2657              	.LVL298:
1013:ff.c          **** 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
 2658              		.loc 1 1013 4 is_stmt 1 view .LVU936
 2659              	.LBB62:
 2660              	.LBI59:
 170:ff.c          **** 	char *d = (char*)dst;
 2661              		.loc 1 170 6 view .LVU937
 2662              	.LBB61:
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 2663              		.loc 1 171 2 view .LVU938
 172:ff.c          **** }
 2664              		.loc 1 172 2 view .LVU939
 172:ff.c          **** }
 2665              		.loc 1 172 21 is_stmt 0 view .LVU940
 2666 0042 2146     		mov	r1, r4
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 2667              		.loc 1 171 8 view .LVU941
 2668 0044 2B46     		mov	r3, r5
 2669 0046 05F12002 		add	r2, r5, #32
 2670              	.LVL299:
 2671              	.L227:
 172:ff.c          **** }
 2672              		.loc 1 172 8 is_stmt 1 view .LVU942
 172:ff.c          **** }
 2673              		.loc 1 172 8 is_stmt 0 view .LVU943
 2674 004a 9A42     		cmp	r2, r3
 2675 004c EFD1     		bne	.L228
 2676              	.LVL300:
 172:ff.c          **** }
 2677              		.loc 1 172 8 view .LVU944
 2678              	.LBE61:
 2679              	.LBE62:
1014:ff.c          **** 			dir[DIR_NTres] = *(dj->fn+11) & 0x18;	/* Put NT flag */
 2680              		.loc 1 1014 4 is_stmt 1 view .LVU945
 2681 004e 0B22     		movs	r2, #11
 2682 0050 2846     		mov	r0, r5
 2683              	.LVL301:
1014:ff.c          **** 			dir[DIR_NTres] = *(dj->fn+11) & 0x18;	/* Put NT flag */
 2684              		.loc 1 1014 4 is_stmt 0 view .LVU946
 2685 0052 B169     		ldr	r1, [r6, #24]
 2686 0054 FFF7FEFF 		bl	mem_cpy
 2687              	.LVL302:
1015:ff.c          **** 			dj->fs->wflag = 1;
 2688              		.loc 1 1015 4 is_stmt 1 view .LVU947
1016:ff.c          **** 		}
 2689              		.loc 1 1016 18 is_stmt 0 view .LVU948
 2690 0058 0122     		movs	r2, #1
1015:ff.c          **** 			dj->fs->wflag = 1;
 2691              		.loc 1 1015 21 view .LVU949
 2692 005a B369     		ldr	r3, [r6, #24]
1015:ff.c          **** 			dj->fs->wflag = 1;
 2693              		.loc 1 1015 34 view .LVU950
 2694 005c DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 2695 005e 03F01803 		and	r3, r3, #24
1015:ff.c          **** 			dj->fs->wflag = 1;
 2696              		.loc 1 1015 19 view .LVU951
 2697 0062 2B73     		strb	r3, [r5, #12]
1016:ff.c          **** 		}
 2698              		.loc 1 1016 4 is_stmt 1 view .LVU952
1016:ff.c          **** 		}
 2699              		.loc 1 1016 18 is_stmt 0 view .LVU953
 2700 0064 3368     		ldr	r3, [r6]
 2701 0066 1A71     		strb	r2, [r3, #4]
 2702              	.LVL303:
 2703              	.L230:
1016:ff.c          **** 		}
 2704              		.loc 1 1016 18 view .LVU954
 2705              	.LBE63:
 2706              	.LBE64:
1021:ff.c          **** #endif /* !_FS_READONLY */
 2707              		.loc 1 1021 1 view .LVU955
 2708 0068 2046     		mov	r0, r4
 2709 006a 70BD     		pop	{r4, r5, r6, pc}
1021:ff.c          **** #endif /* !_FS_READONLY */
 2710              		.loc 1 1021 1 view .LVU956
 2711              		.cfi_endproc
 2712              	.LFE44:
 2714              		.section	.rodata.follow_path.str1.1,"aMS",%progbits,1
 2715              	.LC0:
 2716 0000 20222A2B 		.ascii	" \"*+,[=]|\177\000"
 2716      2C5B3D5D 
 2716      7C7F00
 2717              		.section	.text.follow_path,"ax",%progbits
 2718              		.align	1
 2719              		.syntax unified
 2720              		.thumb
 2721              		.thumb_func
 2722              		.fpu softvfp
 2724              	follow_path:
 2725              	.LVL304:
 2726              	.LFB48:
1366:ff.c          **** 	FRESULT res;
 2727              		.loc 1 1366 1 is_stmt 1 view -0
 2728              		.cfi_startproc
 2729              		@ args = 0, pretend = 0, frame = 0
 2730              		@ frame_needed = 0, uses_anonymous_args = 0
1367:ff.c          **** 	BYTE *dir, last;
 2731              		.loc 1 1367 2 view .LVU958
1368:ff.c          **** 
 2732              		.loc 1 1368 2 view .LVU959
1372:ff.c          **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 2733              		.loc 1 1372 2 view .LVU960
1366:ff.c          **** 	FRESULT res;
 2734              		.loc 1 1366 1 is_stmt 0 view .LVU961
 2735 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2736              		.cfi_def_cfa_offset 24
 2737              		.cfi_offset 4, -24
 2738              		.cfi_offset 5, -20
 2739              		.cfi_offset 6, -16
 2740              		.cfi_offset 7, -12
 2741              		.cfi_offset 8, -8
 2742              		.cfi_offset 14, -4
1372:ff.c          **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 2743              		.loc 1 1372 6 view .LVU962
 2744 0004 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
1366:ff.c          **** 	FRESULT res;
 2745              		.loc 1 1366 1 view .LVU963
 2746 0006 0646     		mov	r6, r0
1372:ff.c          **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 2747              		.loc 1 1372 5 view .LVU964
 2748 0008 2F2B     		cmp	r3, #47
1366:ff.c          **** 	FRESULT res;
 2749              		.loc 1 1366 1 view .LVU965
 2750 000a 0D46     		mov	r5, r1
1372:ff.c          **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 2751              		.loc 1 1372 5 view .LVU966
 2752 000c 01D0     		beq	.L241
1372:ff.c          **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 2753              		.loc 1 1372 19 discriminator 1 view .LVU967
 2754 000e 5C2B     		cmp	r3, #92
 2755 0010 42D1     		bne	.L242
 2756              	.L241:
1373:ff.c          **** 	} else {							/* No heading saparator */
 2757              		.loc 1 1373 3 is_stmt 1 view .LVU968
1373:ff.c          **** 	} else {							/* No heading saparator */
 2758              		.loc 1 1373 22 is_stmt 0 view .LVU969
 2759 0012 0023     		movs	r3, #0
1373:ff.c          **** 	} else {							/* No heading saparator */
 2760              		.loc 1 1373 7 view .LVU970
 2761 0014 0135     		adds	r5, r5, #1
 2762              	.LVL305:
1373:ff.c          **** 	} else {							/* No heading saparator */
 2763              		.loc 1 1373 11 is_stmt 1 view .LVU971
 2764              	.L243:
1373:ff.c          **** 	} else {							/* No heading saparator */
 2765              		.loc 1 1373 11 is_stmt 0 view .LVU972
 2766 0016 B360     		str	r3, [r6, #8]
1383:ff.c          **** 		res = dir_seek(dj, 0);
 2767              		.loc 1 1383 2 is_stmt 1 view .LVU973
1383:ff.c          **** 		res = dir_seek(dj, 0);
 2768              		.loc 1 1383 5 is_stmt 0 view .LVU974
 2769 0018 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2770 001a 1F2B     		cmp	r3, #31
 2771 001c 3FD9     		bls	.L304
 2772              	.LBB73:
 2773              	.LBB74:
 2774              	.LBB75:
 2775              	.LBB76:
 172:ff.c          **** }
 2776              		.loc 1 172 21 view .LVU975
 2777 001e 2027     		movs	r7, #32
 2778              	.LVL306:
 2779              	.L244:
 172:ff.c          **** }
 2780              		.loc 1 172 21 view .LVU976
 2781              	.LBE76:
 2782              	.LBE75:
 2783              	.LBE74:
 2784              	.LBE73:
1388:ff.c          **** 			res = create_name(dj, &path);	/* Get a segment */
 2785              		.loc 1 1388 3 is_stmt 1 view .LVU977
1389:ff.c          **** 			if (res != FR_OK) break;
 2786              		.loc 1 1389 4 view .LVU978
1389:ff.c          **** 			if (res != FR_OK) break;
 2787              		.loc 1 1389 10 is_stmt 0 view .LVU979
 2788 0020 B069     		ldr	r0, [r6, #24]
 2789              	.LVL307:
 2790              	.LBB89:
 2791              	.LBI73:
1078:ff.c          **** 	DIR *dj,			/* Pointer to the directory object */
 2792              		.loc 1 1078 9 is_stmt 1 view .LVU980
 2793              	.LBB84:
1206:ff.c          **** 	int ni, si, i;
 2794              		.loc 1 1206 2 view .LVU981
1207:ff.c          **** 	const char *p;
 2795              		.loc 1 1207 2 view .LVU982
1208:ff.c          **** 
 2796              		.loc 1 1208 2 view .LVU983
1211:ff.c          **** 	mem_set(sfn, ' ', 11);
 2797              		.loc 1 1211 2 view .LVU984
1212:ff.c          **** 	si = i = b = 0; ni = 8;
 2798              		.loc 1 1212 2 view .LVU985
 2799              	.LBB79:
 2800              	.LBI75:
 170:ff.c          **** 	char *d = (char*)dst;
 2801              		.loc 1 170 6 view .LVU986
 2802              	.LBE79:
 2803              	.LBE84:
 2804              	.LBE89:
1389:ff.c          **** 			if (res != FR_OK) break;
 2805              		.loc 1 1389 10 is_stmt 0 view .LVU987
 2806 0022 0346     		mov	r3, r0
 2807 0024 00F10B02 		add	r2, r0, #11
 2808              	.LVL308:
 2809              	.L246:
 2810              	.LBB90:
 2811              	.LBB85:
 2812              	.LBB80:
 2813              	.LBB77:
 172:ff.c          **** }
 2814              		.loc 1 172 8 is_stmt 1 view .LVU988
 172:ff.c          **** }
 2815              		.loc 1 172 8 is_stmt 0 view .LVU989
 2816 0028 9342     		cmp	r3, r2
 2817 002a 42D1     		bne	.L247
 2818              	.LVL309:
 172:ff.c          **** }
 2819              		.loc 1 172 8 view .LVU990
 2820              	.LBE77:
 2821              	.LBE80:
1213:ff.c          **** 	p = *path;
 2822              		.loc 1 1213 2 is_stmt 1 view .LVU991
1213:ff.c          **** 	p = *path;
 2823              		.loc 1 1213 18 view .LVU992
1214:ff.c          **** #if _FS_RPATH
 2824              		.loc 1 1214 2 view .LVU993
1216:ff.c          **** 		for (;;) {
 2825              		.loc 1 1216 2 view .LVU994
1216:ff.c          **** 		for (;;) {
 2826              		.loc 1 1216 5 is_stmt 0 view .LVU995
 2827 002c 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2828 002e 2E2B     		cmp	r3, #46
 2829 0030 4CD1     		bne	.L276
1217:ff.c          **** 			c = p[si++];
 2830              		.loc 1 1217 3 is_stmt 1 view .LVU996
1218:ff.c          **** 			if (c != '.' || si >= 3) break;
 2831              		.loc 1 1218 4 view .LVU997
 2832              	.LVL310:
1219:ff.c          **** 			sfn[i++] = c;
 2833              		.loc 1 1219 4 view .LVU998
1220:ff.c          **** 		}
 2834              		.loc 1 1220 4 view .LVU999
1220:ff.c          **** 		}
 2835              		.loc 1 1220 13 is_stmt 0 view .LVU1000
 2836 0032 0370     		strb	r3, [r0]
1217:ff.c          **** 			c = p[si++];
 2837              		.loc 1 1217 9 is_stmt 1 view .LVU1001
1217:ff.c          **** 			c = p[si++];
 2838              		.loc 1 1217 3 view .LVU1002
1218:ff.c          **** 			if (c != '.' || si >= 3) break;
 2839              		.loc 1 1218 4 view .LVU1003
 2840              	.LVL311:
1218:ff.c          **** 			if (c != '.' || si >= 3) break;
 2841              		.loc 1 1218 6 is_stmt 0 view .LVU1004
 2842 0034 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 2843              	.LVL312:
1219:ff.c          **** 			sfn[i++] = c;
 2844              		.loc 1 1219 4 is_stmt 1 view .LVU1005
1219:ff.c          **** 			sfn[i++] = c;
 2845              		.loc 1 1219 7 is_stmt 0 view .LVU1006
 2846 0036 2E2B     		cmp	r3, #46
 2847 0038 3ED1     		bne	.L277
 2848              	.LVL313:
1220:ff.c          **** 		}
 2849              		.loc 1 1220 4 is_stmt 1 view .LVU1007
1220:ff.c          **** 		}
 2850              		.loc 1 1220 13 is_stmt 0 view .LVU1008
 2851 003a 4370     		strb	r3, [r0, #1]
1217:ff.c          **** 			c = p[si++];
 2852              		.loc 1 1217 9 is_stmt 1 view .LVU1009
1217:ff.c          **** 			c = p[si++];
 2853              		.loc 1 1217 3 view .LVU1010
1218:ff.c          **** 			if (c != '.' || si >= 3) break;
 2854              		.loc 1 1218 4 view .LVU1011
 2855              	.LVL314:
1218:ff.c          **** 			if (c != '.' || si >= 3) break;
 2856              		.loc 1 1218 6 is_stmt 0 view .LVU1012
 2857 003c AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 2858              	.LVL315:
1219:ff.c          **** 			sfn[i++] = c;
 2859              		.loc 1 1219 4 is_stmt 1 view .LVU1013
1219:ff.c          **** 			sfn[i++] = c;
 2860              		.loc 1 1219 7 is_stmt 0 view .LVU1014
 2861 003e 2E2B     		cmp	r3, #46
 2862 0040 00F0E780 		beq	.L250
1218:ff.c          **** 			if (c != '.' || si >= 3) break;
 2863              		.loc 1 1218 12 view .LVU1015
 2864 0044 0322     		movs	r2, #3
 2865              	.LVL316:
 2866              	.L249:
1222:ff.c          **** 		*path = &p[si];									/* Rerurn pointer to the next segment */
 2867              		.loc 1 1222 3 is_stmt 1 view .LVU1016
1222:ff.c          **** 		*path = &p[si];									/* Rerurn pointer to the next segment */
 2868              		.loc 1 1222 6 is_stmt 0 view .LVU1017
 2869 0046 2F2B     		cmp	r3, #47
 2870 0048 38D1     		bne	.L251
 2871              	.L307:
1223:ff.c          **** 		sfn[11] = (c < ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 2872              		.loc 1 1223 3 is_stmt 1 view .LVU1018
1224:ff.c          **** 		return FR_OK;
 2873              		.loc 1 1224 11 is_stmt 0 view .LVU1019
 2874 004a 2023     		movs	r3, #32
 2875              	.LVL317:
1223:ff.c          **** 		sfn[11] = (c < ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 2876              		.loc 1 1223 11 view .LVU1020
 2877 004c 1544     		add	r5, r5, r2
 2878              	.LVL318:
1224:ff.c          **** 		return FR_OK;
 2879              		.loc 1 1224 3 is_stmt 1 view .LVU1021
 2880              	.L252:
1224:ff.c          **** 		return FR_OK;
 2881              		.loc 1 1224 11 is_stmt 0 view .LVU1022
 2882 004e C372     		strb	r3, [r0, #11]
1225:ff.c          **** 	}
 2883              		.loc 1 1225 3 is_stmt 1 view .LVU1023
 2884              	.LVL319:
1225:ff.c          **** 	}
 2885              		.loc 1 1225 3 is_stmt 0 view .LVU1024
 2886              	.LBE85:
 2887              	.LBE90:
1390:ff.c          **** 			res = dir_find(dj);				/* Find it */
 2888              		.loc 1 1390 4 is_stmt 1 view .LVU1025
 2889              	.L254:
1391:ff.c          **** 			last = *(dj->fn+11) & NS_LAST;
 2890              		.loc 1 1391 4 view .LVU1026
 2891              	.LBB91:
 2892              	.LBI91:
 805:ff.c          **** 	DIR *dj			/* Pointer to the directory object linked to the file name */
 2893              		.loc 1 805 9 view .LVU1027
 2894              	.LBB92:
 809:ff.c          **** 	BYTE c, *dir;
 2895              		.loc 1 809 2 view .LVU1028
 810:ff.c          **** #if _USE_LFN
 2896              		.loc 1 810 2 view .LVU1029
 815:ff.c          **** 	if (res != FR_OK) return res;
 2897              		.loc 1 815 2 view .LVU1030
 815:ff.c          **** 	if (res != FR_OK) return res;
 2898              		.loc 1 815 8 is_stmt 0 view .LVU1031
 2899 0050 0021     		movs	r1, #0
 2900 0052 3046     		mov	r0, r6
 2901 0054 FFF7FEFF 		bl	dir_seek
 2902              	.LVL320:
 2903              	.L308:
 816:ff.c          **** 
 2904              		.loc 1 816 2 is_stmt 1 view .LVU1032
 816:ff.c          **** 
 2905              		.loc 1 816 5 is_stmt 0 view .LVU1033
 2906 0058 0446     		mov	r4, r0
 2907 005a 0028     		cmp	r0, #0
 2908 005c 40F08F80 		bne	.L271
 821:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2909              		.loc 1 821 2 is_stmt 1 view .LVU1034
 822:ff.c          **** 		if (res != FR_OK) break;
 2910              		.loc 1 822 3 view .LVU1035
 822:ff.c          **** 		if (res != FR_OK) break;
 2911              		.loc 1 822 9 is_stmt 0 view .LVU1036
 2912 0060 3169     		ldr	r1, [r6, #16]
 2913 0062 3068     		ldr	r0, [r6]
 2914              	.LVL321:
 822:ff.c          **** 		if (res != FR_OK) break;
 2915              		.loc 1 822 9 view .LVU1037
 2916 0064 FFF7FEFF 		bl	move_window
 2917              	.LVL322:
 823:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 2918              		.loc 1 823 3 is_stmt 1 view .LVU1038
 823:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 2919              		.loc 1 823 6 is_stmt 0 view .LVU1039
 2920 0068 0446     		mov	r4, r0
 2921 006a 0028     		cmp	r0, #0
 2922 006c 40F08780 		bne	.L271
 824:ff.c          **** 		c = dir[DIR_Name];
 2923              		.loc 1 824 3 is_stmt 1 view .LVU1040
 824:ff.c          **** 		c = dir[DIR_Name];
 2924              		.loc 1 824 7 is_stmt 0 view .LVU1041
 2925 0070 7069     		ldr	r0, [r6, #20]
 2926              	.LVL323:
 825:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2927              		.loc 1 825 3 is_stmt 1 view .LVU1042
 826:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2928              		.loc 1 826 3 view .LVU1043
 826:ff.c          **** #if _USE_LFN	/* LFN configuration */
 2929              		.loc 1 826 6 is_stmt 0 view .LVU1044
 2930 0072 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 2931 0074 002B     		cmp	r3, #0
 2932 0076 00F08180 		beq	.L279
 854:ff.c          **** 			break;
 2933              		.loc 1 854 3 is_stmt 1 view .LVU1045
 2934 007a C47A     		ldrb	r4, [r0, #11]	@ zero_extendqisi2
 854:ff.c          **** 			break;
 2935              		.loc 1 854 6 is_stmt 0 view .LVU1046
 2936 007c 14F00804 		ands	r4, r4, #8
 2937 0080 05D1     		bne	.L272
 854:ff.c          **** 			break;
 2938              		.loc 1 854 37 view .LVU1047
 2939 0082 0B22     		movs	r2, #11
 2940 0084 B169     		ldr	r1, [r6, #24]
 2941 0086 FFF7FEFF 		bl	mem_cmp
 2942              	.LVL324:
 854:ff.c          **** 			break;
 2943              		.loc 1 854 33 view .LVU1048
 2944 008a 0028     		cmp	r0, #0
 2945 008c 77D0     		beq	.L271
 2946              	.L272:
 857:ff.c          **** 	} while (res == FR_OK);
 2947              		.loc 1 857 3 is_stmt 1 view .LVU1049
 857:ff.c          **** 	} while (res == FR_OK);
 2948              		.loc 1 857 9 is_stmt 0 view .LVU1050
 2949 008e 0021     		movs	r1, #0
 2950 0090 3046     		mov	r0, r6
 2951 0092 FFF7FEFF 		bl	dir_next
 2952              	.LVL325:
 2953 0096 DFE7     		b	.L308
 2954              	.LVL326:
 2955              	.L242:
 857:ff.c          **** 	} while (res == FR_OK);
 2956              		.loc 1 857 9 view .LVU1051
 2957              	.LBE92:
 2958              	.LBE91:
1375:ff.c          **** 	}
 2959              		.loc 1 1375 3 is_stmt 1 view .LVU1052
1375:ff.c          **** 	}
 2960              		.loc 1 1375 22 is_stmt 0 view .LVU1053
 2961 0098 0368     		ldr	r3, [r0]
 2962 009a 9B69     		ldr	r3, [r3, #24]
 2963 009c BBE7     		b	.L243
 2964              	.LVL327:
 2965              	.L304:
1384:ff.c          **** 		dj->dir = NULL;
 2966              		.loc 1 1384 3 is_stmt 1 view .LVU1054
1384:ff.c          **** 		dj->dir = NULL;
 2967              		.loc 1 1384 9 is_stmt 0 view .LVU1055
 2968 009e 0021     		movs	r1, #0
 2969 00a0 3046     		mov	r0, r6
 2970              	.LVL328:
1384:ff.c          **** 		dj->dir = NULL;
 2971              		.loc 1 1384 9 view .LVU1056
 2972 00a2 FFF7FEFF 		bl	dir_seek
 2973              	.LVL329:
1385:ff.c          **** 
 2974              		.loc 1 1385 11 view .LVU1057
 2975 00a6 0023     		movs	r3, #0
1384:ff.c          **** 		dj->dir = NULL;
 2976              		.loc 1 1384 9 view .LVU1058
 2977 00a8 0446     		mov	r4, r0
 2978              	.LVL330:
1385:ff.c          **** 
 2979              		.loc 1 1385 3 is_stmt 1 view .LVU1059
1385:ff.c          **** 
 2980              		.loc 1 1385 11 is_stmt 0 view .LVU1060
 2981 00aa 7361     		str	r3, [r6, #20]
 2982              	.LVL331:
 2983              	.L281:
1408:ff.c          **** 
 2984              		.loc 1 1408 1 view .LVU1061
 2985 00ac 2046     		mov	r0, r4
 2986 00ae BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2987              	.LVL332:
 2988              	.L247:
 2989              	.LBB94:
 2990              	.LBB86:
 2991              	.LBB81:
 2992              	.LBB78:
 172:ff.c          **** }
 2993              		.loc 1 172 16 is_stmt 1 view .LVU1062
 172:ff.c          **** }
 2994              		.loc 1 172 21 is_stmt 0 view .LVU1063
 2995 00b2 03F8017B 		strb	r7, [r3], #1
 2996              	.LVL333:
 172:ff.c          **** }
 2997              		.loc 1 172 21 view .LVU1064
 2998 00b6 B7E7     		b	.L246
 2999              	.LVL334:
 3000              	.L277:
 172:ff.c          **** }
 3001              		.loc 1 172 21 view .LVU1065
 3002              	.LBE78:
 3003              	.LBE81:
1218:ff.c          **** 			if (c != '.' || si >= 3) break;
 3004              		.loc 1 1218 12 view .LVU1066
 3005 00b8 0222     		movs	r2, #2
 3006 00ba C4E7     		b	.L249
 3007              	.LVL335:
 3008              	.L251:
1222:ff.c          **** 		*path = &p[si];									/* Rerurn pointer to the next segment */
 3009              		.loc 1 1222 16 view .LVU1067
 3010 00bc 5C2B     		cmp	r3, #92
 3011 00be C4D0     		beq	.L307
1222:ff.c          **** 		*path = &p[si];									/* Rerurn pointer to the next segment */
 3012              		.loc 1 1222 29 view .LVU1068
 3013 00c0 1F2B     		cmp	r3, #31
 3014 00c2 00F2A680 		bhi	.L250
1223:ff.c          **** 		sfn[11] = (c < ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 3015              		.loc 1 1223 3 is_stmt 1 view .LVU1069
1224:ff.c          **** 		return FR_OK;
 3016              		.loc 1 1224 11 is_stmt 0 view .LVU1070
 3017 00c6 2423     		movs	r3, #36
 3018              	.LVL336:
1223:ff.c          **** 		sfn[11] = (c < ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 3019              		.loc 1 1223 11 view .LVU1071
 3020 00c8 1544     		add	r5, r5, r2
 3021              	.LVL337:
1224:ff.c          **** 		return FR_OK;
 3022              		.loc 1 1224 3 is_stmt 1 view .LVU1072
 3023 00ca C0E7     		b	.L252
 3024              	.LVL338:
 3025              	.L276:
1213:ff.c          **** 	p = *path;
 3026              		.loc 1 1213 9 is_stmt 0 view .LVU1073
 3027 00cc 0021     		movs	r1, #0
1213:ff.c          **** 	p = *path;
 3028              		.loc 1 1213 21 view .LVU1074
 3029 00ce 0824     		movs	r4, #8
1213:ff.c          **** 	p = *path;
 3030              		.loc 1 1213 5 view .LVU1075
 3031 00d0 8C46     		mov	ip, r1
1213:ff.c          **** 	p = *path;
 3032              		.loc 1 1213 13 view .LVU1076
 3033 00d2 0B46     		mov	r3, r1
 3034 00d4 79E0     		b	.L248
 3035              	.LVL339:
 3036              	.L260:
1247:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 3037              		.loc 1 1247 4 is_stmt 1 view .LVU1077
1247:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 3038              		.loc 1 1247 6 is_stmt 0 view .LVU1078
 3039 00d6 15F80880 		ldrb	r8, [r5, r8]	@ zero_extendqisi2
 3040              	.LVL340:
1247:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 3041              		.loc 1 1247 12 view .LVU1079
 3042 00da 0CF1020C 		add	ip, ip, #2
 3043              	.LVL341:
1248:ff.c          **** 				return FR_INVALID_NAME;
 3044              		.loc 1 1248 4 is_stmt 1 view .LVU1080
1248:ff.c          **** 				return FR_INVALID_NAME;
 3045              		.loc 1 1248 7 is_stmt 0 view .LVU1081
 3046 00de 28F0200E 		bic	lr, r8, #32
 3047 00e2 AEF1410E 		sub	lr, lr, #65
 3048 00e6 BEF1190F 		cmp	lr, #25
 3049 00ea 07D9     		bls	.L262
1248:ff.c          **** 				return FR_INVALID_NAME;
 3050              		.loc 1 1248 9 view .LVU1082
 3051 00ec 08F17F0E 		add	lr, r8, #127
1248:ff.c          **** 				return FR_INVALID_NAME;
 3052              		.loc 1 1248 8 view .LVU1083
 3053 00f0 5FFA8EFE 		uxtb	lr, lr
 3054 00f4 BEF17D0F 		cmp	lr, #125
 3055 00f8 00F28B80 		bhi	.L250
 3056              	.L262:
1248:ff.c          **** 				return FR_INVALID_NAME;
 3057              		.loc 1 1248 31 view .LVU1084
 3058 00fc 04F1FF3E 		add	lr, r4, #-1
1248:ff.c          **** 				return FR_INVALID_NAME;
 3059              		.loc 1 1248 20 view .LVU1085
 3060 0100 7145     		cmp	r1, lr
 3061 0102 80F28680 		bge	.L250
1250:ff.c          **** 			sfn[i++] = d;
 3062              		.loc 1 1250 4 is_stmt 1 view .LVU1086
1250:ff.c          **** 			sfn[i++] = d;
 3063              		.loc 1 1250 9 is_stmt 0 view .LVU1087
 3064 0106 01F1010E 		add	lr, r1, #1
 3065              	.LVL342:
1250:ff.c          **** 			sfn[i++] = d;
 3066              		.loc 1 1250 13 view .LVU1088
 3067 010a 4254     		strb	r2, [r0, r1]
1251:ff.c          **** 		} else {
 3068              		.loc 1 1251 4 is_stmt 1 view .LVU1089
 3069              	.LVL343:
1251:ff.c          **** 		} else {
 3070              		.loc 1 1251 13 is_stmt 0 view .LVU1090
 3071 010c 00F80E80 		strb	r8, [r0, lr]
 3072 0110 0231     		adds	r1, r1, #2
 3073              	.LVL344:
1247:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 3074              		.loc 1 1247 12 view .LVU1091
 3075 0112 E046     		mov	r8, ip
 3076              	.LVL345:
1247:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 3077              		.loc 1 1247 12 view .LVU1092
 3078 0114 58E0     		b	.L258
 3079              	.LVL346:
 3080              	.L263:
1255:ff.c          **** 				b |= 2;
 3081              		.loc 1 1255 4 is_stmt 1 view .LVU1093
1255:ff.c          **** 				b |= 2;
 3082              		.loc 1 1255 7 is_stmt 0 view .LVU1094
 3083 0116 A2F1410C 		sub	ip, r2, #65
 3084 011a BCF1190F 		cmp	ip, #25
 3085 011e 04D8     		bhi	.L264
1256:ff.c          **** 			} else {
 3086              		.loc 1 1256 5 is_stmt 1 view .LVU1095
1256:ff.c          **** 			} else {
 3087              		.loc 1 1256 7 is_stmt 0 view .LVU1096
 3088 0120 43F00203 		orr	r3, r3, #2
 3089              	.LVL347:
 3090              	.L265:
1262:ff.c          **** 		}
 3091              		.loc 1 1262 4 is_stmt 1 view .LVU1097
1262:ff.c          **** 		}
 3092              		.loc 1 1262 13 is_stmt 0 view .LVU1098
 3093 0124 4254     		strb	r2, [r0, r1]
1262:ff.c          **** 		}
 3094              		.loc 1 1262 9 view .LVU1099
 3095 0126 0131     		adds	r1, r1, #1
 3096              	.LVL348:
1262:ff.c          **** 		}
 3097              		.loc 1 1262 9 view .LVU1100
 3098 0128 4EE0     		b	.L258
 3099              	.L264:
1258:ff.c          **** 					b |= 1; c -= 0x20;
 3100              		.loc 1 1258 5 is_stmt 1 view .LVU1101
1258:ff.c          **** 					b |= 1; c -= 0x20;
 3101              		.loc 1 1258 8 is_stmt 0 view .LVU1102
 3102 012a A2F1610C 		sub	ip, r2, #97
 3103 012e BCF1190F 		cmp	ip, #25
1259:ff.c          **** 				}
 3104              		.loc 1 1259 6 is_stmt 1 view .LVU1103
1259:ff.c          **** 				}
 3105              		.loc 1 1259 16 is_stmt 0 view .LVU1104
 3106 0132 9EBF     		ittt	ls
 3107 0134 203A     		subls	r2, r2, #32
 3108              	.LVL349:
1259:ff.c          **** 				}
 3109              		.loc 1 1259 8 view .LVU1105
 3110 0136 43F00103 		orrls	r3, r3, #1
 3111              	.LVL350:
1259:ff.c          **** 				}
 3112              		.loc 1 1259 14 is_stmt 1 view .LVU1106
1259:ff.c          **** 				}
 3113              		.loc 1 1259 16 is_stmt 0 view .LVU1107
 3114 013a D2B2     		uxtbls	r2, r2
 3115              	.LVL351:
1259:ff.c          **** 				}
 3116              		.loc 1 1259 16 view .LVU1108
 3117 013c F2E7     		b	.L265
 3118              	.L255:
1265:ff.c          **** 	c = (c < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 3119              		.loc 1 1265 2 is_stmt 1 view .LVU1109
1266:ff.c          **** 
 3120              		.loc 1 1266 4 is_stmt 0 view .LVU1110
 3121 013e 202A     		cmp	r2, #32
 3122 0140 34BF     		ite	cc
 3123 0142 0422     		movcc	r2, #4
 3124              	.LVL352:
1266:ff.c          **** 
 3125              		.loc 1 1266 4 view .LVU1111
 3126 0144 0022     		movcs	r2, #0
1265:ff.c          **** 	c = (c < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 3127              		.loc 1 1265 10 view .LVU1112
 3128 0146 4544     		add	r5, r5, r8
 3129              	.LVL353:
1266:ff.c          **** 
 3130              		.loc 1 1266 2 is_stmt 1 view .LVU1113
1268:ff.c          **** 	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
 3131              		.loc 1 1268 2 view .LVU1114
1268:ff.c          **** 	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
 3132              		.loc 1 1268 5 is_stmt 0 view .LVU1115
 3133 0148 0029     		cmp	r1, #0
 3134 014a 62D0     		beq	.L250
1269:ff.c          **** 
 3135              		.loc 1 1269 2 is_stmt 1 view .LVU1116
1269:ff.c          **** 
 3136              		.loc 1 1269 5 is_stmt 0 view .LVU1117
 3137 014c 0178     		ldrb	r1, [r0]	@ zero_extendqisi2
 3138              	.LVL354:
1269:ff.c          **** 
 3139              		.loc 1 1269 5 view .LVU1118
 3140 014e E529     		cmp	r1, #229
1269:ff.c          **** 
 3141              		.loc 1 1269 22 is_stmt 1 view .LVU1119
1269:ff.c          **** 
 3142              		.loc 1 1269 29 is_stmt 0 view .LVU1120
 3143 0150 04BF     		itt	eq
 3144 0152 0521     		moveq	r1, #5
 3145 0154 0170     		strbeq	r1, [r0]
1271:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
 3146              		.loc 1 1271 2 is_stmt 1 view .LVU1121
1271:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
 3147              		.loc 1 1271 5 is_stmt 0 view .LVU1122
 3148 0156 082C     		cmp	r4, #8
 3149 0158 09D1     		bne	.L268
1271:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
 3150              		.loc 1 1271 15 is_stmt 1 view .LVU1123
1271:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
 3151              		.loc 1 1271 17 is_stmt 0 view .LVU1124
 3152 015a 9B00     		lsls	r3, r3, #2
 3153              	.LVL355:
1271:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
 3154              		.loc 1 1271 17 view .LVU1125
 3155 015c DBB2     		uxtb	r3, r3
 3156              	.LVL356:
1272:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 3157              		.loc 1 1272 2 is_stmt 1 view .LVU1126
 3158              	.L269:
1273:ff.c          **** 
 3159              		.loc 1 1273 2 view .LVU1127
1273:ff.c          **** 
 3160              		.loc 1 1273 5 is_stmt 0 view .LVU1128
 3161 015e 03F00C03 		and	r3, r3, #12
 3162              	.LVL357:
1273:ff.c          **** 
 3163              		.loc 1 1273 5 view .LVU1129
 3164 0162 042B     		cmp	r3, #4
1273:ff.c          **** 
 3165              		.loc 1 1273 26 is_stmt 1 view .LVU1130
1273:ff.c          **** 
 3166              		.loc 1 1273 28 is_stmt 0 view .LVU1131
 3167 0164 08BF     		it	eq
 3168 0166 42F00802 		orreq	r2, r2, #8
 3169              	.LVL358:
1275:ff.c          **** #endif
 3170              		.loc 1 1275 2 is_stmt 1 view .LVU1132
1275:ff.c          **** #endif
 3171              		.loc 1 1275 10 is_stmt 0 view .LVU1133
 3172 016a C272     		strb	r2, [r0, #11]
1278:ff.c          **** }
 3173              		.loc 1 1278 2 is_stmt 1 view .LVU1134
 3174              	.LVL359:
1278:ff.c          **** }
 3175              		.loc 1 1278 2 is_stmt 0 view .LVU1135
 3176              	.LBE86:
 3177              	.LBE94:
1390:ff.c          **** 			res = dir_find(dj);				/* Find it */
 3178              		.loc 1 1390 4 is_stmt 1 view .LVU1136
 3179 016c 70E7     		b	.L254
 3180              	.LVL360:
 3181              	.L268:
 3182              	.LBB95:
 3183              	.LBB87:
1272:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 3184              		.loc 1 1272 2 view .LVU1137
1272:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 3185              		.loc 1 1272 5 is_stmt 0 view .LVU1138
 3186 016e 03F00301 		and	r1, r3, #3
 3187 0172 0129     		cmp	r1, #1
1272:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 3188              		.loc 1 1272 26 is_stmt 1 view .LVU1139
1272:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 3189              		.loc 1 1272 28 is_stmt 0 view .LVU1140
 3190 0174 08BF     		it	eq
 3191 0176 42F01002 		orreq	r2, r2, #16
 3192              	.LVL361:
1272:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 3193              		.loc 1 1272 28 view .LVU1141
 3194 017a F0E7     		b	.L269
 3195              	.LVL362:
 3196              	.L279:
1272:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 3197              		.loc 1 1272 28 view .LVU1142
 3198              	.LBE87:
 3199              	.LBE95:
 3200              	.LBB96:
 3201              	.LBB93:
 826:ff.c          **** #if _USE_LFN	/* LFN configuration */
 3202              		.loc 1 826 21 view .LVU1143
 3203 017c 0424     		movs	r4, #4
 3204              	.LVL363:
 3205              	.L271:
 826:ff.c          **** #if _USE_LFN	/* LFN configuration */
 3206              		.loc 1 826 21 view .LVU1144
 3207              	.LBE93:
 3208              	.LBE96:
1392:ff.c          **** 			if (res != FR_OK) {				/* Could not find the object */
 3209              		.loc 1 1392 4 is_stmt 1 view .LVU1145
1392:ff.c          **** 			if (res != FR_OK) {				/* Could not find the object */
 3210              		.loc 1 1392 11 is_stmt 0 view .LVU1146
 3211 017e B369     		ldr	r3, [r6, #24]
1392:ff.c          **** 			if (res != FR_OK) {				/* Could not find the object */
 3212              		.loc 1 1392 9 view .LVU1147
 3213 0180 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 3214 0182 03F00403 		and	r3, r3, #4
 3215              	.LVL364:
1393:ff.c          **** 				if (res == FR_NO_FILE && !last)
 3216              		.loc 1 1393 4 is_stmt 1 view .LVU1148
1393:ff.c          **** 				if (res == FR_NO_FILE && !last)
 3217              		.loc 1 1393 7 is_stmt 0 view .LVU1149
 3218 0186 2CB1     		cbz	r4, .L274
1394:ff.c          **** 					res = FR_NO_PATH;
 3219              		.loc 1 1394 5 is_stmt 1 view .LVU1150
1394:ff.c          **** 					res = FR_NO_PATH;
 3220              		.loc 1 1394 8 is_stmt 0 view .LVU1151
 3221 0188 042C     		cmp	r4, #4
 3222 018a 8FD1     		bne	.L281
 3223              	.LVL365:
1395:ff.c          **** 				break;
 3224              		.loc 1 1395 10 discriminator 1 view .LVU1152
 3225 018c 002B     		cmp	r3, #0
 3226 018e 08BF     		it	eq
 3227 0190 0524     		moveq	r4, #5
 3228 0192 8BE7     		b	.L281
 3229              	.LVL366:
 3230              	.L274:
1398:ff.c          **** 			dir = dj->dir;					/* There is next segment. Follow the sub directory */
 3231              		.loc 1 1398 4 is_stmt 1 view .LVU1153
1398:ff.c          **** 			dir = dj->dir;					/* There is next segment. Follow the sub directory */
 3232              		.loc 1 1398 7 is_stmt 0 view .LVU1154
 3233 0194 002B     		cmp	r3, #0
 3234 0196 89D1     		bne	.L281
1399:ff.c          **** 			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
 3235              		.loc 1 1399 4 is_stmt 1 view .LVU1155
1399:ff.c          **** 			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
 3236              		.loc 1 1399 8 is_stmt 0 view .LVU1156
 3237 0198 7269     		ldr	r2, [r6, #20]
 3238              	.LVL367:
1400:ff.c          **** 				res = FR_NO_PATH; break;
 3239              		.loc 1 1400 4 is_stmt 1 view .LVU1157
1400:ff.c          **** 				res = FR_NO_PATH; break;
 3240              		.loc 1 1400 7 is_stmt 0 view .LVU1158
 3241 019a D37A     		ldrb	r3, [r2, #11]	@ zero_extendqisi2
 3242              	.LVL368:
1400:ff.c          **** 				res = FR_NO_PATH; break;
 3243              		.loc 1 1400 7 view .LVU1159
 3244 019c DB06     		lsls	r3, r3, #27
 3245 019e 0BD5     		bpl	.L280
1403:ff.c          **** 		}
 3246              		.loc 1 1403 4 is_stmt 1 view .LVU1160
1403:ff.c          **** 		}
 3247              		.loc 1 1403 25 is_stmt 0 view .LVU1161
 3248 01a0 137D     		ldrb	r3, [r2, #20]	@ zero_extendqisi2
 3249 01a2 517D     		ldrb	r1, [r2, #21]	@ zero_extendqisi2
1403:ff.c          **** 		}
 3250              		.loc 1 1403 61 view .LVU1162
 3251 01a4 D07E     		ldrb	r0, [r2, #27]	@ zero_extendqisi2
1403:ff.c          **** 		}
 3252              		.loc 1 1403 18 view .LVU1163
 3253 01a6 43EA0121 		orr	r1, r3, r1, lsl #8
1403:ff.c          **** 		}
 3254              		.loc 1 1403 61 view .LVU1164
 3255 01aa 937E     		ldrb	r3, [r2, #26]	@ zero_extendqisi2
 3256 01ac 43EA0023 		orr	r3, r3, r0, lsl #8
1403:ff.c          **** 		}
 3257              		.loc 1 1403 59 view .LVU1165
 3258 01b0 43EA0143 		orr	r3, r3, r1, lsl #16
1403:ff.c          **** 		}
 3259              		.loc 1 1403 15 view .LVU1166
 3260 01b4 B360     		str	r3, [r6, #8]
 3261              	.LVL369:
1388:ff.c          **** 			res = create_name(dj, &path);	/* Get a segment */
 3262              		.loc 1 1388 9 is_stmt 1 view .LVU1167
1389:ff.c          **** 			if (res != FR_OK) break;
 3263              		.loc 1 1389 8 is_stmt 0 view .LVU1168
 3264 01b6 33E7     		b	.L244
 3265              	.LVL370:
 3266              	.L280:
1401:ff.c          **** 			}
 3267              		.loc 1 1401 9 view .LVU1169
 3268 01b8 0524     		movs	r4, #5
 3269              	.LVL371:
1407:ff.c          **** }
 3270              		.loc 1 1407 2 is_stmt 1 view .LVU1170
1407:ff.c          **** }
 3271              		.loc 1 1407 9 is_stmt 0 view .LVU1171
 3272 01ba 77E7     		b	.L281
 3273              	.LVL372:
 3274              	.L256:
 3275              	.LBB97:
 3276              	.LBB88:
1232:ff.c          **** 			i = 8; ni = 11;
 3277              		.loc 1 1232 4 is_stmt 1 view .LVU1172
1232:ff.c          **** 			i = 8; ni = 11;
 3278              		.loc 1 1232 7 is_stmt 0 view .LVU1173
 3279 01bc 082C     		cmp	r4, #8
 3280 01be 28D1     		bne	.L250
1233:ff.c          **** 			b <<= 2; continue;
 3281              		.loc 1 1233 4 is_stmt 1 view .LVU1174
 3282              	.LVL373:
1233:ff.c          **** 			b <<= 2; continue;
 3283              		.loc 1 1233 11 view .LVU1175
1234:ff.c          **** 		}
 3284              		.loc 1 1234 4 view .LVU1176
1233:ff.c          **** 			b <<= 2; continue;
 3285              		.loc 1 1233 6 is_stmt 0 view .LVU1177
 3286 01c0 2146     		mov	r1, r4
1233:ff.c          **** 			b <<= 2; continue;
 3287              		.loc 1 1233 14 view .LVU1178
 3288 01c2 0B24     		movs	r4, #11
1234:ff.c          **** 		}
 3289              		.loc 1 1234 6 view .LVU1179
 3290 01c4 9B00     		lsls	r3, r3, #2
 3291              	.LVL374:
1234:ff.c          **** 		}
 3292              		.loc 1 1234 6 view .LVU1180
 3293 01c6 DBB2     		uxtb	r3, r3
 3294              	.LVL375:
1234:ff.c          **** 		}
 3295              		.loc 1 1234 13 is_stmt 1 view .LVU1181
 3296              	.L258:
1247:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 3297              		.loc 1 1247 12 is_stmt 0 view .LVU1182
 3298 01c8 C446     		mov	ip, r8
 3299              	.LVL376:
 3300              	.L248:
1228:ff.c          **** 		c = p[si++];
 3301              		.loc 1 1228 2 is_stmt 1 view .LVU1183
1229:ff.c          **** 		if (c < ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 3302              		.loc 1 1229 3 view .LVU1184
1229:ff.c          **** 		if (c < ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 3303              		.loc 1 1229 5 is_stmt 0 view .LVU1185
 3304 01ca 15F80C20 		ldrb	r2, [r5, ip]	@ zero_extendqisi2
1229:ff.c          **** 		if (c < ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 3305              		.loc 1 1229 11 view .LVU1186
 3306 01ce 0CF10108 		add	r8, ip, #1
 3307              	.LVL377:
1230:ff.c          **** 		if (c == '.' || i >= ni) {
 3308              		.loc 1 1230 3 is_stmt 1 view .LVU1187
1230:ff.c          **** 		if (c == '.' || i >= ni) {
 3309              		.loc 1 1230 6 is_stmt 0 view .LVU1188
 3310 01d2 1F2A     		cmp	r2, #31
 3311 01d4 B3D9     		bls	.L255
1230:ff.c          **** 		if (c == '.' || i >= ni) {
 3312              		.loc 1 1230 15 view .LVU1189
 3313 01d6 2F2A     		cmp	r2, #47
 3314 01d8 B1D0     		beq	.L255
1230:ff.c          **** 		if (c == '.' || i >= ni) {
 3315              		.loc 1 1230 27 view .LVU1190
 3316 01da 5C2A     		cmp	r2, #92
 3317 01dc AFD0     		beq	.L255
1231:ff.c          **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 3318              		.loc 1 1231 3 is_stmt 1 view .LVU1191
1231:ff.c          **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 3319              		.loc 1 1231 6 is_stmt 0 view .LVU1192
 3320 01de 2E2A     		cmp	r2, #46
 3321 01e0 ECD0     		beq	.L256
1231:ff.c          **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 3322              		.loc 1 1231 16 view .LVU1193
 3323 01e2 8C42     		cmp	r4, r1
 3324 01e4 15DD     		ble	.L250
1236:ff.c          **** #ifdef _EXCVT
 3325              		.loc 1 1236 3 is_stmt 1 view .LVU1194
1246:ff.c          **** 			d = p[si++];				/* Get 2nd byte */
 3326              		.loc 1 1246 7 is_stmt 0 view .LVU1195
 3327 01e6 02F17F0E 		add	lr, r2, #127
1236:ff.c          **** #ifdef _EXCVT
 3328              		.loc 1 1236 6 view .LVU1196
 3329 01ea 12F0800F 		tst	r2, #128
1240:ff.c          **** #if !_DF1S	/* ASCII only cfg */
 3330              		.loc 1 1240 4 is_stmt 1 view .LVU1197
1246:ff.c          **** 			d = p[si++];				/* Get 2nd byte */
 3331              		.loc 1 1246 6 is_stmt 0 view .LVU1198
 3332 01ee 5FFA8EFE 		uxtb	lr, lr
1240:ff.c          **** #if !_DF1S	/* ASCII only cfg */
 3333              		.loc 1 1240 6 view .LVU1199
 3334 01f2 18BF     		it	ne
 3335 01f4 43F00303 		orrne	r3, r3, #3
 3336              	.LVL378:
1246:ff.c          **** 			d = p[si++];				/* Get 2nd byte */
 3337              		.loc 1 1246 3 is_stmt 1 view .LVU1200
1246:ff.c          **** 			d = p[si++];				/* Get 2nd byte */
 3338              		.loc 1 1246 6 is_stmt 0 view .LVU1201
 3339 01f8 BEF17D0F 		cmp	lr, #125
 3340 01fc 7FF66BAF 		bls	.L260
 3341 0200 DFF814E0 		ldr	lr, .L309
 3342              	.L261:
 3343              	.LVL379:
 3344              	.LBB82:
 3345              	.LBB83:
 187:ff.c          **** 	return *str;
 3346              		.loc 1 187 8 is_stmt 1 view .LVU1202
 187:ff.c          **** 	return *str;
 3347              		.loc 1 187 9 is_stmt 0 view .LVU1203
 3348 0204 1EF801CB 		ldrb	ip, [lr], #1	@ zero_extendqisi2
 3349              	.LVL380:
 187:ff.c          **** 	return *str;
 3350              		.loc 1 187 8 view .LVU1204
 3351 0208 BCF1000F 		cmp	ip, #0
 3352 020c 83D0     		beq	.L263
 187:ff.c          **** 	return *str;
 3353              		.loc 1 187 14 view .LVU1205
 3354 020e 6245     		cmp	r2, ip
 3355 0210 F8D1     		bne	.L261
 3356              	.LVL381:
 3357              	.L250:
 187:ff.c          **** 	return *str;
 3358              		.loc 1 187 14 view .LVU1206
 3359              	.LBE83:
 3360              	.LBE82:
1222:ff.c          **** 		*path = &p[si];									/* Rerurn pointer to the next segment */
 3361              		.loc 1 1222 49 view .LVU1207
 3362 0212 0624     		movs	r4, #6
 3363 0214 4AE7     		b	.L281
 3364              	.L310:
 3365 0216 00BF     		.align	2
 3366              	.L309:
 3367 0218 00000000 		.word	.LC0
 3368              	.LBE88:
 3369              	.LBE97:
 3370              		.cfi_endproc
 3371              	.LFE48:
 3373              		.section	.text.sync,"ax",%progbits
 3374              		.align	1
 3375              		.syntax unified
 3376              		.thumb
 3377              		.thumb_func
 3378              		.fpu softvfp
 3380              	sync:
 3381              	.LVL382:
 3382              	.LFB34:
 274:ff.c          **** 	FRESULT res;
 3383              		.loc 1 274 1 is_stmt 1 view -0
 3384              		.cfi_startproc
 3385              		@ args = 0, pretend = 0, frame = 0
 3386              		@ frame_needed = 0, uses_anonymous_args = 0
 275:ff.c          **** 
 3387              		.loc 1 275 2 view .LVU1209
 278:ff.c          **** 	if (res == FR_OK) {
 3388              		.loc 1 278 2 view .LVU1210
 274:ff.c          **** 	FRESULT res;
 3389              		.loc 1 274 1 is_stmt 0 view .LVU1211
 3390 0000 10B5     		push	{r4, lr}
 3391              		.cfi_def_cfa_offset 8
 3392              		.cfi_offset 4, -8
 3393              		.cfi_offset 14, -4
 278:ff.c          **** 	if (res == FR_OK) {
 3394              		.loc 1 278 8 view .LVU1212
 3395 0002 0021     		movs	r1, #0
 274:ff.c          **** 	FRESULT res;
 3396              		.loc 1 274 1 view .LVU1213
 3397 0004 0446     		mov	r4, r0
 278:ff.c          **** 	if (res == FR_OK) {
 3398              		.loc 1 278 8 view .LVU1214
 3399 0006 FFF7FEFF 		bl	move_window
 3400              	.LVL383:
 278:ff.c          **** 	if (res == FR_OK) {
 3401              		.loc 1 278 8 view .LVU1215
 3402 000a 0346     		mov	r3, r0
 3403              	.LVL384:
 279:ff.c          **** 		/* Update FSInfo sector if needed */
 3404              		.loc 1 279 2 is_stmt 1 view .LVU1216
 279:ff.c          **** 		/* Update FSInfo sector if needed */
 3405              		.loc 1 279 5 is_stmt 0 view .LVU1217
 3406 000c 70BB     		cbnz	r0, .L312
 3407              	.LVL385:
 3408              	.LBB102:
 3409              	.LBI102:
 271:ff.c          **** 	FATFS *fs	/* File system object */
 3410              		.loc 1 271 9 is_stmt 1 view .LVU1218
 3411              	.LBB103:
 281:ff.c          **** 			fs->winsect = 0;
 3412              		.loc 1 281 3 view .LVU1219
 281:ff.c          **** 			fs->winsect = 0;
 3413              		.loc 1 281 6 is_stmt 0 view .LVU1220
 3414 000e 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 3415 0010 032A     		cmp	r2, #3
 3416 0012 23D1     		bne	.L313
 281:ff.c          **** 			fs->winsect = 0;
 3417              		.loc 1 281 31 view .LVU1221
 3418 0014 A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
 3419 0016 0AB3     		cbz	r2, .L313
 282:ff.c          **** 			mem_set(fs->win, 0, 512);
 3420              		.loc 1 282 4 is_stmt 1 view .LVU1222
 283:ff.c          **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 3421              		.loc 1 283 14 is_stmt 0 view .LVU1223
 3422 0018 04F13401 		add	r1, r4, #52
 3423              	.LBB104:
 3424              	.LBB105:
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 3425              		.loc 1 171 8 view .LVU1224
 3426 001c 0A46     		mov	r2, r1
 3427              	.LBE105:
 3428              	.LBE104:
 282:ff.c          **** 			mem_set(fs->win, 0, 512);
 3429              		.loc 1 282 16 view .LVU1225
 3430 001e 2063     		str	r0, [r4, #48]
 283:ff.c          **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 3431              		.loc 1 283 4 is_stmt 1 view .LVU1226
 3432              	.LVL386:
 3433              	.LBB108:
 3434              	.LBI104:
 170:ff.c          **** 	char *d = (char*)dst;
 3435              		.loc 1 170 6 view .LVU1227
 3436              	.LBB106:
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 3437              		.loc 1 171 2 view .LVU1228
 172:ff.c          **** }
 3438              		.loc 1 172 2 view .LVU1229
 3439 0020 04F50D70 		add	r0, r4, #564
 3440              	.LVL387:
 3441              	.L314:
 172:ff.c          **** }
 3442              		.loc 1 172 8 view .LVU1230
 172:ff.c          **** }
 3443              		.loc 1 172 8 is_stmt 0 view .LVU1231
 3444 0024 8242     		cmp	r2, r0
 3445 0026 22D1     		bne	.L315
 3446              	.LVL388:
 172:ff.c          **** }
 3447              		.loc 1 172 8 view .LVU1232
 3448              	.LBE106:
 3449              	.LBE108:
 284:ff.c          **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 3450              		.loc 1 284 4 is_stmt 1 view .LVU1233
 284:ff.c          **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 3451              		.loc 1 284 4 view .LVU1234
 3452 0028 4AF65523 		movw	r3, #43605
 3453 002c A4F83232 		strh	r3, [r4, #562]	@ movhi
 285:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 3454              		.loc 1 285 4 view .LVU1235
 285:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 3455              		.loc 1 285 4 view .LVU1236
 285:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 3456              		.loc 1 285 4 view .LVU1237
 285:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 3457              		.loc 1 285 4 view .LVU1238
 3458 0030 104B     		ldr	r3, .L319
 289:ff.c          **** 			fs->fsi_flag = 0;
 3459              		.loc 1 289 4 is_stmt 0 view .LVU1239
 3460 0032 6269     		ldr	r2, [r4, #20]
 285:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 3461              		.loc 1 285 4 view .LVU1240
 3462 0034 6363     		str	r3, [r4, #52]
 286:ff.c          **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 3463              		.loc 1 286 4 is_stmt 1 view .LVU1241
 286:ff.c          **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 3464              		.loc 1 286 4 view .LVU1242
 286:ff.c          **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 3465              		.loc 1 286 4 view .LVU1243
 286:ff.c          **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 3466              		.loc 1 286 4 view .LVU1244
 3467 0036 03F1FF53 		add	r3, r3, #534773760
 3468 003a 03F50053 		add	r3, r3, #8192
 3469 003e 2033     		adds	r3, r3, #32
 3470 0040 C4F81832 		str	r3, [r4, #536]
 287:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 3471              		.loc 1 287 4 view .LVU1245
 287:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 3472              		.loc 1 287 4 view .LVU1246
 287:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 3473              		.loc 1 287 4 view .LVU1247
 287:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 3474              		.loc 1 287 4 view .LVU1248
 3475 0044 2369     		ldr	r3, [r4, #16]
 289:ff.c          **** 			fs->fsi_flag = 0;
 3476              		.loc 1 289 4 is_stmt 0 view .LVU1249
 3477 0046 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 287:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 3478              		.loc 1 287 4 view .LVU1250
 3479 0048 C4F81C32 		str	r3, [r4, #540]
 288:ff.c          **** 			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 3480              		.loc 1 288 4 is_stmt 1 view .LVU1251
 288:ff.c          **** 			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 3481              		.loc 1 288 4 view .LVU1252
 288:ff.c          **** 			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 3482              		.loc 1 288 4 view .LVU1253
 288:ff.c          **** 			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 3483              		.loc 1 288 4 view .LVU1254
 3484 004c E368     		ldr	r3, [r4, #12]
 3485 004e C4F82032 		str	r3, [r4, #544]
 289:ff.c          **** 			fs->fsi_flag = 0;
 3486              		.loc 1 289 4 view .LVU1255
 3487 0052 0123     		movs	r3, #1
 3488 0054 FFF7FEFF 		bl	disk_write
 3489              	.LVL389:
 290:ff.c          **** 		}
 3490              		.loc 1 290 4 view .LVU1256
 290:ff.c          **** 		}
 3491              		.loc 1 290 17 is_stmt 0 view .LVU1257
 3492 0058 0023     		movs	r3, #0
 3493 005a A372     		strb	r3, [r4, #10]
 3494              	.L313:
 293:ff.c          **** 			res = FR_DISK_ERR;
 3495              		.loc 1 293 3 is_stmt 1 view .LVU1258
 293:ff.c          **** 			res = FR_DISK_ERR;
 3496              		.loc 1 293 7 is_stmt 0 view .LVU1259
 3497 005c 0022     		movs	r2, #0
 3498 005e 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 3499 0060 1146     		mov	r1, r2
 3500 0062 FFF7FEFF 		bl	disk_ioctl
 3501              	.LVL390:
 278:ff.c          **** 	if (res == FR_OK) {
 3502              		.loc 1 278 8 view .LVU1260
 3503 0066 0038     		subs	r0, r0, #0
 3504 0068 18BF     		it	ne
 3505 006a 0120     		movne	r0, #1
 3506              	.LVL391:
 3507              	.L312:
 278:ff.c          **** 	if (res == FR_OK) {
 3508              		.loc 1 278 8 view .LVU1261
 3509              	.LBE103:
 3510              	.LBE102:
 297:ff.c          **** }
 3511              		.loc 1 297 2 is_stmt 1 view .LVU1262
 298:ff.c          **** #endif
 3512              		.loc 1 298 1 is_stmt 0 view .LVU1263
 3513 006c 10BD     		pop	{r4, pc}
 3514              	.LVL392:
 3515              	.L315:
 3516              	.LBB111:
 3517              	.LBB110:
 3518              	.LBB109:
 3519              	.LBB107:
 172:ff.c          **** }
 3520              		.loc 1 172 16 is_stmt 1 view .LVU1264
 172:ff.c          **** }
 3521              		.loc 1 172 21 is_stmt 0 view .LVU1265
 3522 006e 02F8013B 		strb	r3, [r2], #1
 3523              	.LVL393:
 172:ff.c          **** }
 3524              		.loc 1 172 21 view .LVU1266
 3525 0072 D7E7     		b	.L314
 3526              	.L320:
 3527              		.align	2
 3528              	.L319:
 3529 0074 52526141 		.word	1096897106
 3530              	.LBE107:
 3531              	.LBE109:
 3532              	.LBE110:
 3533              	.LBE111:
 3534              		.cfi_endproc
 3535              	.LFE34:
 3537              		.section	.text.f_mount,"ax",%progbits
 3538              		.align	1
 3539              		.global	f_mount
 3540              		.syntax unified
 3541              		.thumb
 3542              		.thumb_func
 3543              		.fpu softvfp
 3545              	f_mount:
 3546              	.LVL394:
 3547              	.LFB52:
1598:ff.c          **** 
1599:ff.c          **** 
1600:ff.c          **** 
1601:ff.c          **** 
1602:ff.c          **** /*--------------------------------------------------------------------------
1603:ff.c          **** 
1604:ff.c          ****    Public Functions
1605:ff.c          **** 
1606:ff.c          **** --------------------------------------------------------------------------*/
1607:ff.c          **** 
1608:ff.c          **** 
1609:ff.c          **** 
1610:ff.c          **** /*-----------------------------------------------------------------------*/
1611:ff.c          **** /* Mount/Unmount a Locical Drive                                         */
1612:ff.c          **** /*-----------------------------------------------------------------------*/
1613:ff.c          **** 
1614:ff.c          **** FRESULT f_mount (
1615:ff.c          **** 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
1616:ff.c          **** 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
1617:ff.c          **** )
1618:ff.c          **** {
 3548              		.loc 1 1618 1 is_stmt 1 view -0
 3549              		.cfi_startproc
 3550              		@ args = 0, pretend = 0, frame = 0
 3551              		@ frame_needed = 0, uses_anonymous_args = 0
 3552              		@ link register save eliminated.
1619:ff.c          **** 	FATFS *rfs;
 3553              		.loc 1 1619 2 view .LVU1268
1620:ff.c          **** 
1621:ff.c          **** 
1622:ff.c          **** 	if (vol >= _DRIVES)				/* Check if the drive number is valid */
 3554              		.loc 1 1622 2 view .LVU1269
 3555              		.loc 1 1622 5 is_stmt 0 view .LVU1270
 3556 0000 40B9     		cbnz	r0, .L325
1623:ff.c          **** 		return FR_INVALID_DRIVE;
1624:ff.c          **** 	rfs = FatFs[vol];				/* Get current fs object */
 3557              		.loc 1 1624 2 is_stmt 1 view .LVU1271
 3558              		.loc 1 1624 6 is_stmt 0 view .LVU1272
 3559 0002 054B     		ldr	r3, .L332
 3560 0004 1A68     		ldr	r2, [r3]
 3561              	.LVL395:
1625:ff.c          **** 
1626:ff.c          **** 	if (rfs) {
 3562              		.loc 1 1626 2 is_stmt 1 view .LVU1273
 3563              		.loc 1 1626 5 is_stmt 0 view .LVU1274
 3564 0006 02B1     		cbz	r2, .L323
1627:ff.c          **** #if _FS_REENTRANT					/* Discard sync object of the current volume */
1628:ff.c          **** 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
1629:ff.c          **** #endif
1630:ff.c          **** 		rfs->fs_type = 0;			/* Clear old fs object */
 3565              		.loc 1 1630 3 is_stmt 1 view .LVU1275
 3566              		.loc 1 1630 16 is_stmt 0 view .LVU1276
 3567 0008 1070     		strb	r0, [r2]
 3568              	.L323:
1631:ff.c          **** 	}
1632:ff.c          **** 
1633:ff.c          **** 	if (fs) {
 3569              		.loc 1 1633 2 is_stmt 1 view .LVU1277
 3570              		.loc 1 1633 5 is_stmt 0 view .LVU1278
 3571 000a 09B1     		cbz	r1, .L324
1634:ff.c          **** 		fs->fs_type = 0;			/* Clear new fs object */
 3572              		.loc 1 1634 3 is_stmt 1 view .LVU1279
 3573              		.loc 1 1634 15 is_stmt 0 view .LVU1280
 3574 000c 0022     		movs	r2, #0
 3575              	.LVL396:
 3576              		.loc 1 1634 15 view .LVU1281
 3577 000e 0A70     		strb	r2, [r1]
 3578              	.L324:
1635:ff.c          **** #if _FS_REENTRANT					/* Create sync object for the new volume */
1636:ff.c          **** 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
1637:ff.c          **** #endif
1638:ff.c          **** 	}
1639:ff.c          **** 	FatFs[vol] = fs;				/* Register new fs object */
 3579              		.loc 1 1639 2 is_stmt 1 view .LVU1282
 3580              		.loc 1 1639 13 is_stmt 0 view .LVU1283
 3581 0010 1960     		str	r1, [r3]
 3582              	.LVL397:
1640:ff.c          **** 
1641:ff.c          **** 	return FR_OK;
 3583              		.loc 1 1641 2 is_stmt 1 view .LVU1284
 3584              		.loc 1 1641 9 is_stmt 0 view .LVU1285
 3585 0012 7047     		bx	lr
 3586              	.L325:
1623:ff.c          **** 	rfs = FatFs[vol];				/* Get current fs object */
 3587              		.loc 1 1623 10 view .LVU1286
 3588 0014 0B20     		movs	r0, #11
 3589              	.LVL398:
1642:ff.c          **** }
 3590              		.loc 1 1642 1 view .LVU1287
 3591 0016 7047     		bx	lr
 3592              	.L333:
 3593              		.align	2
 3594              	.L332:
 3595 0018 00000000 		.word	.LANCHOR2
 3596              		.cfi_endproc
 3597              	.LFE52:
 3599              		.section	.text.f_open,"ax",%progbits
 3600              		.align	1
 3601              		.global	f_open
 3602              		.syntax unified
 3603              		.thumb
 3604              		.thumb_func
 3605              		.fpu softvfp
 3607              	f_open:
 3608              	.LVL399:
 3609              	.LFB53:
1643:ff.c          **** 
1644:ff.c          **** 
1645:ff.c          **** 
1646:ff.c          **** 
1647:ff.c          **** /*-----------------------------------------------------------------------*/
1648:ff.c          **** /* Open or Create a File                                                 */
1649:ff.c          **** /*-----------------------------------------------------------------------*/
1650:ff.c          **** 
1651:ff.c          **** FRESULT f_open (
1652:ff.c          **** 	FIL *fp,			/* Pointer to the blank file object */
1653:ff.c          **** 	const XCHAR *path,	/* Pointer to the file name */
1654:ff.c          **** 	BYTE mode			/* Access mode and file open mode flags */
1655:ff.c          **** )
1656:ff.c          **** {
 3610              		.loc 1 1656 1 is_stmt 1 view -0
 3611              		.cfi_startproc
 3612              		@ args = 0, pretend = 0, frame = 48
 3613              		@ frame_needed = 0, uses_anonymous_args = 0
1657:ff.c          **** 	FRESULT res;
 3614              		.loc 1 1657 2 view .LVU1289
1658:ff.c          **** 	DIR dj;
 3615              		.loc 1 1658 2 view .LVU1290
1659:ff.c          **** 	NAMEBUF(sfn, lfn);
 3616              		.loc 1 1659 2 view .LVU1291
1660:ff.c          **** 	BYTE *dir;
 3617              		.loc 1 1660 2 view .LVU1292
1661:ff.c          **** 
1662:ff.c          **** 
1663:ff.c          **** 	fp->fs = NULL;		/* Clear file object */
 3618              		.loc 1 1663 2 view .LVU1293
 3619              		.loc 1 1663 9 is_stmt 0 view .LVU1294
 3620 0000 0023     		movs	r3, #0
1656:ff.c          **** 	FRESULT res;
 3621              		.loc 1 1656 1 view .LVU1295
 3622 0002 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3623              		.cfi_def_cfa_offset 24
 3624              		.cfi_offset 4, -24
 3625              		.cfi_offset 5, -20
 3626              		.cfi_offset 6, -16
 3627              		.cfi_offset 7, -12
 3628              		.cfi_offset 8, -8
 3629              		.cfi_offset 14, -4
 3630 0006 8CB0     		sub	sp, sp, #48
 3631              		.cfi_def_cfa_offset 72
1656:ff.c          **** 	FRESULT res;
 3632              		.loc 1 1656 1 view .LVU1296
 3633 0008 0446     		mov	r4, r0
 3634 000a 1746     		mov	r7, r2
 3635 000c 0191     		str	r1, [sp, #4]
 3636              		.loc 1 1663 9 view .LVU1297
 3637 000e 0360     		str	r3, [r0]
1664:ff.c          **** #if !_FS_READONLY
1665:ff.c          **** 	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
 3638              		.loc 1 1665 2 is_stmt 1 view .LVU1298
 3639              	.LVL400:
1666:ff.c          **** 	res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_C
 3640              		.loc 1 1666 2 view .LVU1299
 3641              		.loc 1 1666 8 is_stmt 0 view .LVU1300
 3642 0010 02F01E02 		and	r2, r2, #30
 3643              	.LVL401:
 3644              		.loc 1 1666 8 view .LVU1301
 3645 0014 05A9     		add	r1, sp, #20
 3646              	.LVL402:
 3647              		.loc 1 1666 8 view .LVU1302
 3648 0016 01A8     		add	r0, sp, #4
 3649              	.LVL403:
 3650              		.loc 1 1666 8 view .LVU1303
 3651 0018 FFF7FEFF 		bl	auto_mount
 3652              	.LVL404:
1667:ff.c          **** #else
1668:ff.c          **** 	mode &= FA_READ;
1669:ff.c          **** 	res = auto_mount(&path, &dj.fs, 0);
1670:ff.c          **** #endif
1671:ff.c          **** 	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 3653              		.loc 1 1671 2 is_stmt 1 view .LVU1304
 3654              		.loc 1 1671 5 is_stmt 0 view .LVU1305
 3655 001c 0028     		cmp	r0, #0
 3656 001e 75D1     		bne	.L335
1672:ff.c          **** 	INITBUF(dj, sfn, lfn);
 3657              		.loc 1 1672 2 view .LVU1306
 3658 0020 02AB     		add	r3, sp, #8
1673:ff.c          **** 	res = follow_path(&dj, path);	/* Follow the file path */
 3659              		.loc 1 1673 8 view .LVU1307
 3660 0022 0199     		ldr	r1, [sp, #4]
 3661 0024 05A8     		add	r0, sp, #20
 3662              	.LVL405:
1672:ff.c          **** 	INITBUF(dj, sfn, lfn);
 3663              		.loc 1 1672 2 view .LVU1308
 3664 0026 0B93     		str	r3, [sp, #44]
 3665              		.loc 1 1673 8 view .LVU1309
 3666 0028 FFF7FEFF 		bl	follow_path
 3667              	.LVL406:
1674:ff.c          **** 
1675:ff.c          **** #if !_FS_READONLY
1676:ff.c          **** 	/* Create or Open a file */
1677:ff.c          **** 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 3668              		.loc 1 1677 5 view .LVU1310
 3669 002c 17F01C0F 		tst	r7, #28
1665:ff.c          **** 	res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_C
 3670              		.loc 1 1665 7 view .LVU1311
 3671 0030 07F01F06 		and	r6, r7, #31
1672:ff.c          **** 	res = follow_path(&dj, path);	/* Follow the file path */
 3672              		.loc 1 1672 2 is_stmt 1 view .LVU1312
1673:ff.c          **** 
 3673              		.loc 1 1673 2 view .LVU1313
 3674              	.LVL407:
 3675              		.loc 1 1677 2 view .LVU1314
 3676              		.loc 1 1677 5 is_stmt 0 view .LVU1315
 3677 0034 6DD0     		beq	.L336
 3678              	.LBB112:
1678:ff.c          **** 		DWORD ps, cl;
 3679              		.loc 1 1678 3 is_stmt 1 view .LVU1316
1679:ff.c          **** 
1680:ff.c          **** 		if (res != FR_OK) {			/* No file, create new */
 3680              		.loc 1 1680 3 view .LVU1317
 3681              		.loc 1 1680 6 is_stmt 0 view .LVU1318
 3682 0036 0028     		cmp	r0, #0
 3683 0038 38D0     		beq	.L337
1681:ff.c          **** 			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
 3684              		.loc 1 1681 4 is_stmt 1 view .LVU1319
 3685              		.loc 1 1681 7 is_stmt 0 view .LVU1320
 3686 003a 0428     		cmp	r0, #4
 3687 003c 66D1     		bne	.L335
1682:ff.c          **** 				res = dir_register(&dj);
 3688              		.loc 1 1682 5 is_stmt 1 view .LVU1321
 3689              		.loc 1 1682 11 is_stmt 0 view .LVU1322
 3690 003e 05A8     		add	r0, sp, #20
 3691              	.LVL408:
 3692              		.loc 1 1682 11 view .LVU1323
 3693 0040 FFF7FEFF 		bl	dir_register
 3694              	.LVL409:
1683:ff.c          **** 			if (res != FR_OK) LEAVE_FF(dj.fs, res);
 3695              		.loc 1 1683 4 is_stmt 1 view .LVU1324
 3696              		.loc 1 1683 7 is_stmt 0 view .LVU1325
 3697 0044 0028     		cmp	r0, #0
 3698 0046 61D1     		bne	.L335
1684:ff.c          **** 			mode |= FA_CREATE_ALWAYS;
 3699              		.loc 1 1684 4 is_stmt 1 view .LVU1326
1685:ff.c          **** 			dir = dj.dir;			/* Created entry (SFN entry) */
 3700              		.loc 1 1685 8 is_stmt 0 view .LVU1327
 3701 0048 0A9D     		ldr	r5, [sp, #40]
1684:ff.c          **** 			mode |= FA_CREATE_ALWAYS;
 3702              		.loc 1 1684 9 view .LVU1328
 3703 004a 46F00806 		orr	r6, r6, #8
 3704              	.LVL410:
 3705              		.loc 1 1685 4 is_stmt 1 view .LVU1329
 3706              	.L338:
1686:ff.c          **** 		}
1687:ff.c          **** 		else {						/* Any object is already existing */
1688:ff.c          **** 			if (mode & FA_CREATE_NEW)			/* Cannot create new */
1689:ff.c          **** 				LEAVE_FF(dj.fs, FR_EXIST);
1690:ff.c          **** 			dir = dj.dir;
1691:ff.c          **** 			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
1692:ff.c          **** 				LEAVE_FF(dj.fs, FR_DENIED);
1693:ff.c          **** 			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
1694:ff.c          **** 				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start clust
1695:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
1696:ff.c          **** 				ST_WORD(dir+DIR_FstClusLO, 0);
1697:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
1698:ff.c          **** 				dj.fs->wflag = 1;
1699:ff.c          **** 				ps = dj.fs->winsect;			/* Remove the cluster chain */
1700:ff.c          **** 				if (cl) {
1701:ff.c          **** 					res = remove_chain(dj.fs, cl);
1702:ff.c          **** 					if (res) LEAVE_FF(dj.fs, res);
1703:ff.c          **** 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
1704:ff.c          **** 				}
1705:ff.c          **** 				res = move_window(dj.fs, ps);
1706:ff.c          **** 				if (res != FR_OK) LEAVE_FF(dj.fs, res);
1707:ff.c          **** 			}
1708:ff.c          **** 		}
1709:ff.c          **** 		if (mode & FA_CREATE_ALWAYS) {
 3707              		.loc 1 1709 3 view .LVU1330
 3708              		.loc 1 1709 6 is_stmt 0 view .LVU1331
 3709 004e 3007     		lsls	r0, r6, #28
 3710              	.LVL411:
 3711              		.loc 1 1709 6 view .LVU1332
 3712 0050 10D5     		bpl	.L340
1710:ff.c          **** 			dir[DIR_Attr] = 0;					/* Reset attribute */
 3713              		.loc 1 1710 4 is_stmt 1 view .LVU1333
 3714              		.loc 1 1710 18 is_stmt 0 view .LVU1334
 3715 0052 0023     		movs	r3, #0
 3716 0054 EB72     		strb	r3, [r5, #11]
1711:ff.c          **** 			ps = get_fattime();
 3717              		.loc 1 1711 4 is_stmt 1 view .LVU1335
 3718              		.loc 1 1711 9 is_stmt 0 view .LVU1336
 3719 0056 FFF7FEFF 		bl	get_fattime
 3720              	.LVL412:
1712:ff.c          **** 			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 3721              		.loc 1 1712 4 is_stmt 1 view .LVU1337
1713:ff.c          **** 			dj.fs->wflag = 1;
 3722              		.loc 1 1713 17 is_stmt 0 view .LVU1338
 3723 005a 0122     		movs	r2, #1
1712:ff.c          **** 			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 3724              		.loc 1 1712 4 view .LVU1339
 3725 005c C0F30723 		ubfx	r3, r0, #8, #8
 3726 0060 EB73     		strb	r3, [r5, #15]
 3727 0062 030C     		lsrs	r3, r0, #16
 3728 0064 2B74     		strb	r3, [r5, #16]
 3729              		.loc 1 1713 17 view .LVU1340
 3730 0066 059B     		ldr	r3, [sp, #20]
1712:ff.c          **** 			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 3731              		.loc 1 1712 4 view .LVU1341
 3732 0068 A873     		strb	r0, [r5, #14]
1712:ff.c          **** 			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 3733              		.loc 1 1712 4 is_stmt 1 view .LVU1342
1712:ff.c          **** 			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 3734              		.loc 1 1712 4 view .LVU1343
1712:ff.c          **** 			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 3735              		.loc 1 1712 4 view .LVU1344
 3736 006a 000E     		lsrs	r0, r0, #24
 3737              	.LVL413:
1712:ff.c          **** 			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 3738              		.loc 1 1712 4 is_stmt 0 view .LVU1345
 3739 006c 6874     		strb	r0, [r5, #17]
 3740              		.loc 1 1713 4 is_stmt 1 view .LVU1346
1714:ff.c          **** 			mode |= FA__WRITTEN;				/* Set file changed flag */
 3741              		.loc 1 1714 9 is_stmt 0 view .LVU1347
 3742 006e 46F02006 		orr	r6, r6, #32
 3743              	.LVL414:
1713:ff.c          **** 			dj.fs->wflag = 1;
 3744              		.loc 1 1713 17 view .LVU1348
 3745 0072 1A71     		strb	r2, [r3, #4]
 3746              		.loc 1 1714 4 is_stmt 1 view .LVU1349
 3747              	.LVL415:
 3748              	.L340:
 3749              		.loc 1 1714 4 is_stmt 0 view .LVU1350
 3750              	.LBE112:
1715:ff.c          **** 		}
1716:ff.c          **** 	}
1717:ff.c          **** 	/* Open an existing file */
1718:ff.c          **** 	else {
1719:ff.c          **** #endif /* !_FS_READONLY */
1720:ff.c          **** 		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
1721:ff.c          **** 		dir = dj.dir;
1722:ff.c          **** 		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
1723:ff.c          **** 			LEAVE_FF(dj.fs, FR_NO_FILE);
1724:ff.c          **** #if !_FS_READONLY
1725:ff.c          **** 		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
1726:ff.c          **** 			LEAVE_FF(dj.fs, FR_DENIED);
1727:ff.c          **** 	}
1728:ff.c          **** 	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 3751              		.loc 1 1728 2 is_stmt 1 view .LVU1351
 3752              		.loc 1 1728 19 is_stmt 0 view .LVU1352
 3753 0074 059A     		ldr	r2, [sp, #20]
 3754              		.loc 1 1728 15 view .LVU1353
 3755 0076 136B     		ldr	r3, [r2, #48]
1729:ff.c          **** 	fp->dir_ptr = dj.dir;
1730:ff.c          **** #endif
1731:ff.c          **** 	fp->flag = mode;					/* File access mode */
 3756              		.loc 1 1731 11 view .LVU1354
 3757 0078 A671     		strb	r6, [r4, #6]
1728:ff.c          **** 	fp->dir_ptr = dj.dir;
 3758              		.loc 1 1728 15 view .LVU1355
 3759 007a E361     		str	r3, [r4, #28]
1729:ff.c          **** 	fp->dir_ptr = dj.dir;
 3760              		.loc 1 1729 2 is_stmt 1 view .LVU1356
1729:ff.c          **** 	fp->dir_ptr = dj.dir;
 3761              		.loc 1 1729 14 is_stmt 0 view .LVU1357
 3762 007c 0A9B     		ldr	r3, [sp, #40]
 3763 007e 2362     		str	r3, [r4, #32]
 3764              		.loc 1 1731 2 is_stmt 1 view .LVU1358
1732:ff.c          **** 	fp->org_clust =						/* File start cluster */
 3765              		.loc 1 1732 2 view .LVU1359
1733:ff.c          **** 		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 3766              		.loc 1 1733 11 is_stmt 0 view .LVU1360
 3767 0080 2B7D     		ldrb	r3, [r5, #20]	@ zero_extendqisi2
 3768 0082 697D     		ldrb	r1, [r5, #21]	@ zero_extendqisi2
 3769              		.loc 1 1733 47 view .LVU1361
 3770 0084 E87E     		ldrb	r0, [r5, #27]	@ zero_extendqisi2
 3771              		.loc 1 1733 4 view .LVU1362
 3772 0086 43EA0121 		orr	r1, r3, r1, lsl #8
 3773              		.loc 1 1733 47 view .LVU1363
 3774 008a AB7E     		ldrb	r3, [r5, #26]	@ zero_extendqisi2
 3775 008c 43EA0023 		orr	r3, r3, r0, lsl #8
 3776              		.loc 1 1733 45 view .LVU1364
 3777 0090 43EA0143 		orr	r3, r3, r1, lsl #16
1732:ff.c          **** 	fp->org_clust =						/* File start cluster */
 3778              		.loc 1 1732 16 view .LVU1365
 3779 0094 2361     		str	r3, [r4, #16]
1734:ff.c          **** 	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 3780              		.loc 1 1734 2 is_stmt 1 view .LVU1366
 3781              		.loc 1 1734 14 is_stmt 0 view .LVU1367
 3782 0096 EB69     		ldr	r3, [r5, #28]	@ unaligned
1735:ff.c          **** 	fp->fptr = 0; fp->csect = 255;		/* File pointer */
 3783              		.loc 1 1735 11 view .LVU1368
 3784 0098 0020     		movs	r0, #0
1734:ff.c          **** 	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 3785              		.loc 1 1734 12 view .LVU1369
 3786 009a E360     		str	r3, [r4, #12]
 3787              		.loc 1 1735 2 is_stmt 1 view .LVU1370
 3788              		.loc 1 1735 26 is_stmt 0 view .LVU1371
 3789 009c FF23     		movs	r3, #255
 3790 009e E371     		strb	r3, [r4, #7]
1736:ff.c          **** 	fp->dsect = 0;
1737:ff.c          **** 	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
 3791              		.loc 1 1737 25 view .LVU1372
 3792 00a0 D388     		ldrh	r3, [r2, #6]
1735:ff.c          **** 	fp->fptr = 0; fp->csect = 255;		/* File pointer */
 3793              		.loc 1 1735 11 view .LVU1373
 3794 00a2 A060     		str	r0, [r4, #8]
1735:ff.c          **** 	fp->fptr = 0; fp->csect = 255;		/* File pointer */
 3795              		.loc 1 1735 16 is_stmt 1 view .LVU1374
1736:ff.c          **** 	fp->dsect = 0;
 3796              		.loc 1 1736 2 view .LVU1375
1736:ff.c          **** 	fp->dsect = 0;
 3797              		.loc 1 1736 12 is_stmt 0 view .LVU1376
 3798 00a4 A061     		str	r0, [r4, #24]
 3799              		.loc 1 1737 2 is_stmt 1 view .LVU1377
 3800              		.loc 1 1737 9 is_stmt 0 view .LVU1378
 3801 00a6 2260     		str	r2, [r4]
 3802              		.loc 1 1737 18 is_stmt 1 view .LVU1379
 3803              		.loc 1 1737 25 is_stmt 0 view .LVU1380
 3804 00a8 A380     		strh	r3, [r4, #4]	@ movhi
1738:ff.c          **** 
1739:ff.c          **** 	LEAVE_FF(dj.fs, FR_OK);
 3805              		.loc 1 1739 2 is_stmt 1 view .LVU1381
 3806 00aa 2FE0     		b	.L335
 3807              	.LVL416:
 3808              	.L337:
 3809              	.LBB113:
1688:ff.c          **** 				LEAVE_FF(dj.fs, FR_EXIST);
 3810              		.loc 1 1688 4 view .LVU1382
1688:ff.c          **** 				LEAVE_FF(dj.fs, FR_EXIST);
 3811              		.loc 1 1688 7 is_stmt 0 view .LVU1383
 3812 00ac 7B07     		lsls	r3, r7, #29
 3813 00ae 3DD4     		bmi	.L342
1690:ff.c          **** 			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
 3814              		.loc 1 1690 4 is_stmt 1 view .LVU1384
1690:ff.c          **** 			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
 3815              		.loc 1 1690 8 is_stmt 0 view .LVU1385
 3816 00b0 0A9D     		ldr	r5, [sp, #40]
 3817              	.LVL417:
1691:ff.c          **** 				LEAVE_FF(dj.fs, FR_DENIED);
 3818              		.loc 1 1691 4 is_stmt 1 view .LVU1386
1691:ff.c          **** 				LEAVE_FF(dj.fs, FR_DENIED);
 3819              		.loc 1 1691 7 is_stmt 0 view .LVU1387
 3820 00b2 002D     		cmp	r5, #0
 3821 00b4 38D0     		beq	.L347
1691:ff.c          **** 				LEAVE_FF(dj.fs, FR_DENIED);
 3822              		.loc 1 1691 13 discriminator 1 view .LVU1388
 3823 00b6 EB7A     		ldrb	r3, [r5, #11]	@ zero_extendqisi2
 3824 00b8 13F01103 		ands	r3, r3, #17
 3825 00bc 34D1     		bne	.L347
1693:ff.c          **** 				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start clust
 3826              		.loc 1 1693 4 is_stmt 1 view .LVU1389
1693:ff.c          **** 				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start clust
 3827              		.loc 1 1693 7 is_stmt 0 view .LVU1390
 3828 00be 3F07     		lsls	r7, r7, #28
 3829 00c0 C5D5     		bpl	.L338
1694:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 3830              		.loc 1 1694 5 is_stmt 1 view .LVU1391
1694:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 3831              		.loc 1 1694 18 is_stmt 0 view .LVU1392
 3832 00c2 6F7D     		ldrb	r7, [r5, #21]	@ zero_extendqisi2
 3833 00c4 297D     		ldrb	r1, [r5, #20]	@ zero_extendqisi2
1694:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 3834              		.loc 1 1694 54 view .LVU1393
 3835 00c6 EA7E     		ldrb	r2, [r5, #27]	@ zero_extendqisi2
1695:ff.c          **** 				ST_WORD(dir+DIR_FstClusLO, 0);
 3836              		.loc 1 1695 5 view .LVU1394
 3837 00c8 2B75     		strb	r3, [r5, #20]
 3838 00ca 6B75     		strb	r3, [r5, #21]
1696:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 3839              		.loc 1 1696 5 view .LVU1395
 3840 00cc EB76     		strb	r3, [r5, #27]
1697:ff.c          **** 				dj.fs->wflag = 1;
 3841              		.loc 1 1697 5 view .LVU1396
 3842 00ce 2B77     		strb	r3, [r5, #28]
 3843 00d0 6B77     		strb	r3, [r5, #29]
 3844 00d2 AB77     		strb	r3, [r5, #30]
 3845 00d4 EB77     		strb	r3, [r5, #31]
1694:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 3846              		.loc 1 1694 11 view .LVU1397
 3847 00d6 41EA0721 		orr	r1, r1, r7, lsl #8
1694:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 3848              		.loc 1 1694 54 view .LVU1398
 3849 00da AF7E     		ldrb	r7, [r5, #26]	@ zero_extendqisi2
1696:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 3850              		.loc 1 1696 5 view .LVU1399
 3851 00dc AB76     		strb	r3, [r5, #26]
1698:ff.c          **** 				ps = dj.fs->winsect;			/* Remove the cluster chain */
 3852              		.loc 1 1698 18 view .LVU1400
 3853 00de 0123     		movs	r3, #1
1698:ff.c          **** 				ps = dj.fs->winsect;			/* Remove the cluster chain */
 3854              		.loc 1 1698 7 view .LVU1401
 3855 00e0 0598     		ldr	r0, [sp, #20]
 3856              	.LVL418:
1694:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 3857              		.loc 1 1694 54 view .LVU1402
 3858 00e2 47EA0227 		orr	r7, r7, r2, lsl #8
 3859              	.LVL419:
1695:ff.c          **** 				ST_WORD(dir+DIR_FstClusLO, 0);
 3860              		.loc 1 1695 5 is_stmt 1 view .LVU1403
1695:ff.c          **** 				ST_WORD(dir+DIR_FstClusLO, 0);
 3861              		.loc 1 1695 5 view .LVU1404
1696:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 3862              		.loc 1 1696 5 view .LVU1405
1696:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 3863              		.loc 1 1696 5 view .LVU1406
1697:ff.c          **** 				dj.fs->wflag = 1;
 3864              		.loc 1 1697 5 view .LVU1407
1697:ff.c          **** 				dj.fs->wflag = 1;
 3865              		.loc 1 1697 5 view .LVU1408
1697:ff.c          **** 				dj.fs->wflag = 1;
 3866              		.loc 1 1697 5 view .LVU1409
1697:ff.c          **** 				dj.fs->wflag = 1;
 3867              		.loc 1 1697 5 view .LVU1410
1698:ff.c          **** 				ps = dj.fs->winsect;			/* Remove the cluster chain */
 3868              		.loc 1 1698 5 view .LVU1411
1700:ff.c          **** 					res = remove_chain(dj.fs, cl);
 3869              		.loc 1 1700 8 is_stmt 0 view .LVU1412
 3870 00e6 57EA0147 		orrs	r7, r7, r1, lsl #16
 3871              	.LVL420:
1699:ff.c          **** 				if (cl) {
 3872              		.loc 1 1699 8 view .LVU1413
 3873 00ea D0F83080 		ldr	r8, [r0, #48]
1698:ff.c          **** 				ps = dj.fs->winsect;			/* Remove the cluster chain */
 3874              		.loc 1 1698 18 view .LVU1414
 3875 00ee 0371     		strb	r3, [r0, #4]
1699:ff.c          **** 				if (cl) {
 3876              		.loc 1 1699 5 is_stmt 1 view .LVU1415
 3877              	.LVL421:
1700:ff.c          **** 					res = remove_chain(dj.fs, cl);
 3878              		.loc 1 1700 5 view .LVU1416
1700:ff.c          **** 					res = remove_chain(dj.fs, cl);
 3879              		.loc 1 1700 8 is_stmt 0 view .LVU1417
 3880 00f0 06D0     		beq	.L339
1701:ff.c          **** 					if (res) LEAVE_FF(dj.fs, res);
 3881              		.loc 1 1701 6 is_stmt 1 view .LVU1418
1701:ff.c          **** 					if (res) LEAVE_FF(dj.fs, res);
 3882              		.loc 1 1701 12 is_stmt 0 view .LVU1419
 3883 00f2 3946     		mov	r1, r7
 3884 00f4 FFF7FEFF 		bl	remove_chain
 3885              	.LVL422:
1702:ff.c          **** 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 3886              		.loc 1 1702 6 is_stmt 1 view .LVU1420
1702:ff.c          **** 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 3887              		.loc 1 1702 9 is_stmt 0 view .LVU1421
 3888 00f8 40B9     		cbnz	r0, .L335
1703:ff.c          **** 				}
 3889              		.loc 1 1703 6 is_stmt 1 view .LVU1422
1703:ff.c          **** 				}
 3890              		.loc 1 1703 24 is_stmt 0 view .LVU1423
 3891 00fa 059B     		ldr	r3, [sp, #20]
1703:ff.c          **** 				}
 3892              		.loc 1 1703 29 view .LVU1424
 3893 00fc 013F     		subs	r7, r7, #1
 3894              	.LVL423:
1703:ff.c          **** 				}
 3895              		.loc 1 1703 24 view .LVU1425
 3896 00fe DF60     		str	r7, [r3, #12]
 3897              	.LVL424:
 3898              	.L339:
1705:ff.c          **** 				if (res != FR_OK) LEAVE_FF(dj.fs, res);
 3899              		.loc 1 1705 5 is_stmt 1 view .LVU1426
1705:ff.c          **** 				if (res != FR_OK) LEAVE_FF(dj.fs, res);
 3900              		.loc 1 1705 11 is_stmt 0 view .LVU1427
 3901 0100 4146     		mov	r1, r8
 3902 0102 0598     		ldr	r0, [sp, #20]
 3903 0104 FFF7FEFF 		bl	move_window
 3904              	.LVL425:
1706:ff.c          **** 			}
 3905              		.loc 1 1706 5 is_stmt 1 view .LVU1428
1706:ff.c          **** 			}
 3906              		.loc 1 1706 8 is_stmt 0 view .LVU1429
 3907 0108 0028     		cmp	r0, #0
 3908 010a A0D0     		beq	.L338
 3909              	.LVL426:
 3910              	.L335:
1706:ff.c          **** 			}
 3911              		.loc 1 1706 8 view .LVU1430
 3912              	.LBE113:
1740:ff.c          **** }
 3913              		.loc 1 1740 1 view .LVU1431
 3914 010c 0CB0     		add	sp, sp, #48
 3915              		.cfi_remember_state
 3916              		.cfi_def_cfa_offset 24
 3917              		@ sp needed
 3918 010e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3919              	.LVL427:
 3920              	.L336:
 3921              		.cfi_restore_state
1720:ff.c          **** 		dir = dj.dir;
 3922              		.loc 1 1720 3 is_stmt 1 view .LVU1432
1720:ff.c          **** 		dir = dj.dir;
 3923              		.loc 1 1720 6 is_stmt 0 view .LVU1433
 3924 0112 0028     		cmp	r0, #0
 3925 0114 FAD1     		bne	.L335
1721:ff.c          **** 		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
 3926              		.loc 1 1721 3 is_stmt 1 view .LVU1434
1721:ff.c          **** 		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
 3927              		.loc 1 1721 7 is_stmt 0 view .LVU1435
 3928 0116 0A9D     		ldr	r5, [sp, #40]
 3929              	.LVL428:
1722:ff.c          **** 			LEAVE_FF(dj.fs, FR_NO_FILE);
 3930              		.loc 1 1722 3 is_stmt 1 view .LVU1436
1722:ff.c          **** 			LEAVE_FF(dj.fs, FR_NO_FILE);
 3931              		.loc 1 1722 6 is_stmt 0 view .LVU1437
 3932 0118 55B1     		cbz	r5, .L346
1722:ff.c          **** 			LEAVE_FF(dj.fs, FR_NO_FILE);
 3933              		.loc 1 1722 19 discriminator 1 view .LVU1438
 3934 011a EB7A     		ldrb	r3, [r5, #11]	@ zero_extendqisi2
1722:ff.c          **** 			LEAVE_FF(dj.fs, FR_NO_FILE);
 3935              		.loc 1 1722 12 discriminator 1 view .LVU1439
 3936 011c D906     		lsls	r1, r3, #27
 3937 011e 07D4     		bmi	.L346
1725:ff.c          **** 			LEAVE_FF(dj.fs, FR_DENIED);
 3938              		.loc 1 1725 3 is_stmt 1 view .LVU1440
1725:ff.c          **** 			LEAVE_FF(dj.fs, FR_DENIED);
 3939              		.loc 1 1725 6 is_stmt 0 view .LVU1441
 3940 0120 BA07     		lsls	r2, r7, #30
 3941 0122 A7D5     		bpl	.L340
1725:ff.c          **** 			LEAVE_FF(dj.fs, FR_DENIED);
 3942              		.loc 1 1725 25 discriminator 1 view .LVU1442
 3943 0124 DB07     		lsls	r3, r3, #31
 3944 0126 A5D5     		bpl	.L340
 3945              	.L347:
 3946              	.LBB114:
1692:ff.c          **** 			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
 3947              		.loc 1 1692 5 view .LVU1443
 3948 0128 0720     		movs	r0, #7
 3949              	.LVL429:
1692:ff.c          **** 			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
 3950              		.loc 1 1692 5 view .LVU1444
 3951 012a EFE7     		b	.L335
 3952              	.LVL430:
 3953              	.L342:
1689:ff.c          **** 			dir = dj.dir;
 3954              		.loc 1 1689 5 view .LVU1445
 3955 012c 0820     		movs	r0, #8
 3956              	.LVL431:
1689:ff.c          **** 			dir = dj.dir;
 3957              		.loc 1 1689 5 view .LVU1446
 3958 012e EDE7     		b	.L335
 3959              	.LVL432:
 3960              	.L346:
1689:ff.c          **** 			dir = dj.dir;
 3961              		.loc 1 1689 5 view .LVU1447
 3962              	.LBE114:
1723:ff.c          **** #if !_FS_READONLY
 3963              		.loc 1 1723 4 view .LVU1448
 3964 0130 0420     		movs	r0, #4
 3965              	.LVL433:
1723:ff.c          **** #if !_FS_READONLY
 3966              		.loc 1 1723 4 view .LVU1449
 3967 0132 EBE7     		b	.L335
 3968              		.cfi_endproc
 3969              	.LFE53:
 3971              		.section	.text.f_read,"ax",%progbits
 3972              		.align	1
 3973              		.global	f_read
 3974              		.syntax unified
 3975              		.thumb
 3976              		.thumb_func
 3977              		.fpu softvfp
 3979              	f_read:
 3980              	.LVL434:
 3981              	.LFB54:
1741:ff.c          **** 
1742:ff.c          **** 
1743:ff.c          **** 
1744:ff.c          **** 
1745:ff.c          **** /*-----------------------------------------------------------------------*/
1746:ff.c          **** /* Read File                                                             */
1747:ff.c          **** /*-----------------------------------------------------------------------*/
1748:ff.c          **** 
1749:ff.c          **** FRESULT f_read (
1750:ff.c          **** 	FIL *fp, 		/* Pointer to the file object */
1751:ff.c          **** 	void *buff,		/* Pointer to data buffer */
1752:ff.c          **** 	UINT btr,		/* Number of bytes to read */
1753:ff.c          **** 	UINT *br		/* Pointer to number of bytes read */
1754:ff.c          **** )
1755:ff.c          **** {
 3982              		.loc 1 1755 1 is_stmt 1 view -0
 3983              		.cfi_startproc
 3984              		@ args = 0, pretend = 0, frame = 16
 3985              		@ frame_needed = 0, uses_anonymous_args = 0
1756:ff.c          **** 	FRESULT res;
 3986              		.loc 1 1756 2 view .LVU1451
1757:ff.c          **** 	DWORD clst, sect, remain;
 3987              		.loc 1 1757 2 view .LVU1452
1758:ff.c          **** 	UINT rcnt, cc;
 3988              		.loc 1 1758 2 view .LVU1453
1759:ff.c          **** 	BYTE *rbuff = buff;
 3989              		.loc 1 1759 2 view .LVU1454
1755:ff.c          **** 	FRESULT res;
 3990              		.loc 1 1755 1 is_stmt 0 view .LVU1455
 3991 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3992              		.cfi_def_cfa_offset 36
 3993              		.cfi_offset 4, -36
 3994              		.cfi_offset 5, -32
 3995              		.cfi_offset 6, -28
 3996              		.cfi_offset 7, -24
 3997              		.cfi_offset 8, -20
 3998              		.cfi_offset 9, -16
 3999              		.cfi_offset 10, -12
 4000              		.cfi_offset 11, -8
 4001              		.cfi_offset 14, -4
 4002 0004 85B0     		sub	sp, sp, #20
 4003              		.cfi_def_cfa_offset 56
1755:ff.c          **** 	FRESULT res;
 4004              		.loc 1 1755 1 view .LVU1456
 4005 0006 0293     		str	r3, [sp, #8]
1760:ff.c          **** 
1761:ff.c          **** 
1762:ff.c          **** 	*br = 0;
 4006              		.loc 1 1762 6 view .LVU1457
 4007 0008 0023     		movs	r3, #0
 4008              	.LVL435:
1755:ff.c          **** 	FRESULT res;
 4009              		.loc 1 1755 1 view .LVU1458
 4010 000a 1546     		mov	r5, r2
 4011              		.loc 1 1762 6 view .LVU1459
 4012 000c 029A     		ldr	r2, [sp, #8]
 4013              	.LVL436:
1755:ff.c          **** 	FRESULT res;
 4014              		.loc 1 1755 1 view .LVU1460
 4015 000e 0446     		mov	r4, r0
 4016 0010 8946     		mov	r9, r1
 4017              	.LVL437:
 4018              		.loc 1 1762 2 is_stmt 1 view .LVU1461
 4019              		.loc 1 1762 6 is_stmt 0 view .LVU1462
 4020 0012 1360     		str	r3, [r2]
1763:ff.c          **** 
1764:ff.c          **** 	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 4021              		.loc 1 1764 2 is_stmt 1 view .LVU1463
 4022              		.loc 1 1764 8 is_stmt 0 view .LVU1464
 4023 0014 8188     		ldrh	r1, [r0, #4]
 4024              	.LVL438:
 4025              		.loc 1 1764 8 view .LVU1465
 4026 0016 0068     		ldr	r0, [r0]
 4027              	.LVL439:
 4028              		.loc 1 1764 8 view .LVU1466
 4029 0018 FFF7FEFF 		bl	validate
 4030              	.LVL440:
1765:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 4031              		.loc 1 1765 2 is_stmt 1 view .LVU1467
 4032              		.loc 1 1765 5 is_stmt 0 view .LVU1468
 4033 001c 0646     		mov	r6, r0
 4034 001e 0028     		cmp	r0, #0
 4035 0020 58D1     		bne	.L361
1766:ff.c          **** 	if (fp->flag & FA__ERROR)						/* Check abort flag */
 4036              		.loc 1 1766 2 is_stmt 1 view .LVU1469
 4037              		.loc 1 1766 5 is_stmt 0 view .LVU1470
 4038 0022 94F90620 		ldrsb	r2, [r4, #6]
 4039              		.loc 1 1766 8 view .LVU1471
 4040 0026 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4041              		.loc 1 1766 5 view .LVU1472
 4042 0028 002A     		cmp	r2, #0
 4043 002a 21DB     		blt	.L379
1767:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
1768:ff.c          **** 	if (!(fp->flag & FA_READ)) 						/* Check access mode */
 4044              		.loc 1 1768 2 is_stmt 1 view .LVU1473
 4045              		.loc 1 1768 5 is_stmt 0 view .LVU1474
 4046 002c 13F00103 		ands	r3, r3, #1
 4047 0030 0193     		str	r3, [sp, #4]
 4048 0032 00F0A180 		beq	.L380
 4049              	.LVL441:
 4050              	.LBB117:
 4051              	.LBI117:
1749:ff.c          **** 	FIL *fp, 		/* Pointer to the file object */
 4052              		.loc 1 1749 9 is_stmt 1 view .LVU1475
 4053              	.LBB118:
1769:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
1770:ff.c          **** 	remain = fp->fsize - fp->fptr;
 4054              		.loc 1 1770 2 view .LVU1476
1771:ff.c          **** 	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
 4055              		.loc 1 1771 2 view .LVU1477
1770:ff.c          **** 	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
 4056              		.loc 1 1770 9 is_stmt 0 view .LVU1478
 4057 0036 D4E90227 		ldrd	r2, r7, [r4, #8]
 4058 003a BF1A     		subs	r7, r7, r2
 4059              	.LVL442:
1770:ff.c          **** 	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
 4060              		.loc 1 1770 9 view .LVU1479
 4061 003c AF42     		cmp	r7, r5
 4062 003e 28BF     		it	cs
 4063 0040 2F46     		movcs	r7, r5
 4064              	.LVL443:
1772:ff.c          **** 
1773:ff.c          **** 	for ( ;  btr;									/* Repeat until all data transferred */
1774:ff.c          **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
1775:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
1776:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
1777:ff.c          **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
1778:ff.c          **** 					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
1779:ff.c          **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
1780:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
1781:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
1782:ff.c          **** 				fp->csect = 0;						/* Reset sector offset in the cluster */
1783:ff.c          **** 			}
1784:ff.c          **** 			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
1785:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
1786:ff.c          **** 			sect += fp->csect;
1787:ff.c          **** 			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
1788:ff.c          **** 			if (cc) {								/* Read maximum contiguous sectors directly */
1789:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
1790:ff.c          **** 					cc = fp->fs->csize - fp->csect;
1791:ff.c          **** 				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
1792:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
1793:ff.c          **** #if !_FS_READONLY && _FS_MINIMIZE <= 2
1794:ff.c          **** #if _FS_TINY
1795:ff.c          **** 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)		/* Replace one of the read sectors with cach
1796:ff.c          **** 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
1797:ff.c          **** #else
1798:ff.c          **** 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with ca
1799:ff.c          **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
1800:ff.c          **** #endif
1801:ff.c          **** #endif
1802:ff.c          **** 				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
1803:ff.c          **** 				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
1804:ff.c          **** 				continue;
1805:ff.c          **** 			}
1806:ff.c          **** #if !_FS_TINY
1807:ff.c          **** #if !_FS_READONLY
1808:ff.c          **** 			if (fp->flag & FA__DIRTY) {			/* Write sector I/O buffer if needed */
1809:ff.c          **** 				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
1810:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
1811:ff.c          **** 				fp->flag &= ~FA__DIRTY;
1812:ff.c          **** 			}
1813:ff.c          **** #endif
1814:ff.c          **** 			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
1815:ff.c          **** 				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 4065              		.loc 1 1815 36 view .LVU1480
 4066 0042 04F1240B 		add	fp, r4, #36
 4067              	.LVL444:
 4068              	.L362:
1773:ff.c          **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 4069              		.loc 1 1773 11 is_stmt 1 view .LVU1481
1773:ff.c          **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 4070              		.loc 1 1773 2 is_stmt 0 view .LVU1482
 4071 0046 002F     		cmp	r7, #0
 4072 0048 44D0     		beq	.L361
1775:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 4073              		.loc 1 1775 3 is_stmt 1 view .LVU1483
1775:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 4074              		.loc 1 1775 10 is_stmt 0 view .LVU1484
 4075 004a A368     		ldr	r3, [r4, #8]
1775:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 4076              		.loc 1 1775 17 view .LVU1485
 4077 004c C3F30802 		ubfx	r2, r3, #0, #9
1775:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 4078              		.loc 1 1775 6 view .LVU1486
 4079 0050 002A     		cmp	r2, #0
 4080 0052 40F08280 		bne	.L363
1776:ff.c          **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
 4081              		.loc 1 1776 4 is_stmt 1 view .LVU1487
1776:ff.c          **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
 4082              		.loc 1 1776 23 is_stmt 0 view .LVU1488
 4083 0056 2068     		ldr	r0, [r4]
1776:ff.c          **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
 4084              		.loc 1 1776 7 view .LVU1489
 4085 0058 E179     		ldrb	r1, [r4, #7]	@ zero_extendqisi2
 4086 005a 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 4087 005c 9142     		cmp	r1, r2
 4088 005e 14D3     		bcc	.L364
1777:ff.c          **** 					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
 4089              		.loc 1 1777 5 is_stmt 1 view .LVU1490
1778:ff.c          **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 4090              		.loc 1 1778 20 is_stmt 0 view .LVU1491
 4091 0060 43B9     		cbnz	r3, .L365
 4092 0062 2069     		ldr	r0, [r4, #16]
 4093              	.L366:
 4094              	.LVL445:
1779:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4095              		.loc 1 1779 5 is_stmt 1 view .LVU1492
1779:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4096              		.loc 1 1779 8 is_stmt 0 view .LVU1493
 4097 0064 0128     		cmp	r0, #1
 4098 0066 09D8     		bhi	.L367
 4099              	.LVL446:
 4100              	.L392:
1785:ff.c          **** 			sect += fp->csect;
 4101              		.loc 1 1785 15 is_stmt 1 view .LVU1494
 4102 0068 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4103 006a 63F07F03 		orn	r3, r3, #127
 4104 006e A371     		strb	r3, [r4, #6]
1785:ff.c          **** 			sect += fp->csect;
 4105              		.loc 1 1785 15 view .LVU1495
 4106              	.LVL447:
 4107              	.L379:
1785:ff.c          **** 			sect += fp->csect;
 4108              		.loc 1 1785 15 is_stmt 0 view .LVU1496
 4109              	.LBE118:
 4110              	.LBE117:
1767:ff.c          **** 	if (!(fp->flag & FA_READ)) 						/* Check access mode */
 4111              		.loc 1 1767 3 view .LVU1497
 4112 0070 0226     		movs	r6, #2
 4113 0072 2FE0     		b	.L361
 4114              	.LVL448:
 4115              	.L365:
 4116              	.LBB121:
 4117              	.LBB119:
1778:ff.c          **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 4118              		.loc 1 1778 22 view .LVU1498
 4119 0074 6169     		ldr	r1, [r4, #20]
 4120 0076 FFF7FEFF 		bl	get_fat
 4121              	.LVL449:
 4122 007a F3E7     		b	.L366
 4123              	.LVL450:
 4124              	.L367:
1779:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4125              		.loc 1 1779 45 is_stmt 1 view .LVU1499
1780:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
 4126              		.loc 1 1780 5 view .LVU1500
1780:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
 4127              		.loc 1 1780 8 is_stmt 0 view .LVU1501
 4128 007c 411C     		adds	r1, r0, #1
 4129 007e 01D1     		bne	.L368
 4130              	.LVL451:
 4131              	.L390:
1816:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4132              		.loc 1 1816 6 is_stmt 1 view .LVU1502
 4133 0080 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4134 0082 23E0     		b	.L391
 4135              	.LVL452:
 4136              	.L368:
1780:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
 4137              		.loc 1 1780 55 view .LVU1503
1781:ff.c          **** 				fp->csect = 0;						/* Reset sector offset in the cluster */
 4138              		.loc 1 1781 5 view .LVU1504
1782:ff.c          **** 			}
 4139              		.loc 1 1782 15 is_stmt 0 view .LVU1505
 4140 0084 0023     		movs	r3, #0
1781:ff.c          **** 				fp->csect = 0;						/* Reset sector offset in the cluster */
 4141              		.loc 1 1781 20 view .LVU1506
 4142 0086 6061     		str	r0, [r4, #20]
1782:ff.c          **** 			}
 4143              		.loc 1 1782 5 is_stmt 1 view .LVU1507
1782:ff.c          **** 			}
 4144              		.loc 1 1782 15 is_stmt 0 view .LVU1508
 4145 0088 E371     		strb	r3, [r4, #7]
 4146              	.LVL453:
 4147              	.L364:
1784:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 4148              		.loc 1 1784 4 is_stmt 1 view .LVU1509
1784:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 4149              		.loc 1 1784 11 is_stmt 0 view .LVU1510
 4150 008a D4F800A0 		ldr	r10, [r4]
 4151 008e 6169     		ldr	r1, [r4, #20]
 4152 0090 5046     		mov	r0, r10
 4153 0092 FFF7FEFF 		bl	clust2sect
 4154              	.LVL454:
1785:ff.c          **** 			sect += fp->csect;
 4155              		.loc 1 1785 4 is_stmt 1 view .LVU1511
1785:ff.c          **** 			sect += fp->csect;
 4156              		.loc 1 1785 7 is_stmt 0 view .LVU1512
 4157 0096 0028     		cmp	r0, #0
 4158 0098 E6D0     		beq	.L392
1785:ff.c          **** 			sect += fp->csect;
 4159              		.loc 1 1785 40 is_stmt 1 view .LVU1513
1786:ff.c          **** 			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
 4160              		.loc 1 1786 4 view .LVU1514
1786:ff.c          **** 			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
 4161              		.loc 1 1786 14 is_stmt 0 view .LVU1515
 4162 009a E379     		ldrb	r3, [r4, #7]	@ zero_extendqisi2
1788:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 4163              		.loc 1 1788 7 view .LVU1516
 4164 009c B7F5007F 		cmp	r7, #512
1786:ff.c          **** 			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
 4165              		.loc 1 1786 9 view .LVU1517
 4166 00a0 00EB0308 		add	r8, r0, r3
 4167              	.LVL455:
1787:ff.c          **** 			if (cc) {								/* Read maximum contiguous sectors directly */
 4168              		.loc 1 1787 4 is_stmt 1 view .LVU1518
1788:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 4169              		.loc 1 1788 4 view .LVU1519
1788:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 4170              		.loc 1 1788 7 is_stmt 0 view .LVU1520
 4171 00a4 38D3     		bcc	.L370
1789:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4172              		.loc 1 1789 32 view .LVU1521
 4173 00a6 9AF80220 		ldrb	r2, [r10, #2]	@ zero_extendqisi2
1789:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4174              		.loc 1 1789 19 view .LVU1522
 4175 00aa 03EB5721 		add	r1, r3, r7, lsr #9
1789:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4176              		.loc 1 1789 8 view .LVU1523
 4177 00ae 9142     		cmp	r1, r2
1787:ff.c          **** 			if (cc) {								/* Read maximum contiguous sectors directly */
 4178              		.loc 1 1787 7 view .LVU1524
 4179 00b0 4FEA5725 		lsr	r5, r7, #9
 4180              	.LVL456:
1789:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4181              		.loc 1 1789 5 is_stmt 1 view .LVU1525
1790:ff.c          **** 				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
 4182              		.loc 1 1790 6 view .LVU1526
1790:ff.c          **** 				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
 4183              		.loc 1 1790 25 is_stmt 0 view .LVU1527
 4184 00b4 88BF     		it	hi
 4185 00b6 D51A     		subhi	r5, r2, r3
 4186              	.LVL457:
1791:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4187              		.loc 1 1791 5 is_stmt 1 view .LVU1528
1791:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4188              		.loc 1 1791 9 is_stmt 0 view .LVU1529
 4189 00b8 EBB2     		uxtb	r3, r5
 4190 00ba 4246     		mov	r2, r8
 4191 00bc 4946     		mov	r1, r9
 4192 00be 9AF80100 		ldrb	r0, [r10, #1]	@ zero_extendqisi2
 4193 00c2 0393     		str	r3, [sp, #12]
 4194 00c4 FFF7FEFF 		bl	disk_read
 4195              	.LVL458:
 4196 00c8 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
1791:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4197              		.loc 1 1791 8 view .LVU1530
 4198 00ca 38B1     		cbz	r0, .L372
 4199              	.LVL459:
 4200              	.L391:
 4201              		.loc 1 1816 6 view .LVU1531
 4202 00cc 63F07F03 		orn	r3, r3, #127
 4203 00d0 019E     		ldr	r6, [sp, #4]
 4204 00d2 A371     		strb	r3, [r4, #6]
 4205              		.loc 1 1816 6 is_stmt 1 view .LVU1532
 4206              	.LVL460:
 4207              	.L361:
 4208              		.loc 1 1816 6 is_stmt 0 view .LVU1533
 4209              	.LBE119:
 4210              	.LBE121:
1817:ff.c          **** 			}
1818:ff.c          **** #endif
1819:ff.c          **** 			fp->dsect = sect;
1820:ff.c          **** 			fp->csect++;							/* Next sector address in the cluster */
1821:ff.c          **** 		}
1822:ff.c          **** 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
1823:ff.c          **** 		if (rcnt > btr) rcnt = btr;
1824:ff.c          **** #if _FS_TINY
1825:ff.c          **** 		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
1826:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
1827:ff.c          **** 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
1828:ff.c          **** #else
1829:ff.c          **** 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
1830:ff.c          **** #endif
1831:ff.c          **** 	}
1832:ff.c          **** 
1833:ff.c          **** 	LEAVE_FF(fp->fs, FR_OK);
1834:ff.c          **** }
 4211              		.loc 1 1834 1 view .LVU1534
 4212 00d4 3046     		mov	r0, r6
 4213 00d6 05B0     		add	sp, sp, #20
 4214              		.cfi_remember_state
 4215              		.cfi_def_cfa_offset 36
 4216              		@ sp needed
 4217 00d8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4218              	.LVL461:
 4219              	.L372:
 4220              		.cfi_restore_state
 4221              	.LBB122:
 4222              	.LBB120:
1792:ff.c          **** #if !_FS_READONLY && _FS_MINIMIZE <= 2
 4223              		.loc 1 1792 32 is_stmt 1 view .LVU1535
1798:ff.c          **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 4224              		.loc 1 1798 5 view .LVU1536
1798:ff.c          **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 4225              		.loc 1 1798 8 is_stmt 0 view .LVU1537
 4226 00dc 5A06     		lsls	r2, r3, #25
 4227 00de 0BD5     		bpl	.L373
1798:ff.c          **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 4228              		.loc 1 1798 45 view .LVU1538
 4229 00e0 A069     		ldr	r0, [r4, #24]
 4230 00e2 A0EB0800 		sub	r0, r0, r8
1798:ff.c          **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 4231              		.loc 1 1798 32 view .LVU1539
 4232 00e6 8542     		cmp	r5, r0
 4233 00e8 06D9     		bls	.L373
1799:ff.c          **** #endif
 4234              		.loc 1 1799 6 is_stmt 1 view .LVU1540
 4235 00ea 4FF40072 		mov	r2, #512
 4236 00ee 5946     		mov	r1, fp
 4237 00f0 09EB4020 		add	r0, r9, r0, lsl #9
 4238 00f4 FFF7FEFF 		bl	mem_cpy
 4239              	.LVL462:
 4240              	.L373:
1802:ff.c          **** 				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 4241              		.loc 1 1802 5 view .LVU1541
1802:ff.c          **** 				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 4242              		.loc 1 1802 15 is_stmt 0 view .LVU1542
 4243 00f8 E379     		ldrb	r3, [r4, #7]	@ zero_extendqisi2
 4244 00fa 039A     		ldr	r2, [sp, #12]
1803:ff.c          **** 				continue;
 4245              		.loc 1 1803 10 view .LVU1543
 4246 00fc 6D02     		lsls	r5, r5, #9
 4247              	.LVL463:
1802:ff.c          **** 				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 4248              		.loc 1 1802 15 view .LVU1544
 4249 00fe 1A44     		add	r2, r2, r3
 4250 0100 E271     		strb	r2, [r4, #7]
1803:ff.c          **** 				continue;
 4251              		.loc 1 1803 5 is_stmt 1 view .LVU1545
 4252              	.LVL464:
1804:ff.c          **** 			}
 4253              		.loc 1 1804 5 view .LVU1546
 4254              	.L374:
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4255              		.loc 1 1774 3 view .LVU1547
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4256              		.loc 1 1774 27 is_stmt 0 view .LVU1548
 4257 0102 A368     		ldr	r3, [r4, #8]
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4258              		.loc 1 1774 40 view .LVU1549
 4259 0104 029A     		ldr	r2, [sp, #8]
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4260              		.loc 1 1774 27 view .LVU1550
 4261 0106 2B44     		add	r3, r3, r5
 4262 0108 A360     		str	r3, [r4, #8]
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4263              		.loc 1 1774 40 view .LVU1551
 4264 010a 029B     		ldr	r3, [sp, #8]
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4265              		.loc 1 1774 9 view .LVU1552
 4266 010c A944     		add	r9, r9, r5
 4267              	.LVL465:
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4268              		.loc 1 1774 40 view .LVU1553
 4269 010e 1B68     		ldr	r3, [r3]
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4270              		.loc 1 1774 53 view .LVU1554
 4271 0110 7F1B     		subs	r7, r7, r5
 4272              	.LVL466:
1774:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4273              		.loc 1 1774 40 view .LVU1555
 4274 0112 2B44     		add	r3, r3, r5
 4275 0114 1360     		str	r3, [r2]
 4276 0116 96E7     		b	.L362
 4277              	.LVL467:
 4278              	.L370:
1808:ff.c          **** 				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 4279              		.loc 1 1808 4 is_stmt 1 view .LVU1556
1808:ff.c          **** 				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 4280              		.loc 1 1808 7 is_stmt 0 view .LVU1557
 4281 0118 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4282 011a 5B06     		lsls	r3, r3, #25
 4283 011c 0CD5     		bpl	.L375
1809:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4284              		.loc 1 1809 5 is_stmt 1 view .LVU1558
1809:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4285              		.loc 1 1809 9 is_stmt 0 view .LVU1559
 4286 011e 0123     		movs	r3, #1
 4287 0120 5946     		mov	r1, fp
 4288 0122 A269     		ldr	r2, [r4, #24]
 4289 0124 9AF80100 		ldrb	r0, [r10, #1]	@ zero_extendqisi2
 4290 0128 FFF7FEFF 		bl	disk_write
 4291              	.LVL468:
 4292 012c A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
1809:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4293              		.loc 1 1809 8 view .LVU1560
 4294 012e 0028     		cmp	r0, #0
 4295 0130 CCD1     		bne	.L391
1810:ff.c          **** 				fp->flag &= ~FA__DIRTY;
 4296              		.loc 1 1810 32 is_stmt 1 view .LVU1561
1811:ff.c          **** 			}
 4297              		.loc 1 1811 5 view .LVU1562
1811:ff.c          **** 			}
 4298              		.loc 1 1811 14 is_stmt 0 view .LVU1563
 4299 0132 23F04003 		bic	r3, r3, #64
 4300 0136 A371     		strb	r3, [r4, #6]
 4301              	.L375:
1814:ff.c          **** 				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 4302              		.loc 1 1814 4 is_stmt 1 view .LVU1564
1814:ff.c          **** 				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 4303              		.loc 1 1814 7 is_stmt 0 view .LVU1565
 4304 0138 A369     		ldr	r3, [r4, #24]
 4305 013a 9845     		cmp	r8, r3
 4306 013c 08D0     		beq	.L377
1815:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4307              		.loc 1 1815 5 is_stmt 1 view .LVU1566
1815:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4308              		.loc 1 1815 9 is_stmt 0 view .LVU1567
 4309 013e 2068     		ldr	r0, [r4]
 4310 0140 0123     		movs	r3, #1
 4311 0142 4246     		mov	r2, r8
 4312 0144 5946     		mov	r1, fp
 4313 0146 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 4314 0148 FFF7FEFF 		bl	disk_read
 4315              	.LVL469:
1815:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4316              		.loc 1 1815 8 view .LVU1568
 4317 014c 0028     		cmp	r0, #0
 4318 014e 97D1     		bne	.L390
 4319              	.L377:
1816:ff.c          **** 			}
 4320              		.loc 1 1816 32 is_stmt 1 view .LVU1569
1819:ff.c          **** 			fp->csect++;							/* Next sector address in the cluster */
 4321              		.loc 1 1819 4 view .LVU1570
1820:ff.c          **** 		}
 4322              		.loc 1 1820 13 is_stmt 0 view .LVU1571
 4323 0150 E379     		ldrb	r3, [r4, #7]	@ zero_extendqisi2
1819:ff.c          **** 			fp->csect++;							/* Next sector address in the cluster */
 4324              		.loc 1 1819 14 view .LVU1572
 4325 0152 C4F81880 		str	r8, [r4, #24]
1820:ff.c          **** 		}
 4326              		.loc 1 1820 4 is_stmt 1 view .LVU1573
1820:ff.c          **** 		}
 4327              		.loc 1 1820 13 is_stmt 0 view .LVU1574
 4328 0156 0133     		adds	r3, r3, #1
 4329 0158 E371     		strb	r3, [r4, #7]
 4330              	.LVL470:
 4331              	.L363:
1822:ff.c          **** 		if (rcnt > btr) rcnt = btr;
 4332              		.loc 1 1822 3 is_stmt 1 view .LVU1575
1822:ff.c          **** 		if (rcnt > btr) rcnt = btr;
 4333              		.loc 1 1822 33 is_stmt 0 view .LVU1576
 4334 015a A168     		ldr	r1, [r4, #8]
1829:ff.c          **** #endif
 4335              		.loc 1 1829 3 view .LVU1577
 4336 015c 4846     		mov	r0, r9
1822:ff.c          **** 		if (rcnt > btr) rcnt = btr;
 4337              		.loc 1 1822 33 view .LVU1578
 4338 015e C1F30801 		ubfx	r1, r1, #0, #9
1822:ff.c          **** 		if (rcnt > btr) rcnt = btr;
 4339              		.loc 1 1822 8 view .LVU1579
 4340 0162 C1F50075 		rsb	r5, r1, #512
 4341              	.LVL471:
1823:ff.c          **** #if _FS_TINY
 4342              		.loc 1 1823 3 is_stmt 1 view .LVU1580
 4343 0166 BD42     		cmp	r5, r7
 4344 0168 28BF     		it	cs
 4345 016a 3D46     		movcs	r5, r7
 4346              	.LVL472:
1829:ff.c          **** #endif
 4347              		.loc 1 1829 3 view .LVU1581
1829:ff.c          **** #endif
 4348              		.loc 1 1829 18 is_stmt 0 view .LVU1582
 4349 016c 2431     		adds	r1, r1, #36
1829:ff.c          **** #endif
 4350              		.loc 1 1829 3 view .LVU1583
 4351 016e 2A46     		mov	r2, r5
 4352 0170 2144     		add	r1, r1, r4
 4353 0172 FFF7FEFF 		bl	mem_cpy
 4354              	.LVL473:
 4355 0176 C4E7     		b	.L374
 4356              	.LVL474:
 4357              	.L380:
1829:ff.c          **** #endif
 4358              		.loc 1 1829 3 view .LVU1584
 4359              	.LBE120:
 4360              	.LBE122:
1769:ff.c          **** 	remain = fp->fsize - fp->fptr;
 4361              		.loc 1 1769 3 view .LVU1585
 4362 0178 0726     		movs	r6, #7
 4363 017a ABE7     		b	.L361
 4364              		.cfi_endproc
 4365              	.LFE54:
 4367              		.section	.text.f_write,"ax",%progbits
 4368              		.align	1
 4369              		.global	f_write
 4370              		.syntax unified
 4371              		.thumb
 4372              		.thumb_func
 4373              		.fpu softvfp
 4375              	f_write:
 4376              	.LVL475:
 4377              	.LFB55:
1835:ff.c          **** 
1836:ff.c          **** 
1837:ff.c          **** 
1838:ff.c          **** 
1839:ff.c          **** #if !_FS_READONLY
1840:ff.c          **** /*-----------------------------------------------------------------------*/
1841:ff.c          **** /* Write File                                                            */
1842:ff.c          **** /*-----------------------------------------------------------------------*/
1843:ff.c          **** 
1844:ff.c          **** FRESULT f_write (
1845:ff.c          **** 	FIL *fp,			/* Pointer to the file object */
1846:ff.c          **** 	const void *buff,	/* Pointer to the data to be written */
1847:ff.c          **** 	UINT btw,			/* Number of bytes to write */
1848:ff.c          **** 	UINT *bw			/* Pointer to number of bytes written */
1849:ff.c          **** )
1850:ff.c          **** {
 4378              		.loc 1 1850 1 is_stmt 1 view -0
 4379              		.cfi_startproc
 4380              		@ args = 0, pretend = 0, frame = 8
 4381              		@ frame_needed = 0, uses_anonymous_args = 0
1851:ff.c          **** 	FRESULT res;
 4382              		.loc 1 1851 2 view .LVU1587
1852:ff.c          **** 	DWORD clst, sect;
 4383              		.loc 1 1852 2 view .LVU1588
1853:ff.c          **** 	UINT wcnt, cc;
 4384              		.loc 1 1853 2 view .LVU1589
1854:ff.c          **** 	const BYTE *wbuff = buff;
 4385              		.loc 1 1854 2 view .LVU1590
1850:ff.c          **** 	FRESULT res;
 4386              		.loc 1 1850 1 is_stmt 0 view .LVU1591
 4387 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4388              		.cfi_def_cfa_offset 48
 4389              		.cfi_offset 4, -36
 4390              		.cfi_offset 5, -32
 4391              		.cfi_offset 6, -28
 4392              		.cfi_offset 7, -24
 4393              		.cfi_offset 8, -20
 4394              		.cfi_offset 9, -16
 4395              		.cfi_offset 10, -12
 4396              		.cfi_offset 11, -8
 4397              		.cfi_offset 14, -4
1850:ff.c          **** 	FRESULT res;
 4398              		.loc 1 1850 1 view .LVU1592
 4399 0004 9946     		mov	r9, r3
1855:ff.c          **** 
1856:ff.c          **** 
1857:ff.c          **** 	*bw = 0;
 4400              		.loc 1 1857 6 view .LVU1593
 4401 0006 0023     		movs	r3, #0
 4402              	.LVL476:
1850:ff.c          **** 	FRESULT res;
 4403              		.loc 1 1850 1 view .LVU1594
 4404 0008 0446     		mov	r4, r0
 4405 000a 8846     		mov	r8, r1
 4406              	.LVL477:
 4407              		.loc 1 1857 2 is_stmt 1 view .LVU1595
 4408              		.loc 1 1857 6 is_stmt 0 view .LVU1596
 4409 000c C9F80030 		str	r3, [r9]
1858:ff.c          **** 
1859:ff.c          **** 	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 4410              		.loc 1 1859 2 is_stmt 1 view .LVU1597
 4411              		.loc 1 1859 8 is_stmt 0 view .LVU1598
 4412 0010 8188     		ldrh	r1, [r0, #4]
 4413              	.LVL478:
 4414              		.loc 1 1859 8 view .LVU1599
 4415 0012 0068     		ldr	r0, [r0]
 4416              	.LVL479:
1850:ff.c          **** 	FRESULT res;
 4417              		.loc 1 1850 1 view .LVU1600
 4418 0014 1746     		mov	r7, r2
 4419              		.loc 1 1859 8 view .LVU1601
 4420 0016 FFF7FEFF 		bl	validate
 4421              	.LVL480:
1860:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 4422              		.loc 1 1860 2 is_stmt 1 view .LVU1602
 4423              		.loc 1 1860 5 is_stmt 0 view .LVU1603
 4424 001a 0646     		mov	r6, r0
 4425 001c 0028     		cmp	r0, #0
 4426 001e 3ED1     		bne	.L394
1861:ff.c          **** 	if (fp->flag & FA__ERROR)						/* Check abort flag */
 4427              		.loc 1 1861 2 is_stmt 1 view .LVU1604
 4428              		.loc 1 1861 5 is_stmt 0 view .LVU1605
 4429 0020 94F90620 		ldrsb	r2, [r4, #6]
 4430              		.loc 1 1861 8 view .LVU1606
 4431 0024 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4432              		.loc 1 1861 5 view .LVU1607
 4433 0026 002A     		cmp	r2, #0
 4434 0028 2CDB     		blt	.L416
1862:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
1863:ff.c          **** 	if (!(fp->flag & FA_WRITE))						/* Check access mode */
 4435              		.loc 1 1863 2 is_stmt 1 view .LVU1608
 4436              		.loc 1 1863 5 is_stmt 0 view .LVU1609
 4437 002a 9907     		lsls	r1, r3, #30
 4438 002c 40F1BB80 		bpl	.L417
 4439              	.LVL481:
 4440              	.LBB125:
 4441              	.LBI125:
1844:ff.c          **** 	FIL *fp,			/* Pointer to the file object */
 4442              		.loc 1 1844 9 is_stmt 1 view .LVU1610
 4443              	.LBB126:
1864:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
1865:ff.c          **** 	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
 4444              		.loc 1 1865 2 view .LVU1611
 4445              		.loc 1 1865 8 is_stmt 0 view .LVU1612
 4446 0030 E368     		ldr	r3, [r4, #12]
 4447              		.loc 1 1865 5 view .LVU1613
 4448 0032 DF42     		cmn	r7, r3
 4449 0034 03D2     		bcs	.L403
1866:ff.c          **** 
1867:ff.c          **** 	for ( ;  btw;									/* Repeat until all data transferred */
1868:ff.c          **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
1869:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
1870:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
1871:ff.c          **** 				if (fp->fptr == 0) {				/* On the top of the file? */
1872:ff.c          **** 					clst = fp->org_clust;			/* Follow from the origin */
1873:ff.c          **** 					if (clst == 0)					/* When there is no cluster chain, */
1874:ff.c          **** 						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
1875:ff.c          **** 				} else {							/* Middle or end of the file */
1876:ff.c          **** 					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or streach cluster chain */
1877:ff.c          **** 				}
1878:ff.c          **** 				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
1879:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
1880:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
1881:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
1882:ff.c          **** 				fp->csect = 0;						/* Reset sector address in the cluster */
1883:ff.c          **** 			}
1884:ff.c          **** #if _FS_TINY
1885:ff.c          **** 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to f
1886:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
1887:ff.c          **** #else
1888:ff.c          **** 			if (fp->flag & FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
1889:ff.c          **** 				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
1890:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
1891:ff.c          **** 				fp->flag &= ~FA__DIRTY;
1892:ff.c          **** 			}
1893:ff.c          **** #endif
1894:ff.c          **** 			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
1895:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
1896:ff.c          **** 			sect += fp->csect;
1897:ff.c          **** 			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
1898:ff.c          **** 			if (cc) {								/* Write maximum contiguous sectors directly */
1899:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
1900:ff.c          **** 					cc = fp->fs->csize - fp->csect;
1901:ff.c          **** 				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
1902:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
1903:ff.c          **** #if _FS_TINY
1904:ff.c          **** 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write 
1905:ff.c          **** 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
1906:ff.c          **** 					fp->fs->wflag = 0;
1907:ff.c          **** 				}
1908:ff.c          **** #else
1909:ff.c          **** 				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
1910:ff.c          **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
1911:ff.c          **** 					fp->flag &= ~FA__DIRTY;
1912:ff.c          **** 				}
1913:ff.c          **** #endif
1914:ff.c          **** 				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
1915:ff.c          **** 				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
1916:ff.c          **** 				continue;
1917:ff.c          **** 			}
1918:ff.c          **** #if _FS_TINY
1919:ff.c          **** 			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
1920:ff.c          **** 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
1921:ff.c          **** 				fp->fs->winsect = sect;
1922:ff.c          **** 			}
1923:ff.c          **** #else
1924:ff.c          **** 			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
1925:ff.c          **** 				if (fp->fptr < fp->fsize &&
1926:ff.c          **** 					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 4450              		.loc 1 1926 33 view .LVU1614
 4451 0036 04F1240A 		add	r10, r4, #36
 4452              	.LVL482:
 4453              	.L395:
1867:ff.c          **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 4454              		.loc 1 1867 11 is_stmt 1 view .LVU1615
 4455 003a A368     		ldr	r3, [r4, #8]
1867:ff.c          **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 4456              		.loc 1 1867 2 is_stmt 0 view .LVU1616
 4457 003c 4FB9     		cbnz	r7, .L415
 4458              	.LVL483:
 4459              	.L403:
1927:ff.c          **** 						ABORT(fp->fs, FR_DISK_ERR);
1928:ff.c          **** 			}
1929:ff.c          **** #endif
1930:ff.c          **** 			fp->dsect = sect;
1931:ff.c          **** 			fp->csect++;							/* Next sector address in the cluster */
1932:ff.c          **** 		}
1933:ff.c          **** 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
1934:ff.c          **** 		if (wcnt > btw) wcnt = btw;
1935:ff.c          **** #if _FS_TINY
1936:ff.c          **** 		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
1937:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
1938:ff.c          **** 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
1939:ff.c          **** 		fp->fs->wflag = 1;
1940:ff.c          **** #else
1941:ff.c          **** 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
1942:ff.c          **** 		fp->flag |= FA__DIRTY;
1943:ff.c          **** #endif
1944:ff.c          **** 	}
1945:ff.c          **** 
1946:ff.c          **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 4460              		.loc 1 1946 2 is_stmt 1 view .LVU1617
 4461              		.loc 1 1946 5 is_stmt 0 view .LVU1618
 4462 003e D4E90232 		ldrd	r3, r2, [r4, #8]
 4463 0042 9342     		cmp	r3, r2
 4464 0044 00F2AD80 		bhi	.L396
 4465              	.L397:
1947:ff.c          **** 	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
 4466              		.loc 1 1947 2 is_stmt 1 view .LVU1619
 4467              		.loc 1 1947 11 is_stmt 0 view .LVU1620
 4468 0048 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4469 004a 43F02003 		orr	r3, r3, #32
 4470 004e A371     		strb	r3, [r4, #6]
1948:ff.c          **** 
1949:ff.c          **** 	LEAVE_FF(fp->fs, FR_OK);
 4471              		.loc 1 1949 2 is_stmt 1 view .LVU1621
 4472 0050 25E0     		b	.L394
 4473              	.LVL484:
 4474              	.L415:
1869:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 4475              		.loc 1 1869 3 view .LVU1622
1869:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 4476              		.loc 1 1869 17 is_stmt 0 view .LVU1623
 4477 0052 C3F30802 		ubfx	r2, r3, #0, #9
1869:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 4478              		.loc 1 1869 6 view .LVU1624
 4479 0056 002A     		cmp	r2, #0
 4480 0058 40F09080 		bne	.L398
1870:ff.c          **** 				if (fp->fptr == 0) {				/* On the top of the file? */
 4481              		.loc 1 1870 4 is_stmt 1 view .LVU1625
1870:ff.c          **** 				if (fp->fptr == 0) {				/* On the top of the file? */
 4482              		.loc 1 1870 23 is_stmt 0 view .LVU1626
 4483 005c 2068     		ldr	r0, [r4]
1870:ff.c          **** 				if (fp->fptr == 0) {				/* On the top of the file? */
 4484              		.loc 1 1870 7 view .LVU1627
 4485 005e E179     		ldrb	r1, [r4, #7]	@ zero_extendqisi2
 4486 0060 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 4487 0062 9142     		cmp	r1, r2
 4488 0064 22D3     		bcc	.L399
1871:ff.c          **** 					clst = fp->org_clust;			/* Follow from the origin */
 4489              		.loc 1 1871 5 is_stmt 1 view .LVU1628
1871:ff.c          **** 					clst = fp->org_clust;			/* Follow from the origin */
 4490              		.loc 1 1871 8 is_stmt 0 view .LVU1629
 4491 0066 7BB9     		cbnz	r3, .L400
1872:ff.c          **** 					if (clst == 0)					/* When there is no cluster chain, */
 4492              		.loc 1 1872 6 is_stmt 1 view .LVU1630
1872:ff.c          **** 					if (clst == 0)					/* When there is no cluster chain, */
 4493              		.loc 1 1872 11 is_stmt 0 view .LVU1631
 4494 0068 2169     		ldr	r1, [r4, #16]
 4495              	.LVL485:
1873:ff.c          **** 						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 4496              		.loc 1 1873 6 is_stmt 1 view .LVU1632
1873:ff.c          **** 						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 4497              		.loc 1 1873 9 is_stmt 0 view .LVU1633
 4498 006a 29B9     		cbnz	r1, .L401
1874:ff.c          **** 				} else {							/* Middle or end of the file */
 4499              		.loc 1 1874 7 is_stmt 1 view .LVU1634
1874:ff.c          **** 				} else {							/* Middle or end of the file */
 4500              		.loc 1 1874 30 is_stmt 0 view .LVU1635
 4501 006c FFF7FEFF 		bl	create_chain
 4502              	.LVL486:
1874:ff.c          **** 				} else {							/* Middle or end of the file */
 4503              		.loc 1 1874 30 view .LVU1636
 4504 0070 0146     		mov	r1, r0
 4505              	.LVL487:
1874:ff.c          **** 				} else {							/* Middle or end of the file */
 4506              		.loc 1 1874 21 view .LVU1637
 4507 0072 2061     		str	r0, [r4, #16]
 4508              	.L402:
1878:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 4509              		.loc 1 1878 5 is_stmt 1 view .LVU1638
1878:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 4510              		.loc 1 1878 8 is_stmt 0 view .LVU1639
 4511 0074 0029     		cmp	r1, #0
 4512 0076 E2D0     		beq	.L403
 4513              	.LVL488:
 4514              	.L401:
1879:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4515              		.loc 1 1879 5 is_stmt 1 view .LVU1640
1879:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4516              		.loc 1 1879 8 is_stmt 0 view .LVU1641
 4517 0078 0129     		cmp	r1, #1
 4518 007a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4519 007c 09D1     		bne	.L404
 4520              	.LVL489:
 4521              	.L430:
1895:ff.c          **** 			sect += fp->csect;
 4522              		.loc 1 1895 15 view .LVU1642
 4523 007e 63F07F03 		orn	r3, r3, #127
 4524 0082 A371     		strb	r3, [r4, #6]
1895:ff.c          **** 			sect += fp->csect;
 4525              		.loc 1 1895 15 is_stmt 1 view .LVU1643
 4526              	.LVL490:
 4527              	.L416:
1895:ff.c          **** 			sect += fp->csect;
 4528              		.loc 1 1895 15 is_stmt 0 view .LVU1644
 4529              	.LBE126:
 4530              	.LBE125:
1862:ff.c          **** 	if (!(fp->flag & FA_WRITE))						/* Check access mode */
 4531              		.loc 1 1862 3 view .LVU1645
 4532 0084 0226     		movs	r6, #2
 4533 0086 0AE0     		b	.L394
 4534              	.LVL491:
 4535              	.L400:
 4536              	.LBB129:
 4537              	.LBB127:
1876:ff.c          **** 				}
 4538              		.loc 1 1876 6 is_stmt 1 view .LVU1646
1876:ff.c          **** 				}
 4539              		.loc 1 1876 13 is_stmt 0 view .LVU1647
 4540 0088 6169     		ldr	r1, [r4, #20]
 4541 008a FFF7FEFF 		bl	create_chain
 4542              	.LVL492:
 4543 008e 0146     		mov	r1, r0
 4544              	.LVL493:
1876:ff.c          **** 				}
 4545              		.loc 1 1876 13 view .LVU1648
 4546 0090 F0E7     		b	.L402
 4547              	.LVL494:
 4548              	.L404:
1879:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4549              		.loc 1 1879 45 is_stmt 1 view .LVU1649
1880:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
 4550              		.loc 1 1880 5 view .LVU1650
1880:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
 4551              		.loc 1 1880 8 is_stmt 0 view .LVU1651
 4552 0092 4A1C     		adds	r2, r1, #1
 4553 0094 07D1     		bne	.L405
 4554              	.LVL495:
 4555              	.L428:
1927:ff.c          **** 			}
 4556              		.loc 1 1927 7 view .LVU1652
 4557 0096 0126     		movs	r6, #1
 4558 0098 63F07F03 		orn	r3, r3, #127
 4559 009c A371     		strb	r3, [r4, #6]
1927:ff.c          **** 			}
 4560              		.loc 1 1927 7 is_stmt 1 view .LVU1653
 4561              	.LVL496:
 4562              	.L394:
1927:ff.c          **** 			}
 4563              		.loc 1 1927 7 is_stmt 0 view .LVU1654
 4564              	.LBE127:
 4565              	.LBE129:
1950:ff.c          **** }
 4566              		.loc 1 1950 1 view .LVU1655
 4567 009e 3046     		mov	r0, r6
 4568 00a0 03B0     		add	sp, sp, #12
 4569              		.cfi_remember_state
 4570              		.cfi_def_cfa_offset 36
 4571              		@ sp needed
 4572 00a2 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4573              	.LVL497:
 4574              	.L405:
 4575              		.cfi_restore_state
 4576              	.LBB130:
 4577              	.LBB128:
1880:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
 4578              		.loc 1 1880 55 is_stmt 1 view .LVU1656
1881:ff.c          **** 				fp->csect = 0;						/* Reset sector address in the cluster */
 4579              		.loc 1 1881 5 view .LVU1657
1882:ff.c          **** 			}
 4580              		.loc 1 1882 15 is_stmt 0 view .LVU1658
 4581 00a6 0023     		movs	r3, #0
1881:ff.c          **** 				fp->csect = 0;						/* Reset sector address in the cluster */
 4582              		.loc 1 1881 20 view .LVU1659
 4583 00a8 6161     		str	r1, [r4, #20]
1882:ff.c          **** 			}
 4584              		.loc 1 1882 5 is_stmt 1 view .LVU1660
1882:ff.c          **** 			}
 4585              		.loc 1 1882 15 is_stmt 0 view .LVU1661
 4586 00aa E371     		strb	r3, [r4, #7]
 4587              	.LVL498:
 4588              	.L399:
1888:ff.c          **** 				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 4589              		.loc 1 1888 4 is_stmt 1 view .LVU1662
1888:ff.c          **** 				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 4590              		.loc 1 1888 7 is_stmt 0 view .LVU1663
 4591 00ac A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4592 00ae 5B06     		lsls	r3, r3, #25
 4593 00b0 0CD5     		bpl	.L406
1889:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4594              		.loc 1 1889 5 is_stmt 1 view .LVU1664
1889:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4595              		.loc 1 1889 9 is_stmt 0 view .LVU1665
 4596 00b2 2068     		ldr	r0, [r4]
 4597 00b4 0123     		movs	r3, #1
 4598 00b6 5146     		mov	r1, r10
 4599 00b8 A269     		ldr	r2, [r4, #24]
 4600 00ba 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 4601 00bc FFF7FEFF 		bl	disk_write
 4602              	.LVL499:
 4603 00c0 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
1889:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4604              		.loc 1 1889 8 view .LVU1666
 4605 00c2 0028     		cmp	r0, #0
 4606 00c4 E7D1     		bne	.L428
1890:ff.c          **** 				fp->flag &= ~FA__DIRTY;
 4607              		.loc 1 1890 32 is_stmt 1 view .LVU1667
1891:ff.c          **** 			}
 4608              		.loc 1 1891 5 view .LVU1668
1891:ff.c          **** 			}
 4609              		.loc 1 1891 14 is_stmt 0 view .LVU1669
 4610 00c6 23F04003 		bic	r3, r3, #64
 4611 00ca A371     		strb	r3, [r4, #6]
 4612              	.L406:
1894:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 4613              		.loc 1 1894 4 is_stmt 1 view .LVU1670
1894:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 4614              		.loc 1 1894 11 is_stmt 0 view .LVU1671
 4615 00cc D4F800B0 		ldr	fp, [r4]
 4616 00d0 6169     		ldr	r1, [r4, #20]
 4617 00d2 5846     		mov	r0, fp
 4618 00d4 FFF7FEFF 		bl	clust2sect
 4619              	.LVL500:
1895:ff.c          **** 			sect += fp->csect;
 4620              		.loc 1 1895 4 is_stmt 1 view .LVU1672
1895:ff.c          **** 			sect += fp->csect;
 4621              		.loc 1 1895 7 is_stmt 0 view .LVU1673
 4622 00d8 08B9     		cbnz	r0, .L408
1895:ff.c          **** 			sect += fp->csect;
 4623              		.loc 1 1895 15 is_stmt 1 view .LVU1674
 4624 00da A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4625 00dc CFE7     		b	.L430
 4626              	.L408:
1895:ff.c          **** 			sect += fp->csect;
 4627              		.loc 1 1895 40 view .LVU1675
1896:ff.c          **** 			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
 4628              		.loc 1 1896 4 view .LVU1676
1896:ff.c          **** 			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
 4629              		.loc 1 1896 14 is_stmt 0 view .LVU1677
 4630 00de E379     		ldrb	r3, [r4, #7]	@ zero_extendqisi2
1898:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 4631              		.loc 1 1898 7 view .LVU1678
 4632 00e0 B7F5007F 		cmp	r7, #512
1896:ff.c          **** 			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
 4633              		.loc 1 1896 9 view .LVU1679
 4634 00e4 00EB0302 		add	r2, r0, r3
 4635              	.LVL501:
1897:ff.c          **** 			if (cc) {								/* Write maximum contiguous sectors directly */
 4636              		.loc 1 1897 4 is_stmt 1 view .LVU1680
1898:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 4637              		.loc 1 1898 4 view .LVU1681
1898:ff.c          **** 				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 4638              		.loc 1 1898 7 is_stmt 0 view .LVU1682
 4639 00e8 33D3     		bcc	.L409
1899:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4640              		.loc 1 1899 32 view .LVU1683
 4641 00ea 9BF80210 		ldrb	r1, [fp, #2]	@ zero_extendqisi2
1899:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4642              		.loc 1 1899 19 view .LVU1684
 4643 00ee 03EB5720 		add	r0, r3, r7, lsr #9
1899:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4644              		.loc 1 1899 8 view .LVU1685
 4645 00f2 8842     		cmp	r0, r1
1897:ff.c          **** 			if (cc) {								/* Write maximum contiguous sectors directly */
 4646              		.loc 1 1897 7 view .LVU1686
 4647 00f4 4FEA5725 		lsr	r5, r7, #9
 4648              	.LVL502:
1899:ff.c          **** 					cc = fp->fs->csize - fp->csect;
 4649              		.loc 1 1899 5 is_stmt 1 view .LVU1687
1900:ff.c          **** 				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
 4650              		.loc 1 1900 6 view .LVU1688
1900:ff.c          **** 				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
 4651              		.loc 1 1900 25 is_stmt 0 view .LVU1689
 4652 00f8 88BF     		it	hi
 4653 00fa CD1A     		subhi	r5, r1, r3
 4654              	.LVL503:
1901:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4655              		.loc 1 1901 5 is_stmt 1 view .LVU1690
1901:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4656              		.loc 1 1901 9 is_stmt 0 view .LVU1691
 4657 00fc EBB2     		uxtb	r3, r5
 4658 00fe 4146     		mov	r1, r8
 4659 0100 9BF80100 		ldrb	r0, [fp, #1]	@ zero_extendqisi2
 4660 0104 CDE90032 		strd	r3, r2, [sp]
 4661 0108 FFF7FEFF 		bl	disk_write
 4662              	.LVL504:
1901:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 4663              		.loc 1 1901 8 view .LVU1692
 4664 010c 019A     		ldr	r2, [sp, #4]
 4665 010e 08B1     		cbz	r0, .L411
 4666              	.LVL505:
 4667              	.L429:
1927:ff.c          **** 			}
 4668              		.loc 1 1927 7 is_stmt 1 view .LVU1693
 4669 0110 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4670 0112 C0E7     		b	.L428
 4671              	.LVL506:
 4672              	.L411:
1902:ff.c          **** #if _FS_TINY
 4673              		.loc 1 1902 32 view .LVU1694
1909:ff.c          **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 4674              		.loc 1 1909 5 view .LVU1695
1909:ff.c          **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 4675              		.loc 1 1909 19 is_stmt 0 view .LVU1696
 4676 0114 A169     		ldr	r1, [r4, #24]
 4677 0116 891A     		subs	r1, r1, r2
1909:ff.c          **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 4678              		.loc 1 1909 8 view .LVU1697
 4679 0118 8D42     		cmp	r5, r1
 4680 011a 0AD9     		bls	.L412
1910:ff.c          **** 					fp->flag &= ~FA__DIRTY;
 4681              		.loc 1 1910 6 is_stmt 1 view .LVU1698
 4682 011c 4FF40072 		mov	r2, #512
 4683 0120 5046     		mov	r0, r10
 4684 0122 08EB4121 		add	r1, r8, r1, lsl #9
 4685 0126 FFF7FEFF 		bl	mem_cpy
 4686              	.LVL507:
1911:ff.c          **** 				}
 4687              		.loc 1 1911 6 view .LVU1699
1911:ff.c          **** 				}
 4688              		.loc 1 1911 15 is_stmt 0 view .LVU1700
 4689 012a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4690 012c 23F04003 		bic	r3, r3, #64
 4691 0130 A371     		strb	r3, [r4, #6]
 4692              	.L412:
1914:ff.c          **** 				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 4693              		.loc 1 1914 5 is_stmt 1 view .LVU1701
1914:ff.c          **** 				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 4694              		.loc 1 1914 15 is_stmt 0 view .LVU1702
 4695 0132 E379     		ldrb	r3, [r4, #7]	@ zero_extendqisi2
 4696 0134 009A     		ldr	r2, [sp]
1915:ff.c          **** 				continue;
 4697              		.loc 1 1915 10 view .LVU1703
 4698 0136 6D02     		lsls	r5, r5, #9
 4699              	.LVL508:
1914:ff.c          **** 				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 4700              		.loc 1 1914 15 view .LVU1704
 4701 0138 1A44     		add	r2, r2, r3
 4702 013a E271     		strb	r2, [r4, #7]
1915:ff.c          **** 				continue;
 4703              		.loc 1 1915 5 is_stmt 1 view .LVU1705
 4704              	.LVL509:
1916:ff.c          **** 			}
 4705              		.loc 1 1916 5 view .LVU1706
 4706              	.L413:
1868:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4707              		.loc 1 1868 3 view .LVU1707
1868:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4708              		.loc 1 1868 27 is_stmt 0 view .LVU1708
 4709 013c A368     		ldr	r3, [r4, #8]
1868:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4710              		.loc 1 1868 9 view .LVU1709
 4711 013e A844     		add	r8, r8, r5
 4712              	.LVL510:
1868:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4713              		.loc 1 1868 27 view .LVU1710
 4714 0140 2B44     		add	r3, r3, r5
 4715 0142 A360     		str	r3, [r4, #8]
1868:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4716              		.loc 1 1868 40 view .LVU1711
 4717 0144 D9F80030 		ldr	r3, [r9]
1868:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4718              		.loc 1 1868 53 view .LVU1712
 4719 0148 7F1B     		subs	r7, r7, r5
 4720              	.LVL511:
1868:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 4721              		.loc 1 1868 40 view .LVU1713
 4722 014a 2B44     		add	r3, r3, r5
 4723 014c C9F80030 		str	r3, [r9]
 4724 0150 73E7     		b	.L395
 4725              	.LVL512:
 4726              	.L409:
1924:ff.c          **** 				if (fp->fptr < fp->fsize &&
 4727              		.loc 1 1924 4 is_stmt 1 view .LVU1714
1924:ff.c          **** 				if (fp->fptr < fp->fsize &&
 4728              		.loc 1 1924 7 is_stmt 0 view .LVU1715
 4729 0152 A369     		ldr	r3, [r4, #24]
 4730 0154 9A42     		cmp	r2, r3
 4731 0156 0DD0     		beq	.L414
1925:ff.c          **** 					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 4732              		.loc 1 1925 5 is_stmt 1 view .LVU1716
1925:ff.c          **** 					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 4733              		.loc 1 1925 8 is_stmt 0 view .LVU1717
 4734 0158 D4E90231 		ldrd	r3, r1, [r4, #8]
 4735 015c 9942     		cmp	r1, r3
 4736 015e 09D9     		bls	.L414
1926:ff.c          **** 						ABORT(fp->fs, FR_DISK_ERR);
 4737              		.loc 1 1926 6 view .LVU1718
 4738 0160 0123     		movs	r3, #1
 4739 0162 5146     		mov	r1, r10
 4740 0164 9BF80100 		ldrb	r0, [fp, #1]	@ zero_extendqisi2
 4741 0168 0092     		str	r2, [sp]
 4742 016a FFF7FEFF 		bl	disk_read
 4743              	.LVL513:
1925:ff.c          **** 					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 4744              		.loc 1 1925 30 view .LVU1719
 4745 016e 009A     		ldr	r2, [sp]
 4746 0170 0028     		cmp	r0, #0
 4747 0172 CDD1     		bne	.L429
 4748              	.LVL514:
 4749              	.L414:
1927:ff.c          **** 			}
 4750              		.loc 1 1927 33 is_stmt 1 view .LVU1720
1930:ff.c          **** 			fp->csect++;							/* Next sector address in the cluster */
 4751              		.loc 1 1930 4 view .LVU1721
1931:ff.c          **** 		}
 4752              		.loc 1 1931 13 is_stmt 0 view .LVU1722
 4753 0174 E379     		ldrb	r3, [r4, #7]	@ zero_extendqisi2
1930:ff.c          **** 			fp->csect++;							/* Next sector address in the cluster */
 4754              		.loc 1 1930 14 view .LVU1723
 4755 0176 A261     		str	r2, [r4, #24]
1931:ff.c          **** 		}
 4756              		.loc 1 1931 4 is_stmt 1 view .LVU1724
1931:ff.c          **** 		}
 4757              		.loc 1 1931 13 is_stmt 0 view .LVU1725
 4758 0178 0133     		adds	r3, r3, #1
 4759 017a E371     		strb	r3, [r4, #7]
 4760              	.LVL515:
 4761              	.L398:
1933:ff.c          **** 		if (wcnt > btw) wcnt = btw;
 4762              		.loc 1 1933 3 is_stmt 1 view .LVU1726
1933:ff.c          **** 		if (wcnt > btw) wcnt = btw;
 4763              		.loc 1 1933 33 is_stmt 0 view .LVU1727
 4764 017c A068     		ldr	r0, [r4, #8]
1941:ff.c          **** 		fp->flag |= FA__DIRTY;
 4765              		.loc 1 1941 3 view .LVU1728
 4766 017e 4146     		mov	r1, r8
1933:ff.c          **** 		if (wcnt > btw) wcnt = btw;
 4767              		.loc 1 1933 33 view .LVU1729
 4768 0180 C0F30800 		ubfx	r0, r0, #0, #9
1933:ff.c          **** 		if (wcnt > btw) wcnt = btw;
 4769              		.loc 1 1933 8 view .LVU1730
 4770 0184 C0F50075 		rsb	r5, r0, #512
 4771              	.LVL516:
1934:ff.c          **** #if _FS_TINY
 4772              		.loc 1 1934 3 is_stmt 1 view .LVU1731
 4773 0188 BD42     		cmp	r5, r7
 4774 018a 28BF     		it	cs
 4775 018c 3D46     		movcs	r5, r7
 4776              	.LVL517:
1941:ff.c          **** 		fp->flag |= FA__DIRTY;
 4777              		.loc 1 1941 3 view .LVU1732
1941:ff.c          **** 		fp->flag |= FA__DIRTY;
 4778              		.loc 1 1941 11 is_stmt 0 view .LVU1733
 4779 018e 2430     		adds	r0, r0, #36
1941:ff.c          **** 		fp->flag |= FA__DIRTY;
 4780              		.loc 1 1941 3 view .LVU1734
 4781 0190 2A46     		mov	r2, r5
 4782 0192 2044     		add	r0, r0, r4
 4783 0194 FFF7FEFF 		bl	mem_cpy
 4784              	.LVL518:
1942:ff.c          **** #endif
 4785              		.loc 1 1942 3 is_stmt 1 view .LVU1735
1942:ff.c          **** #endif
 4786              		.loc 1 1942 12 is_stmt 0 view .LVU1736
 4787 0198 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4788 019a 43F04003 		orr	r3, r3, #64
 4789 019e A371     		strb	r3, [r4, #6]
 4790 01a0 CCE7     		b	.L413
 4791              	.LVL519:
 4792              	.L396:
1946:ff.c          **** 	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
 4793              		.loc 1 1946 28 is_stmt 1 view .LVU1737
1946:ff.c          **** 	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
 4794              		.loc 1 1946 38 is_stmt 0 view .LVU1738
 4795 01a2 E360     		str	r3, [r4, #12]
 4796 01a4 50E7     		b	.L397
 4797              	.LVL520:
 4798              	.L417:
1946:ff.c          **** 	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
 4799              		.loc 1 1946 38 view .LVU1739
 4800              	.LBE128:
 4801              	.LBE130:
1864:ff.c          **** 	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
 4802              		.loc 1 1864 3 view .LVU1740
 4803 01a6 0726     		movs	r6, #7
 4804 01a8 79E7     		b	.L394
 4805              		.cfi_endproc
 4806              	.LFE55:
 4808              		.section	.text.f_sync,"ax",%progbits
 4809              		.align	1
 4810              		.global	f_sync
 4811              		.syntax unified
 4812              		.thumb
 4813              		.thumb_func
 4814              		.fpu softvfp
 4816              	f_sync:
 4817              	.LVL521:
 4818              	.LFB56:
1951:ff.c          **** 
1952:ff.c          **** 
1953:ff.c          **** 
1954:ff.c          **** 
1955:ff.c          **** /*-----------------------------------------------------------------------*/
1956:ff.c          **** /* Synchronize the File Object                                           */
1957:ff.c          **** /*-----------------------------------------------------------------------*/
1958:ff.c          **** 
1959:ff.c          **** FRESULT f_sync (
1960:ff.c          **** 	FIL *fp		/* Pointer to the file object */
1961:ff.c          **** )
1962:ff.c          **** {
 4819              		.loc 1 1962 1 is_stmt 1 view -0
 4820              		.cfi_startproc
 4821              		@ args = 0, pretend = 0, frame = 0
 4822              		@ frame_needed = 0, uses_anonymous_args = 0
1963:ff.c          **** 	FRESULT res;
 4823              		.loc 1 1963 2 view .LVU1742
1964:ff.c          **** 	DWORD tim;
 4824              		.loc 1 1964 2 view .LVU1743
1965:ff.c          **** 	BYTE *dir;
 4825              		.loc 1 1965 2 view .LVU1744
1966:ff.c          **** 
1967:ff.c          **** 
1968:ff.c          **** 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 4826              		.loc 1 1968 2 view .LVU1745
1962:ff.c          **** 	FRESULT res;
 4827              		.loc 1 1962 1 is_stmt 0 view .LVU1746
 4828 0000 38B5     		push	{r3, r4, r5, lr}
 4829              		.cfi_def_cfa_offset 16
 4830              		.cfi_offset 3, -16
 4831              		.cfi_offset 4, -12
 4832              		.cfi_offset 5, -8
 4833              		.cfi_offset 14, -4
 4834              		.loc 1 1968 8 view .LVU1747
 4835 0002 8188     		ldrh	r1, [r0, #4]
1962:ff.c          **** 	FRESULT res;
 4836              		.loc 1 1962 1 view .LVU1748
 4837 0004 0446     		mov	r4, r0
 4838              		.loc 1 1968 8 view .LVU1749
 4839 0006 0068     		ldr	r0, [r0]
 4840              	.LVL522:
 4841              		.loc 1 1968 8 view .LVU1750
 4842 0008 FFF7FEFF 		bl	validate
 4843              	.LVL523:
1969:ff.c          **** 	if (res == FR_OK) {
 4844              		.loc 1 1969 2 is_stmt 1 view .LVU1751
 4845              		.loc 1 1969 5 is_stmt 0 view .LVU1752
 4846 000c 0028     		cmp	r0, #0
 4847 000e 46D1     		bne	.L432
1970:ff.c          **** 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 4848              		.loc 1 1970 3 is_stmt 1 view .LVU1753
 4849              		.loc 1 1970 9 is_stmt 0 view .LVU1754
 4850 0010 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4851              		.loc 1 1970 6 view .LVU1755
 4852 0012 13F02000 		ands	r0, r3, #32
 4853              	.LVL524:
 4854              		.loc 1 1970 6 view .LVU1756
 4855 0016 42D0     		beq	.L432
1971:ff.c          **** #if !_FS_TINY	/* Write-back dirty buffer */
1972:ff.c          **** 			if (fp->flag & FA__DIRTY) {
 4856              		.loc 1 1972 4 is_stmt 1 view .LVU1757
 4857              		.loc 1 1972 7 is_stmt 0 view .LVU1758
 4858 0018 5B06     		lsls	r3, r3, #25
 4859 001a 0DD5     		bpl	.L433
1973:ff.c          **** 				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 4860              		.loc 1 1973 5 is_stmt 1 view .LVU1759
 4861              		.loc 1 1973 37 is_stmt 0 view .LVU1760
 4862 001c 2146     		mov	r1, r4
 4863              		.loc 1 1973 9 view .LVU1761
 4864 001e 51F8240B 		ldr	r0, [r1], #36
 4865 0022 0123     		movs	r3, #1
 4866 0024 A269     		ldr	r2, [r4, #24]
 4867 0026 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 4868 0028 FFF7FEFF 		bl	disk_write
 4869              	.LVL525:
 4870              		.loc 1 1973 8 view .LVU1762
 4871 002c 0028     		cmp	r0, #0
 4872 002e 35D1     		bne	.L434
1974:ff.c          **** 					LEAVE_FF(fp->fs, FR_DISK_ERR);
1975:ff.c          **** 				fp->flag &= ~FA__DIRTY;
 4873              		.loc 1 1975 5 is_stmt 1 view .LVU1763
 4874              		.loc 1 1975 14 is_stmt 0 view .LVU1764
 4875 0030 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4876 0032 23F04003 		bic	r3, r3, #64
 4877 0036 A371     		strb	r3, [r4, #6]
 4878              	.L433:
 4879              	.LVL526:
 4880              	.LBB133:
 4881              	.LBI133:
1959:ff.c          **** 	FIL *fp		/* Pointer to the file object */
 4882              		.loc 1 1959 9 is_stmt 1 view .LVU1765
 4883              	.LBB134:
1976:ff.c          **** 			}
1977:ff.c          **** #endif
1978:ff.c          **** 			/* Update the directory entry */
1979:ff.c          **** 			res = move_window(fp->fs, fp->dir_sect);
 4884              		.loc 1 1979 4 view .LVU1766
 4885              		.loc 1 1979 10 is_stmt 0 view .LVU1767
 4886 0038 E169     		ldr	r1, [r4, #28]
 4887 003a 2068     		ldr	r0, [r4]
 4888 003c FFF7FEFF 		bl	move_window
 4889              	.LVL527:
1980:ff.c          **** 			if (res == FR_OK) {
 4890              		.loc 1 1980 4 is_stmt 1 view .LVU1768
 4891              		.loc 1 1980 7 is_stmt 0 view .LVU1769
 4892 0040 68BB     		cbnz	r0, .L432
1981:ff.c          **** 				dir = fp->dir_ptr;
 4893              		.loc 1 1981 5 is_stmt 1 view .LVU1770
 4894              		.loc 1 1981 9 is_stmt 0 view .LVU1771
 4895 0042 256A     		ldr	r5, [r4, #32]
 4896              	.LVL528:
1982:ff.c          **** 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 4897              		.loc 1 1982 5 is_stmt 1 view .LVU1772
 4898              		.loc 1 1982 19 is_stmt 0 view .LVU1773
 4899 0044 EB7A     		ldrb	r3, [r5, #11]	@ zero_extendqisi2
 4900 0046 43F02003 		orr	r3, r3, #32
 4901 004a EB72     		strb	r3, [r5, #11]
1983:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 4902              		.loc 1 1983 5 is_stmt 1 view .LVU1774
 4903 004c E368     		ldr	r3, [r4, #12]
 4904 004e 2B77     		strb	r3, [r5, #28]
 4905              		.loc 1 1983 5 view .LVU1775
 4906 0050 A389     		ldrh	r3, [r4, #12]
 4907 0052 1B0A     		lsrs	r3, r3, #8
 4908 0054 6B77     		strb	r3, [r5, #29]
 4909              		.loc 1 1983 5 view .LVU1776
 4910 0056 E389     		ldrh	r3, [r4, #14]
 4911 0058 AB77     		strb	r3, [r5, #30]
 4912              		.loc 1 1983 5 view .LVU1777
 4913 005a E37B     		ldrb	r3, [r4, #15]	@ zero_extendqisi2
 4914 005c EB77     		strb	r3, [r5, #31]
1984:ff.c          **** 				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
 4915              		.loc 1 1984 5 view .LVU1778
 4916 005e 2369     		ldr	r3, [r4, #16]
 4917 0060 AB76     		strb	r3, [r5, #26]
 4918              		.loc 1 1984 5 view .LVU1779
 4919 0062 238A     		ldrh	r3, [r4, #16]
 4920 0064 1B0A     		lsrs	r3, r3, #8
 4921 0066 EB76     		strb	r3, [r5, #27]
1985:ff.c          **** 				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
 4922              		.loc 1 1985 5 view .LVU1780
 4923 0068 638A     		ldrh	r3, [r4, #18]
 4924 006a 2B75     		strb	r3, [r5, #20]
 4925              		.loc 1 1985 5 view .LVU1781
 4926 006c 638A     		ldrh	r3, [r4, #18]
 4927 006e 1B0A     		lsrs	r3, r3, #8
 4928 0070 6B75     		strb	r3, [r5, #21]
1986:ff.c          **** 				tim = get_fattime();			/* Updated time */
 4929              		.loc 1 1986 5 view .LVU1782
 4930              		.loc 1 1986 11 is_stmt 0 view .LVU1783
 4931 0072 FFF7FEFF 		bl	get_fattime
 4932              	.LVL529:
1987:ff.c          **** 				ST_DWORD(dir+DIR_WrtTime, tim);
 4933              		.loc 1 1987 5 is_stmt 1 view .LVU1784
 4934 0076 C0F30723 		ubfx	r3, r0, #8, #8
 4935 007a A875     		strb	r0, [r5, #22]
 4936              		.loc 1 1987 5 view .LVU1785
 4937 007c EB75     		strb	r3, [r5, #23]
 4938              		.loc 1 1987 5 view .LVU1786
 4939 007e 030C     		lsrs	r3, r0, #16
 4940 0080 000E     		lsrs	r0, r0, #24
 4941              	.LVL530:
 4942              		.loc 1 1987 5 is_stmt 0 view .LVU1787
 4943 0082 2B76     		strb	r3, [r5, #24]
 4944              		.loc 1 1987 5 is_stmt 1 view .LVU1788
 4945 0084 6876     		strb	r0, [r5, #25]
1988:ff.c          **** 				fp->flag &= ~FA__WRITTEN;
 4946              		.loc 1 1988 5 view .LVU1789
 4947              		.loc 1 1988 14 is_stmt 0 view .LVU1790
 4948 0086 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
1989:ff.c          **** 				fp->fs->wflag = 1;
 4949              		.loc 1 1989 7 view .LVU1791
 4950 0088 2068     		ldr	r0, [r4]
1988:ff.c          **** 				fp->flag &= ~FA__WRITTEN;
 4951              		.loc 1 1988 14 view .LVU1792
 4952 008a 23F02003 		bic	r3, r3, #32
 4953 008e A371     		strb	r3, [r4, #6]
 4954              		.loc 1 1989 5 is_stmt 1 view .LVU1793
 4955              		.loc 1 1989 19 is_stmt 0 view .LVU1794
 4956 0090 0123     		movs	r3, #1
 4957 0092 0371     		strb	r3, [r0, #4]
1990:ff.c          **** 				res = sync(fp->fs);
 4958              		.loc 1 1990 5 is_stmt 1 view .LVU1795
 4959              	.LBE134:
 4960              	.LBE133:
1991:ff.c          **** 			}
1992:ff.c          **** 		}
1993:ff.c          **** 	}
1994:ff.c          **** 
1995:ff.c          **** 	LEAVE_FF(fp->fs, res);
1996:ff.c          **** }
 4961              		.loc 1 1996 1 is_stmt 0 view .LVU1796
 4962 0094 BDE83840 		pop	{r3, r4, r5, lr}
 4963              		.cfi_remember_state
 4964              		.cfi_restore 14
 4965              		.cfi_restore 5
 4966              		.cfi_restore 4
 4967              		.cfi_restore 3
 4968              		.cfi_def_cfa_offset 0
 4969              	.LVL531:
 4970              	.LBB136:
 4971              	.LBB135:
1990:ff.c          **** 				res = sync(fp->fs);
 4972              		.loc 1 1990 11 view .LVU1797
 4973 0098 FFF7FEBF 		b	sync
 4974              	.LVL532:
 4975              	.L434:
 4976              		.cfi_restore_state
1990:ff.c          **** 				res = sync(fp->fs);
 4977              		.loc 1 1990 11 view .LVU1798
 4978              	.LBE135:
 4979              	.LBE136:
1974:ff.c          **** 				fp->flag &= ~FA__DIRTY;
 4980              		.loc 1 1974 6 view .LVU1799
 4981 009c 0120     		movs	r0, #1
 4982              	.L432:
 4983              		.loc 1 1996 1 view .LVU1800
 4984 009e 38BD     		pop	{r3, r4, r5, pc}
 4985              		.loc 1 1996 1 view .LVU1801
 4986              		.cfi_endproc
 4987              	.LFE56:
 4989              		.section	.text.f_close,"ax",%progbits
 4990              		.align	1
 4991              		.global	f_close
 4992              		.syntax unified
 4993              		.thumb
 4994              		.thumb_func
 4995              		.fpu softvfp
 4997              	f_close:
 4998              	.LVL533:
 4999              	.LFB57:
1997:ff.c          **** 
1998:ff.c          **** #endif /* !_FS_READONLY */
1999:ff.c          **** 
2000:ff.c          **** 
2001:ff.c          **** 
2002:ff.c          **** 
2003:ff.c          **** /*-----------------------------------------------------------------------*/
2004:ff.c          **** /* Close File                                                            */
2005:ff.c          **** /*-----------------------------------------------------------------------*/
2006:ff.c          **** 
2007:ff.c          **** FRESULT f_close (
2008:ff.c          **** 	FIL *fp		/* Pointer to the file object to be closed */
2009:ff.c          **** )
2010:ff.c          **** {
 5000              		.loc 1 2010 1 is_stmt 1 view -0
 5001              		.cfi_startproc
 5002              		@ args = 0, pretend = 0, frame = 0
 5003              		@ frame_needed = 0, uses_anonymous_args = 0
2011:ff.c          **** 	FRESULT res;
 5004              		.loc 1 2011 2 view .LVU1803
2012:ff.c          **** 
2013:ff.c          **** 
2014:ff.c          **** #if _FS_READONLY
2015:ff.c          **** 	res = validate(fp->fs, fp->id);
2016:ff.c          **** 	if (res == FR_OK) fp->fs = NULL;
2017:ff.c          **** 	LEAVE_FF(fp->fs, res);
2018:ff.c          **** #else
2019:ff.c          **** 	res = f_sync(fp);
 5005              		.loc 1 2019 2 view .LVU1804
2010:ff.c          **** 	FRESULT res;
 5006              		.loc 1 2010 1 is_stmt 0 view .LVU1805
 5007 0000 10B5     		push	{r4, lr}
 5008              		.cfi_def_cfa_offset 8
 5009              		.cfi_offset 4, -8
 5010              		.cfi_offset 14, -4
2010:ff.c          **** 	FRESULT res;
 5011              		.loc 1 2010 1 view .LVU1806
 5012 0002 0446     		mov	r4, r0
 5013              		.loc 1 2019 8 view .LVU1807
 5014 0004 FFF7FEFF 		bl	f_sync
 5015              	.LVL534:
2020:ff.c          **** 	if (res == FR_OK) fp->fs = NULL;
 5016              		.loc 1 2020 2 is_stmt 1 view .LVU1808
 5017              		.loc 1 2020 5 is_stmt 0 view .LVU1809
 5018 0008 00B9     		cbnz	r0, .L442
 5019              		.loc 1 2020 20 is_stmt 1 discriminator 1 view .LVU1810
 5020              		.loc 1 2020 27 is_stmt 0 discriminator 1 view .LVU1811
 5021 000a 2060     		str	r0, [r4]
 5022              	.L442:
2021:ff.c          **** 	return res;
 5023              		.loc 1 2021 2 is_stmt 1 view .LVU1812
2022:ff.c          **** #endif
2023:ff.c          **** }
 5024              		.loc 1 2023 1 is_stmt 0 view .LVU1813
 5025 000c 10BD     		pop	{r4, pc}
 5026              		.loc 1 2023 1 view .LVU1814
 5027              		.cfi_endproc
 5028              	.LFE57:
 5030              		.section	.text.f_chdrive,"ax",%progbits
 5031              		.align	1
 5032              		.global	f_chdrive
 5033              		.syntax unified
 5034              		.thumb
 5035              		.thumb_func
 5036              		.fpu softvfp
 5038              	f_chdrive:
 5039              	.LVL535:
 5040              	.LFB58:
2024:ff.c          **** 
2025:ff.c          **** 
2026:ff.c          **** 
2027:ff.c          **** 
2028:ff.c          **** /*-----------------------------------------------------------------------*/
2029:ff.c          **** /* Change Current Drive/Directory                                        */
2030:ff.c          **** /*-----------------------------------------------------------------------*/
2031:ff.c          **** 
2032:ff.c          **** #if _FS_RPATH
2033:ff.c          **** 
2034:ff.c          **** FRESULT f_chdrive (
2035:ff.c          **** 	BYTE drv		/* Drive number */
2036:ff.c          **** )
2037:ff.c          **** {
 5041              		.loc 1 2037 1 is_stmt 1 view -0
 5042              		.cfi_startproc
 5043              		@ args = 0, pretend = 0, frame = 0
 5044              		@ frame_needed = 0, uses_anonymous_args = 0
 5045              		@ link register save eliminated.
2038:ff.c          **** 	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
 5046              		.loc 1 2038 2 view .LVU1816
 5047              		.loc 1 2038 5 is_stmt 0 view .LVU1817
 5048 0000 10B9     		cbnz	r0, .L445
2039:ff.c          **** 
2040:ff.c          **** 	Drive = drv;
 5049              		.loc 1 2040 2 is_stmt 1 view .LVU1818
 5050              		.loc 1 2040 8 is_stmt 0 view .LVU1819
 5051 0002 024B     		ldr	r3, .L446
 5052 0004 1870     		strb	r0, [r3]
2041:ff.c          **** 
2042:ff.c          **** 	return FR_OK;
 5053              		.loc 1 2042 2 is_stmt 1 view .LVU1820
 5054              		.loc 1 2042 9 is_stmt 0 view .LVU1821
 5055 0006 7047     		bx	lr
 5056              	.L445:
2038:ff.c          **** 
 5057              		.loc 1 2038 29 view .LVU1822
 5058 0008 0B20     		movs	r0, #11
 5059              	.LVL536:
2043:ff.c          **** }
 5060              		.loc 1 2043 1 view .LVU1823
 5061 000a 7047     		bx	lr
 5062              	.L447:
 5063              		.align	2
 5064              	.L446:
 5065 000c 00000000 		.word	.LANCHOR1
 5066              		.cfi_endproc
 5067              	.LFE58:
 5069              		.section	.text.f_chdir,"ax",%progbits
 5070              		.align	1
 5071              		.global	f_chdir
 5072              		.syntax unified
 5073              		.thumb
 5074              		.thumb_func
 5075              		.fpu softvfp
 5077              	f_chdir:
 5078              	.LVL537:
 5079              	.LFB59:
2044:ff.c          **** 
2045:ff.c          **** 
2046:ff.c          **** 
2047:ff.c          **** 
2048:ff.c          **** FRESULT f_chdir (
2049:ff.c          **** 	const XCHAR *path	/* Pointer to the directory path */
2050:ff.c          **** )
2051:ff.c          **** {
 5080              		.loc 1 2051 1 is_stmt 1 view -0
 5081              		.cfi_startproc
 5082              		@ args = 0, pretend = 0, frame = 48
 5083              		@ frame_needed = 0, uses_anonymous_args = 0
2052:ff.c          **** 	FRESULT res;
 5084              		.loc 1 2052 2 view .LVU1825
2053:ff.c          **** 	DIR dj;
 5085              		.loc 1 2053 2 view .LVU1826
2054:ff.c          **** 	NAMEBUF(sfn, lfn);
 5086              		.loc 1 2054 2 view .LVU1827
2055:ff.c          **** 	BYTE *dir;
 5087              		.loc 1 2055 2 view .LVU1828
2056:ff.c          **** 
2057:ff.c          **** 
2058:ff.c          **** 	res = auto_mount(&path, &dj.fs, 0);
 5088              		.loc 1 2058 2 view .LVU1829
2051:ff.c          **** 	FRESULT res;
 5089              		.loc 1 2051 1 is_stmt 0 view .LVU1830
 5090 0000 00B5     		push	{lr}
 5091              		.cfi_def_cfa_offset 4
 5092              		.cfi_offset 14, -4
 5093 0002 8DB0     		sub	sp, sp, #52
 5094              		.cfi_def_cfa_offset 56
2051:ff.c          **** 	FRESULT res;
 5095              		.loc 1 2051 1 view .LVU1831
 5096 0004 0190     		str	r0, [sp, #4]
 5097              		.loc 1 2058 8 view .LVU1832
 5098 0006 0022     		movs	r2, #0
 5099 0008 05A9     		add	r1, sp, #20
 5100 000a 01A8     		add	r0, sp, #4
 5101              	.LVL538:
 5102              		.loc 1 2058 8 view .LVU1833
 5103 000c FFF7FEFF 		bl	auto_mount
 5104              	.LVL539:
2059:ff.c          **** 	if (res == FR_OK) {
 5105              		.loc 1 2059 2 is_stmt 1 view .LVU1834
 5106              		.loc 1 2059 5 is_stmt 0 view .LVU1835
 5107 0010 50B9     		cbnz	r0, .L449
2060:ff.c          **** 		INITBUF(dj, sfn, lfn);
 5108              		.loc 1 2060 3 is_stmt 1 view .LVU1836
 5109 0012 02AB     		add	r3, sp, #8
2061:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the file path */
 5110              		.loc 1 2061 9 is_stmt 0 view .LVU1837
 5111 0014 0199     		ldr	r1, [sp, #4]
 5112 0016 05A8     		add	r0, sp, #20
 5113              	.LVL540:
2060:ff.c          **** 		INITBUF(dj, sfn, lfn);
 5114              		.loc 1 2060 3 view .LVU1838
 5115 0018 0B93     		str	r3, [sp, #44]
 5116              		.loc 1 2061 3 is_stmt 1 view .LVU1839
 5117              		.loc 1 2061 9 is_stmt 0 view .LVU1840
 5118 001a FFF7FEFF 		bl	follow_path
 5119              	.LVL541:
2062:ff.c          **** 		if (res == FR_OK) {					/* Follow completed */
 5120              		.loc 1 2062 3 is_stmt 1 view .LVU1841
 5121              		.loc 1 2062 6 is_stmt 0 view .LVU1842
 5122 001e B0B9     		cbnz	r0, .L450
2063:ff.c          **** 			dir = dj.dir;					/* Pointer to the entry */
 5123              		.loc 1 2063 4 is_stmt 1 view .LVU1843
 5124              		.loc 1 2063 8 is_stmt 0 view .LVU1844
 5125 0020 0A9B     		ldr	r3, [sp, #40]
 5126              	.LVL542:
2064:ff.c          **** 			if (!dir) {
 5127              		.loc 1 2064 4 is_stmt 1 view .LVU1845
 5128              		.loc 1 2064 7 is_stmt 0 view .LVU1846
 5129 0022 23B9     		cbnz	r3, .L451
2065:ff.c          **** 				dj.fs->cdir = 0;			/* No entry (root dir) */
 5130              		.loc 1 2065 5 is_stmt 1 view .LVU1847
 5131              		.loc 1 2065 17 is_stmt 0 view .LVU1848
 5132 0024 059B     		ldr	r3, [sp, #20]
 5133              	.LVL543:
 5134              		.loc 1 2065 17 view .LVU1849
 5135 0026 9861     		str	r0, [r3, #24]
 5136              	.LVL544:
 5137              	.L449:
2066:ff.c          **** 			} else {
2067:ff.c          **** 				if (dir[DIR_Attr] & AM_DIR)	/* Reached to the dir */
2068:ff.c          **** 					dj.fs->cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
2069:ff.c          **** 				else
2070:ff.c          **** 					res = FR_NO_PATH;		/* Could not reach the dir (it is a file) */
2071:ff.c          **** 			}
2072:ff.c          **** 		}
2073:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
2074:ff.c          **** 	}
2075:ff.c          **** 
2076:ff.c          **** 	LEAVE_FF(dj.fs, res);
 5138              		.loc 1 2076 2 is_stmt 1 view .LVU1850
2077:ff.c          **** }
 5139              		.loc 1 2077 1 is_stmt 0 view .LVU1851
 5140 0028 0DB0     		add	sp, sp, #52
 5141              		.cfi_remember_state
 5142              		.cfi_def_cfa_offset 4
 5143              		@ sp needed
 5144 002a 5DF804FB 		ldr	pc, [sp], #4
 5145              	.LVL545:
 5146              	.L451:
 5147              		.cfi_restore_state
2067:ff.c          **** 					dj.fs->cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5148              		.loc 1 2067 5 is_stmt 1 view .LVU1852
2067:ff.c          **** 					dj.fs->cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5149              		.loc 1 2067 8 is_stmt 0 view .LVU1853
 5150 002e DA7A     		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 5151 0030 D206     		lsls	r2, r2, #27
 5152 0032 10D5     		bpl	.L452
2068:ff.c          **** 				else
 5153              		.loc 1 2068 6 is_stmt 1 view .LVU1854
2068:ff.c          **** 				else
 5154              		.loc 1 2068 28 is_stmt 0 view .LVU1855
 5155 0034 597D     		ldrb	r1, [r3, #21]	@ zero_extendqisi2
 5156 0036 1A7D     		ldrb	r2, [r3, #20]	@ zero_extendqisi2
2068:ff.c          **** 				else
 5157              		.loc 1 2068 21 view .LVU1856
 5158 0038 42EA0122 		orr	r2, r2, r1, lsl #8
2068:ff.c          **** 				else
 5159              		.loc 1 2068 64 view .LVU1857
 5160 003c D97E     		ldrb	r1, [r3, #27]	@ zero_extendqisi2
 5161 003e 9B7E     		ldrb	r3, [r3, #26]	@ zero_extendqisi2
 5162              	.LVL546:
2068:ff.c          **** 				else
 5163              		.loc 1 2068 64 view .LVU1858
 5164 0040 43EA0123 		orr	r3, r3, r1, lsl #8
2068:ff.c          **** 				else
 5165              		.loc 1 2068 62 view .LVU1859
 5166 0044 43EA0243 		orr	r3, r3, r2, lsl #16
2068:ff.c          **** 				else
 5167              		.loc 1 2068 18 view .LVU1860
 5168 0048 059A     		ldr	r2, [sp, #20]
 5169 004a 9361     		str	r3, [r2, #24]
 5170 004c ECE7     		b	.L449
 5171              	.LVL547:
 5172              	.L450:
2073:ff.c          **** 	}
 5173              		.loc 1 2073 3 is_stmt 1 view .LVU1861
2073:ff.c          **** 	}
 5174              		.loc 1 2073 6 is_stmt 0 view .LVU1862
 5175 004e 0428     		cmp	r0, #4
2070:ff.c          **** 			}
 5176              		.loc 1 2070 10 view .LVU1863
 5177 0050 08BF     		it	eq
 5178 0052 0520     		moveq	r0, #5
 5179              	.LVL548:
2070:ff.c          **** 			}
 5180              		.loc 1 2070 10 view .LVU1864
 5181 0054 E8E7     		b	.L449
 5182              	.LVL549:
 5183              	.L452:
2070:ff.c          **** 			}
 5184              		.loc 1 2070 10 view .LVU1865
 5185 0056 0520     		movs	r0, #5
 5186              	.LVL550:
2070:ff.c          **** 			}
 5187              		.loc 1 2070 10 view .LVU1866
 5188 0058 E6E7     		b	.L449
 5189              		.cfi_endproc
 5190              	.LFE59:
 5192              		.section	.text.f_lseek,"ax",%progbits
 5193              		.align	1
 5194              		.global	f_lseek
 5195              		.syntax unified
 5196              		.thumb
 5197              		.thumb_func
 5198              		.fpu softvfp
 5200              	f_lseek:
 5201              	.LVL551:
 5202              	.LFB60:
2078:ff.c          **** 
2079:ff.c          **** #endif
2080:ff.c          **** 
2081:ff.c          **** 
2082:ff.c          **** 
2083:ff.c          **** #if _FS_MINIMIZE <= 2
2084:ff.c          **** /*-----------------------------------------------------------------------*/
2085:ff.c          **** /* Seek File R/W Pointer                                                 */
2086:ff.c          **** /*-----------------------------------------------------------------------*/
2087:ff.c          **** 
2088:ff.c          **** FRESULT f_lseek (
2089:ff.c          **** 	FIL *fp,		/* Pointer to the file object */
2090:ff.c          **** 	DWORD ofs		/* File pointer from top of file */
2091:ff.c          **** )
2092:ff.c          **** {
 5203              		.loc 1 2092 1 is_stmt 1 view -0
 5204              		.cfi_startproc
 5205              		@ args = 0, pretend = 0, frame = 0
 5206              		@ frame_needed = 0, uses_anonymous_args = 0
2093:ff.c          **** 	FRESULT res;
 5207              		.loc 1 2093 2 view .LVU1868
2094:ff.c          **** 	DWORD clst, bcs, nsect, ifptr;
 5208              		.loc 1 2094 2 view .LVU1869
2095:ff.c          **** 
2096:ff.c          **** 
2097:ff.c          **** 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 5209              		.loc 1 2097 2 view .LVU1870
2092:ff.c          **** 	FRESULT res;
 5210              		.loc 1 2092 1 is_stmt 0 view .LVU1871
 5211 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5212              		.cfi_def_cfa_offset 24
 5213              		.cfi_offset 3, -24
 5214              		.cfi_offset 4, -20
 5215              		.cfi_offset 5, -16
 5216              		.cfi_offset 6, -12
 5217              		.cfi_offset 7, -8
 5218              		.cfi_offset 14, -4
2092:ff.c          **** 	FRESULT res;
 5219              		.loc 1 2092 1 view .LVU1872
 5220 0002 0446     		mov	r4, r0
 5221 0004 0D46     		mov	r5, r1
 5222              		.loc 1 2097 8 view .LVU1873
 5223 0006 8188     		ldrh	r1, [r0, #4]
 5224              	.LVL552:
 5225              		.loc 1 2097 8 view .LVU1874
 5226 0008 0068     		ldr	r0, [r0]
 5227              	.LVL553:
 5228              		.loc 1 2097 8 view .LVU1875
 5229 000a FFF7FEFF 		bl	validate
 5230              	.LVL554:
2098:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 5231              		.loc 1 2098 2 is_stmt 1 view .LVU1876
 5232              		.loc 1 2098 5 is_stmt 0 view .LVU1877
 5233 000e 0646     		mov	r6, r0
 5234 0010 0028     		cmp	r0, #0
 5235 0012 49D1     		bne	.L454
2099:ff.c          **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
 5236              		.loc 1 2099 2 is_stmt 1 view .LVU1878
 5237              		.loc 1 2099 5 is_stmt 0 view .LVU1879
 5238 0014 94F90630 		ldrsb	r3, [r4, #6]
 5239              		.loc 1 2099 8 view .LVU1880
 5240 0018 A279     		ldrb	r2, [r4, #6]	@ zero_extendqisi2
 5241              		.loc 1 2099 5 view .LVU1881
 5242 001a 002B     		cmp	r3, #0
 5243 001c 51DB     		blt	.L477
2100:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2101:ff.c          **** 	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 5244              		.loc 1 2101 2 is_stmt 1 view .LVU1882
 5245              		.loc 1 2101 14 is_stmt 0 view .LVU1883
 5246 001e E368     		ldr	r3, [r4, #12]
 5247              		.loc 1 2101 5 view .LVU1884
 5248 0020 AB42     		cmp	r3, r5
 5249 0022 03D2     		bcs	.L455
2102:ff.c          **** #if !_FS_READONLY
2103:ff.c          **** 		 && !(fp->flag & FA_WRITE)
 5250              		.loc 1 2103 4 view .LVU1885
 5251 0024 12F0020F 		tst	r2, #2
 5252 0028 08BF     		it	eq
 5253 002a 1D46     		moveq	r5, r3
 5254              	.LVL555:
 5255              	.L455:
2104:ff.c          **** #endif
2105:ff.c          **** 		) ofs = fp->fsize;
2106:ff.c          **** 
2107:ff.c          **** 	ifptr = fp->fptr;
 5256              		.loc 1 2107 2 is_stmt 1 view .LVU1886
2108:ff.c          **** 	fp->fptr = nsect = 0; fp->csect = 255;
 5257              		.loc 1 2108 11 is_stmt 0 view .LVU1887
 5258 002c 0022     		movs	r2, #0
2107:ff.c          **** 	fp->fptr = nsect = 0; fp->csect = 255;
 5259              		.loc 1 2107 8 view .LVU1888
 5260 002e A368     		ldr	r3, [r4, #8]
 5261              	.LVL556:
 5262              		.loc 1 2108 2 is_stmt 1 view .LVU1889
 5263              		.loc 1 2108 11 is_stmt 0 view .LVU1890
 5264 0030 A260     		str	r2, [r4, #8]
 5265              		.loc 1 2108 24 is_stmt 1 view .LVU1891
 5266              		.loc 1 2108 34 is_stmt 0 view .LVU1892
 5267 0032 FF22     		movs	r2, #255
 5268 0034 E271     		strb	r2, [r4, #7]
2109:ff.c          **** 	if (ofs > 0) {
 5269              		.loc 1 2109 2 is_stmt 1 view .LVU1893
 5270              		.loc 1 2109 5 is_stmt 0 view .LVU1894
 5271 0036 4DB9     		cbnz	r5, .L456
 5272              	.LVL557:
 5273              	.L457:
2110:ff.c          **** 		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
2111:ff.c          **** 		if (ifptr > 0 &&
2112:ff.c          **** 			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
2113:ff.c          **** 			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
2114:ff.c          **** 			ofs -= fp->fptr;
2115:ff.c          **** 			clst = fp->curr_clust;
2116:ff.c          **** 		} else {									/* When seek to back cluster, */
2117:ff.c          **** 			clst = fp->org_clust;					/* start from the first cluster */
2118:ff.c          **** #if !_FS_READONLY
2119:ff.c          **** 			if (clst == 0) {						/* If no cluster chain, create a new chain */
2120:ff.c          **** 				clst = create_chain(fp->fs, 0);
2121:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
2122:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2123:ff.c          **** 				fp->org_clust = clst;
2124:ff.c          **** 			}
2125:ff.c          **** #endif
2126:ff.c          **** 			fp->curr_clust = clst;
2127:ff.c          **** 		}
2128:ff.c          **** 		if (clst != 0) {
2129:ff.c          **** 			while (ofs > bcs) {						/* Cluster following loop */
2130:ff.c          **** #if !_FS_READONLY
2131:ff.c          **** 				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
2132:ff.c          **** 					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
2133:ff.c          **** 					if (clst == 0) {				/* When disk gets full, clip file size */
2134:ff.c          **** 						ofs = bcs; break;
2135:ff.c          **** 					}
2136:ff.c          **** 				} else
2137:ff.c          **** #endif
2138:ff.c          **** 					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
2139:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2140:ff.c          **** 				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
2141:ff.c          **** 				fp->curr_clust = clst;
2142:ff.c          **** 				fp->fptr += bcs;
2143:ff.c          **** 				ofs -= bcs;
2144:ff.c          **** 			}
2145:ff.c          **** 			fp->fptr += ofs;
2146:ff.c          **** 			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
2147:ff.c          **** 			if (ofs % SS(fp->fs)) {
2148:ff.c          **** 				nsect = clust2sect(fp->fs, clst);	/* Current sector */
2149:ff.c          **** 				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
2150:ff.c          **** 				nsect += fp->csect;
2151:ff.c          **** 				fp->csect++;
2152:ff.c          **** 			}
2153:ff.c          **** 		}
2154:ff.c          **** 	}
2155:ff.c          **** 	if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
2156:ff.c          **** #if !_FS_TINY
2157:ff.c          **** #if !_FS_READONLY
2158:ff.c          **** 		if (fp->flag & FA__DIRTY) {			/* Write-back dirty buffer if needed */
2159:ff.c          **** 			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
2160:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
2161:ff.c          **** 			fp->flag &= ~FA__DIRTY;
2162:ff.c          **** 		}
2163:ff.c          **** #endif
2164:ff.c          **** 		if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
2165:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
2166:ff.c          **** #endif
2167:ff.c          **** 		fp->dsect = nsect;
2168:ff.c          **** 	}
2169:ff.c          **** #if !_FS_READONLY
2170:ff.c          **** 	if (fp->fptr > fp->fsize) {			/* Set changed flag if the file size is extended */
 5274              		.loc 1 2170 2 is_stmt 1 view .LVU1895
 5275              		.loc 1 2170 5 is_stmt 0 view .LVU1896
 5276 0038 D4E90232 		ldrd	r3, r2, [r4, #8]
 5277 003c 9342     		cmp	r3, r2
 5278 003e 33D9     		bls	.L454
2171:ff.c          **** 		fp->fsize = fp->fptr;
 5279              		.loc 1 2171 3 is_stmt 1 view .LVU1897
 5280              		.loc 1 2171 13 is_stmt 0 view .LVU1898
 5281 0040 E360     		str	r3, [r4, #12]
2172:ff.c          **** 		fp->flag |= FA__WRITTEN;
 5282              		.loc 1 2172 3 is_stmt 1 view .LVU1899
 5283              		.loc 1 2172 12 is_stmt 0 view .LVU1900
 5284 0042 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 5285 0044 43F02003 		orr	r3, r3, #32
 5286 0048 A371     		strb	r3, [r4, #6]
 5287 004a 2DE0     		b	.L454
 5288              	.LVL558:
 5289              	.L456:
2110:ff.c          **** 		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 5290              		.loc 1 2110 3 is_stmt 1 view .LVU1901
2110:ff.c          **** 		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 5291              		.loc 1 2110 18 is_stmt 0 view .LVU1902
 5292 004c 2068     		ldr	r0, [r4]
 5293              	.LVL559:
2110:ff.c          **** 		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 5294              		.loc 1 2110 9 view .LVU1903
 5295 004e 8778     		ldrb	r7, [r0, #2]	@ zero_extendqisi2
2110:ff.c          **** 		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 5296              		.loc 1 2110 7 view .LVU1904
 5297 0050 7F02     		lsls	r7, r7, #9
 5298              	.LVL560:
2111:ff.c          **** 			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 5299              		.loc 1 2111 3 is_stmt 1 view .LVU1905
2111:ff.c          **** 			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 5300              		.loc 1 2111 6 is_stmt 0 view .LVU1906
 5301 0052 5BB3     		cbz	r3, .L459
2112:ff.c          **** 			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 5302              		.loc 1 2112 30 discriminator 1 view .LVU1907
 5303 0054 013B     		subs	r3, r3, #1
 5304              	.LVL561:
2112:ff.c          **** 			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 5305              		.loc 1 2112 9 discriminator 1 view .LVU1908
 5306 0056 6A1E     		subs	r2, r5, #1
2112:ff.c          **** 			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 5307              		.loc 1 2112 14 discriminator 1 view .LVU1909
 5308 0058 B2FBF7F2 		udiv	r2, r2, r7
2112:ff.c          **** 			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 5309              		.loc 1 2112 35 discriminator 1 view .LVU1910
 5310 005c B3FBF7F1 		udiv	r1, r3, r7
2111:ff.c          **** 			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 5311              		.loc 1 2111 17 discriminator 1 view .LVU1911
 5312 0060 8A42     		cmp	r2, r1
 5313 0062 23D3     		bcc	.L459
2113:ff.c          **** 			ofs -= fp->fptr;
 5314              		.loc 1 2113 4 is_stmt 1 view .LVU1912
2113:ff.c          **** 			ofs -= fp->fptr;
 5315              		.loc 1 2113 29 is_stmt 0 view .LVU1913
 5316 0064 7A42     		rsbs	r2, r7, #0
2113:ff.c          **** 			ofs -= fp->fptr;
 5317              		.loc 1 2113 27 view .LVU1914
 5318 0066 1340     		ands	r3, r3, r2
 5319              	.LVL562:
2115:ff.c          **** 		} else {									/* When seek to back cluster, */
 5320              		.loc 1 2115 9 view .LVU1915
 5321 0068 6169     		ldr	r1, [r4, #20]
2113:ff.c          **** 			ofs -= fp->fptr;
 5322              		.loc 1 2113 13 view .LVU1916
 5323 006a A360     		str	r3, [r4, #8]
2114:ff.c          **** 			clst = fp->curr_clust;
 5324              		.loc 1 2114 4 is_stmt 1 view .LVU1917
2114:ff.c          **** 			clst = fp->curr_clust;
 5325              		.loc 1 2114 8 is_stmt 0 view .LVU1918
 5326 006c ED1A     		subs	r5, r5, r3
 5327              	.LVL563:
2115:ff.c          **** 		} else {									/* When seek to back cluster, */
 5328              		.loc 1 2115 4 is_stmt 1 view .LVU1919
 5329              	.L460:
2128:ff.c          **** 			while (ofs > bcs) {						/* Cluster following loop */
 5330              		.loc 1 2128 3 view .LVU1920
2128:ff.c          **** 			while (ofs > bcs) {						/* Cluster following loop */
 5331              		.loc 1 2128 6 is_stmt 0 view .LVU1921
 5332 006e 0029     		cmp	r1, #0
 5333 0070 4AD1     		bne	.L464
 5334              	.LVL564:
 5335              	.L465:
2108:ff.c          **** 	if (ofs > 0) {
 5336              		.loc 1 2108 19 view .LVU1922
 5337 0072 0025     		movs	r5, #0
 5338              	.LVL565:
 5339              	.L458:
2155:ff.c          **** #if !_FS_TINY
 5340              		.loc 1 2155 2 is_stmt 1 view .LVU1923
2155:ff.c          **** #if !_FS_TINY
 5341              		.loc 1 2155 15 is_stmt 0 view .LVU1924
 5342 0074 A368     		ldr	r3, [r4, #8]
 5343 0076 C3F30803 		ubfx	r3, r3, #0, #9
2155:ff.c          **** #if !_FS_TINY
 5344              		.loc 1 2155 5 view .LVU1925
 5345 007a 002B     		cmp	r3, #0
 5346 007c DCD0     		beq	.L457
2155:ff.c          **** #if !_FS_TINY
 5347              		.loc 1 2155 42 discriminator 1 view .LVU1926
 5348 007e A269     		ldr	r2, [r4, #24]
2155:ff.c          **** #if !_FS_TINY
 5349              		.loc 1 2155 28 discriminator 1 view .LVU1927
 5350 0080 AA42     		cmp	r2, r5
 5351 0082 D9D0     		beq	.L457
2158:ff.c          **** 			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 5352              		.loc 1 2158 3 is_stmt 1 view .LVU1928
2158:ff.c          **** 			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 5353              		.loc 1 2158 6 is_stmt 0 view .LVU1929
 5354 0084 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 5355 0086 04F12407 		add	r7, r4, #36
 5356 008a 5B06     		lsls	r3, r3, #25
 5357 008c 55D5     		bpl	.L474
2159:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
 5358              		.loc 1 2159 4 is_stmt 1 view .LVU1930
2159:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
 5359              		.loc 1 2159 8 is_stmt 0 view .LVU1931
 5360 008e 2068     		ldr	r0, [r4]
 5361 0090 0123     		movs	r3, #1
 5362 0092 3946     		mov	r1, r7
 5363 0094 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 5364 0096 FFF7FEFF 		bl	disk_write
 5365              	.LVL566:
 5366 009a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
2159:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
 5367              		.loc 1 2159 7 view .LVU1932
 5368 009c 0028     		cmp	r0, #0
 5369 009e 49D0     		beq	.L475
 5370              	.LVL567:
 5371              	.L493:
2165:ff.c          **** #endif
 5372              		.loc 1 2165 4 view .LVU1933
 5373 00a0 0126     		movs	r6, #1
 5374 00a2 63F07F03 		orn	r3, r3, #127
 5375 00a6 A371     		strb	r3, [r4, #6]
2165:ff.c          **** #endif
 5376              		.loc 1 2165 4 is_stmt 1 view .LVU1934
 5377              	.L454:
2173:ff.c          **** 	}
2174:ff.c          **** #endif
2175:ff.c          **** 
2176:ff.c          **** 	LEAVE_FF(fp->fs, res);
2177:ff.c          **** }
 5378              		.loc 1 2177 1 is_stmt 0 view .LVU1935
 5379 00a8 3046     		mov	r0, r6
 5380 00aa F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5381              	.LVL568:
 5382              	.L459:
2117:ff.c          **** #if !_FS_READONLY
 5383              		.loc 1 2117 4 is_stmt 1 view .LVU1936
2117:ff.c          **** #if !_FS_READONLY
 5384              		.loc 1 2117 9 is_stmt 0 view .LVU1937
 5385 00ac 2169     		ldr	r1, [r4, #16]
 5386              	.LVL569:
2119:ff.c          **** 				clst = create_chain(fp->fs, 0);
 5387              		.loc 1 2119 4 is_stmt 1 view .LVU1938
2119:ff.c          **** 				clst = create_chain(fp->fs, 0);
 5388              		.loc 1 2119 7 is_stmt 0 view .LVU1939
 5389 00ae 79B9     		cbnz	r1, .L461
2120:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 5390              		.loc 1 2120 5 is_stmt 1 view .LVU1940
2120:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 5391              		.loc 1 2120 12 is_stmt 0 view .LVU1941
 5392 00b0 FFF7FEFF 		bl	create_chain
 5393              	.LVL570:
2121:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5394              		.loc 1 2121 8 view .LVU1942
 5395 00b4 0128     		cmp	r0, #1
2120:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 5396              		.loc 1 2120 12 view .LVU1943
 5397 00b6 0146     		mov	r1, r0
 5398              	.LVL571:
2121:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5399              		.loc 1 2121 5 is_stmt 1 view .LVU1944
2121:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5400              		.loc 1 2121 8 is_stmt 0 view .LVU1945
 5401 00b8 05D1     		bne	.L462
 5402              	.LVL572:
 5403              	.L494:
2149:ff.c          **** 				nsect += fp->csect;
 5404              		.loc 1 2149 17 is_stmt 1 discriminator 1 view .LVU1946
 5405 00ba A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 5406 00bc 63F07F03 		orn	r3, r3, #127
 5407 00c0 A371     		strb	r3, [r4, #6]
2149:ff.c          **** 				nsect += fp->csect;
 5408              		.loc 1 2149 17 discriminator 1 view .LVU1947
 5409              	.L477:
2100:ff.c          **** 	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 5410              		.loc 1 2100 3 is_stmt 0 view .LVU1948
 5411 00c2 0226     		movs	r6, #2
 5412 00c4 F0E7     		b	.L454
 5413              	.LVL573:
 5414              	.L462:
2121:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5415              		.loc 1 2121 45 is_stmt 1 discriminator 2 view .LVU1949
2122:ff.c          **** 				fp->org_clust = clst;
 5416              		.loc 1 2122 5 discriminator 2 view .LVU1950
2122:ff.c          **** 				fp->org_clust = clst;
 5417              		.loc 1 2122 8 is_stmt 0 discriminator 2 view .LVU1951
 5418 00c6 421C     		adds	r2, r0, #1
 5419 00c8 01D1     		bne	.L463
 5420              	.LVL574:
 5421              	.L492:
2165:ff.c          **** #endif
 5422              		.loc 1 2165 4 is_stmt 1 view .LVU1952
 5423 00ca A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 5424 00cc E8E7     		b	.L493
 5425              	.LVL575:
 5426              	.L463:
2122:ff.c          **** 				fp->org_clust = clst;
 5427              		.loc 1 2122 55 discriminator 2 view .LVU1953
2123:ff.c          **** 			}
 5428              		.loc 1 2123 5 discriminator 2 view .LVU1954
2123:ff.c          **** 			}
 5429              		.loc 1 2123 19 is_stmt 0 discriminator 2 view .LVU1955
 5430 00ce 2061     		str	r0, [r4, #16]
 5431              	.LVL576:
 5432              	.L461:
2126:ff.c          **** 		}
 5433              		.loc 1 2126 4 is_stmt 1 view .LVU1956
2126:ff.c          **** 		}
 5434              		.loc 1 2126 19 is_stmt 0 view .LVU1957
 5435 00d0 6161     		str	r1, [r4, #20]
 5436 00d2 CCE7     		b	.L460
 5437              	.L472:
2131:ff.c          **** 					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
 5438              		.loc 1 2131 5 is_stmt 1 view .LVU1958
2131:ff.c          **** 					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
 5439              		.loc 1 2131 8 is_stmt 0 view .LVU1959
 5440 00d4 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 5441 00d6 2068     		ldr	r0, [r4]
 5442 00d8 9B07     		lsls	r3, r3, #30
 5443 00da 05D5     		bpl	.L466
2132:ff.c          **** 					if (clst == 0) {				/* When disk gets full, clip file size */
 5444              		.loc 1 2132 6 is_stmt 1 view .LVU1960
2132:ff.c          **** 					if (clst == 0) {				/* When disk gets full, clip file size */
 5445              		.loc 1 2132 13 is_stmt 0 view .LVU1961
 5446 00dc FFF7FEFF 		bl	create_chain
 5447              	.LVL577:
2133:ff.c          **** 						ofs = bcs; break;
 5448              		.loc 1 2133 6 is_stmt 1 view .LVU1962
2133:ff.c          **** 						ofs = bcs; break;
 5449              		.loc 1 2133 9 is_stmt 0 view .LVU1963
 5450 00e0 0146     		mov	r1, r0
 5451 00e2 20B9     		cbnz	r0, .L468
 5452 00e4 3D46     		mov	r5, r7
 5453              	.LVL578:
2133:ff.c          **** 						ofs = bcs; break;
 5454              		.loc 1 2133 9 view .LVU1964
 5455 00e6 11E0     		b	.L467
 5456              	.LVL579:
 5457              	.L466:
2138:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5458              		.loc 1 2138 6 is_stmt 1 view .LVU1965
2138:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5459              		.loc 1 2138 13 is_stmt 0 view .LVU1966
 5460 00e8 FFF7FEFF 		bl	get_fat
 5461              	.LVL580:
2138:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5462              		.loc 1 2138 13 view .LVU1967
 5463 00ec 0146     		mov	r1, r0
 5464              	.LVL581:
 5465              	.L468:
2139:ff.c          **** 				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
 5466              		.loc 1 2139 5 is_stmt 1 view .LVU1968
2139:ff.c          **** 				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
 5467              		.loc 1 2139 8 is_stmt 0 view .LVU1969
 5468 00ee 4A1C     		adds	r2, r1, #1
 5469 00f0 EBD0     		beq	.L492
2139:ff.c          **** 				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
 5470              		.loc 1 2139 55 is_stmt 1 discriminator 2 view .LVU1970
2140:ff.c          **** 				fp->curr_clust = clst;
 5471              		.loc 1 2140 5 discriminator 2 view .LVU1971
2140:ff.c          **** 				fp->curr_clust = clst;
 5472              		.loc 1 2140 8 is_stmt 0 discriminator 2 view .LVU1972
 5473 00f2 0129     		cmp	r1, #1
 5474 00f4 E1D9     		bls	.L494
2140:ff.c          **** 				fp->curr_clust = clst;
 5475              		.loc 1 2140 36 discriminator 2 view .LVU1973
 5476 00f6 2368     		ldr	r3, [r4]
2140:ff.c          **** 				fp->curr_clust = clst;
 5477              		.loc 1 2140 19 discriminator 2 view .LVU1974
 5478 00f8 1B6A     		ldr	r3, [r3, #32]
 5479 00fa 8B42     		cmp	r3, r1
 5480 00fc DDD9     		bls	.L494
2140:ff.c          **** 				fp->curr_clust = clst;
 5481              		.loc 1 2140 74 is_stmt 1 discriminator 4 view .LVU1975
2141:ff.c          **** 				fp->fptr += bcs;
 5482              		.loc 1 2141 5 discriminator 4 view .LVU1976
2142:ff.c          **** 				ofs -= bcs;
 5483              		.loc 1 2142 14 is_stmt 0 discriminator 4 view .LVU1977
 5484 00fe A368     		ldr	r3, [r4, #8]
2141:ff.c          **** 				fp->fptr += bcs;
 5485              		.loc 1 2141 20 discriminator 4 view .LVU1978
 5486 0100 6161     		str	r1, [r4, #20]
2142:ff.c          **** 				ofs -= bcs;
 5487              		.loc 1 2142 5 is_stmt 1 discriminator 4 view .LVU1979
2142:ff.c          **** 				ofs -= bcs;
 5488              		.loc 1 2142 14 is_stmt 0 discriminator 4 view .LVU1980
 5489 0102 3B44     		add	r3, r3, r7
 5490 0104 A360     		str	r3, [r4, #8]
2143:ff.c          **** 			}
 5491              		.loc 1 2143 5 is_stmt 1 discriminator 4 view .LVU1981
2143:ff.c          **** 			}
 5492              		.loc 1 2143 9 is_stmt 0 discriminator 4 view .LVU1982
 5493 0106 ED1B     		subs	r5, r5, r7
 5494              	.LVL582:
 5495              	.L464:
2129:ff.c          **** #if !_FS_READONLY
 5496              		.loc 1 2129 10 is_stmt 1 view .LVU1983
 5497 0108 BD42     		cmp	r5, r7
 5498 010a E3D8     		bhi	.L472
 5499              	.LVL583:
 5500              	.L467:
2145:ff.c          **** 			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 5501              		.loc 1 2145 4 view .LVU1984
2145:ff.c          **** 			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 5502              		.loc 1 2145 13 is_stmt 0 view .LVU1985
 5503 010c A368     		ldr	r3, [r4, #8]
2146:ff.c          **** 			if (ofs % SS(fp->fs)) {
 5504              		.loc 1 2146 16 view .LVU1986
 5505 010e C5F34722 		ubfx	r2, r5, #9, #8
2145:ff.c          **** 			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 5506              		.loc 1 2145 13 view .LVU1987
 5507 0112 2B44     		add	r3, r3, r5
2146:ff.c          **** 			if (ofs % SS(fp->fs)) {
 5508              		.loc 1 2146 27 view .LVU1988
 5509 0114 6F0A     		lsrs	r7, r5, #9
 5510              	.LVL584:
2147:ff.c          **** 				nsect = clust2sect(fp->fs, clst);	/* Current sector */
 5511              		.loc 1 2147 12 view .LVU1989
 5512 0116 C5F30805 		ubfx	r5, r5, #0, #9
 5513              	.LVL585:
2145:ff.c          **** 			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 5514              		.loc 1 2145 13 view .LVU1990
 5515 011a A360     		str	r3, [r4, #8]
2146:ff.c          **** 			if (ofs % SS(fp->fs)) {
 5516              		.loc 1 2146 4 is_stmt 1 view .LVU1991
2146:ff.c          **** 			if (ofs % SS(fp->fs)) {
 5517              		.loc 1 2146 14 is_stmt 0 view .LVU1992
 5518 011c E271     		strb	r2, [r4, #7]
2147:ff.c          **** 				nsect = clust2sect(fp->fs, clst);	/* Current sector */
 5519              		.loc 1 2147 4 is_stmt 1 view .LVU1993
2147:ff.c          **** 				nsect = clust2sect(fp->fs, clst);	/* Current sector */
 5520              		.loc 1 2147 7 is_stmt 0 view .LVU1994
 5521 011e 002D     		cmp	r5, #0
 5522 0120 A7D0     		beq	.L465
2148:ff.c          **** 				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 5523              		.loc 1 2148 5 is_stmt 1 view .LVU1995
2148:ff.c          **** 				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 5524              		.loc 1 2148 13 is_stmt 0 view .LVU1996
 5525 0122 2068     		ldr	r0, [r4]
 5526 0124 FFF7FEFF 		bl	clust2sect
 5527              	.LVL586:
2149:ff.c          **** 				nsect += fp->csect;
 5528              		.loc 1 2149 5 is_stmt 1 view .LVU1997
2149:ff.c          **** 				nsect += fp->csect;
 5529              		.loc 1 2149 8 is_stmt 0 view .LVU1998
 5530 0128 0028     		cmp	r0, #0
 5531 012a C6D0     		beq	.L494
2149:ff.c          **** 				nsect += fp->csect;
 5532              		.loc 1 2149 42 is_stmt 1 discriminator 2 view .LVU1999
2150:ff.c          **** 				fp->csect++;
 5533              		.loc 1 2150 5 discriminator 2 view .LVU2000
2151:ff.c          **** 			}
 5534              		.loc 1 2151 14 is_stmt 0 discriminator 2 view .LVU2001
 5535 012c 0132     		adds	r2, r2, #1
2150:ff.c          **** 				fp->csect++;
 5536              		.loc 1 2150 11 discriminator 2 view .LVU2002
 5537 012e 3D18     		adds	r5, r7, r0
 5538              	.LVL587:
2151:ff.c          **** 			}
 5539              		.loc 1 2151 5 is_stmt 1 discriminator 2 view .LVU2003
2151:ff.c          **** 			}
 5540              		.loc 1 2151 14 is_stmt 0 discriminator 2 view .LVU2004
 5541 0130 E271     		strb	r2, [r4, #7]
 5542 0132 9FE7     		b	.L458
 5543              	.L475:
2160:ff.c          **** 			fp->flag &= ~FA__DIRTY;
 5544              		.loc 1 2160 31 is_stmt 1 view .LVU2005
2161:ff.c          **** 		}
 5545              		.loc 1 2161 4 view .LVU2006
2161:ff.c          **** 		}
 5546              		.loc 1 2161 13 is_stmt 0 view .LVU2007
 5547 0134 23F04003 		bic	r3, r3, #64
 5548 0138 A371     		strb	r3, [r4, #6]
 5549              	.L474:
2164:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
 5550              		.loc 1 2164 3 is_stmt 1 view .LVU2008
2164:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
 5551              		.loc 1 2164 7 is_stmt 0 view .LVU2009
 5552 013a 2068     		ldr	r0, [r4]
 5553 013c 0123     		movs	r3, #1
 5554 013e 2A46     		mov	r2, r5
 5555 0140 3946     		mov	r1, r7
 5556 0142 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 5557 0144 FFF7FEFF 		bl	disk_read
 5558              	.LVL588:
2164:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
 5559              		.loc 1 2164 6 view .LVU2010
 5560 0148 0028     		cmp	r0, #0
 5561 014a BED1     		bne	.L492
2165:ff.c          **** #endif
 5562              		.loc 1 2165 30 is_stmt 1 view .LVU2011
2167:ff.c          **** 	}
 5563              		.loc 1 2167 3 view .LVU2012
2167:ff.c          **** 	}
 5564              		.loc 1 2167 13 is_stmt 0 view .LVU2013
 5565 014c A561     		str	r5, [r4, #24]
 5566 014e 73E7     		b	.L457
 5567              		.cfi_endproc
 5568              	.LFE60:
 5570              		.section	.text.f_opendir,"ax",%progbits
 5571              		.align	1
 5572              		.global	f_opendir
 5573              		.syntax unified
 5574              		.thumb
 5575              		.thumb_func
 5576              		.fpu softvfp
 5578              	f_opendir:
 5579              	.LVL589:
 5580              	.LFB61:
2178:ff.c          **** 
2179:ff.c          **** 
2180:ff.c          **** 
2181:ff.c          **** 
2182:ff.c          **** #if _FS_MINIMIZE <= 1
2183:ff.c          **** /*-----------------------------------------------------------------------*/
2184:ff.c          **** /* Create a Directroy Object                                             */
2185:ff.c          **** /*-----------------------------------------------------------------------*/
2186:ff.c          **** 
2187:ff.c          **** FRESULT f_opendir (
2188:ff.c          **** 	DIR *dj,			/* Pointer to directory object to create */
2189:ff.c          **** 	const XCHAR *path	/* Pointer to the directory path */
2190:ff.c          **** )
2191:ff.c          **** {
 5581              		.loc 1 2191 1 is_stmt 1 view -0
 5582              		.cfi_startproc
 5583              		@ args = 0, pretend = 0, frame = 24
 5584              		@ frame_needed = 0, uses_anonymous_args = 0
2192:ff.c          **** 	FRESULT res;
 5585              		.loc 1 2192 2 view .LVU2015
2193:ff.c          **** 	NAMEBUF(sfn, lfn);
 5586              		.loc 1 2193 2 view .LVU2016
2194:ff.c          **** 	BYTE *dir;
 5587              		.loc 1 2194 2 view .LVU2017
2195:ff.c          **** 
2196:ff.c          **** 
2197:ff.c          **** 	res = auto_mount(&path, &dj->fs, 0);
 5588              		.loc 1 2197 2 view .LVU2018
2191:ff.c          **** 	FRESULT res;
 5589              		.loc 1 2191 1 is_stmt 0 view .LVU2019
 5590 0000 10B5     		push	{r4, lr}
 5591              		.cfi_def_cfa_offset 8
 5592              		.cfi_offset 4, -8
 5593              		.cfi_offset 14, -4
 5594 0002 86B0     		sub	sp, sp, #24
 5595              		.cfi_def_cfa_offset 32
2191:ff.c          **** 	FRESULT res;
 5596              		.loc 1 2191 1 view .LVU2020
 5597 0004 0446     		mov	r4, r0
 5598 0006 0191     		str	r1, [sp, #4]
 5599              		.loc 1 2197 8 view .LVU2021
 5600 0008 0022     		movs	r2, #0
 5601 000a 0146     		mov	r1, r0
 5602              	.LVL590:
 5603              		.loc 1 2197 8 view .LVU2022
 5604 000c 01A8     		add	r0, sp, #4
 5605              	.LVL591:
 5606              		.loc 1 2197 8 view .LVU2023
 5607 000e FFF7FEFF 		bl	auto_mount
 5608              	.LVL592:
2198:ff.c          **** 	if (res == FR_OK) {
 5609              		.loc 1 2198 2 is_stmt 1 view .LVU2024
 5610              		.loc 1 2198 5 is_stmt 0 view .LVU2025
 5611 0012 60B9     		cbnz	r0, .L496
2199:ff.c          **** 		INITBUF((*dj), sfn, lfn);
 5612              		.loc 1 2199 3 is_stmt 1 view .LVU2026
 5613 0014 03AB     		add	r3, sp, #12
2200:ff.c          **** 		res = follow_path(dj, path);			/* Follow the path to the directory */
 5614              		.loc 1 2200 9 is_stmt 0 view .LVU2027
 5615 0016 2046     		mov	r0, r4
 5616              	.LVL593:
 5617              		.loc 1 2200 9 view .LVU2028
 5618 0018 0199     		ldr	r1, [sp, #4]
2199:ff.c          **** 		INITBUF((*dj), sfn, lfn);
 5619              		.loc 1 2199 3 view .LVU2029
 5620 001a A361     		str	r3, [r4, #24]
 5621              		.loc 1 2200 3 is_stmt 1 view .LVU2030
 5622              		.loc 1 2200 9 is_stmt 0 view .LVU2031
 5623 001c FFF7FEFF 		bl	follow_path
 5624              	.LVL594:
2201:ff.c          **** 		if (res == FR_OK) {						/* Follow completed */
 5625              		.loc 1 2201 3 is_stmt 1 view .LVU2032
 5626              		.loc 1 2201 6 is_stmt 0 view .LVU2033
 5627 0020 C8B9     		cbnz	r0, .L497
2202:ff.c          **** 			dir = dj->dir;
 5628              		.loc 1 2202 4 is_stmt 1 view .LVU2034
 5629              		.loc 1 2202 8 is_stmt 0 view .LVU2035
 5630 0022 6369     		ldr	r3, [r4, #20]
 5631              	.LVL595:
2203:ff.c          **** 			if (dir) {							/* It is not the root dir */
 5632              		.loc 1 2203 4 is_stmt 1 view .LVU2036
 5633              		.loc 1 2203 7 is_stmt 0 view .LVU2037
 5634 0024 83B1     		cbz	r3, .L498
2204:ff.c          **** 				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 5635              		.loc 1 2204 5 is_stmt 1 view .LVU2038
 5636              		.loc 1 2204 8 is_stmt 0 view .LVU2039
 5637 0026 DA7A     		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 5638 0028 D206     		lsls	r2, r2, #27
 5639 002a 02D4     		bmi	.L499
 5640              	.LVL596:
 5641              	.L500:
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
2206:ff.c          **** 				} else {						/* The object is not a directory */
2207:ff.c          **** 					res = FR_NO_PATH;
 5642              		.loc 1 2207 10 view .LVU2040
 5643 002c 0520     		movs	r0, #5
 5644              	.LVL597:
 5645              	.L496:
2208:ff.c          **** 				}
2209:ff.c          **** 			}
2210:ff.c          **** 			if (res == FR_OK) {
2211:ff.c          **** 				dj->id = dj->fs->id;
2212:ff.c          **** 				res = dir_seek(dj, 0);			/* Rewind dir */
2213:ff.c          **** 			}
2214:ff.c          **** 		}
2215:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
2216:ff.c          **** 	}
2217:ff.c          **** 
2218:ff.c          **** 	LEAVE_FF(dj->fs, res);
 5646              		.loc 1 2218 2 is_stmt 1 view .LVU2041
2219:ff.c          **** }
 5647              		.loc 1 2219 1 is_stmt 0 view .LVU2042
 5648 002e 06B0     		add	sp, sp, #24
 5649              		.cfi_remember_state
 5650              		.cfi_def_cfa_offset 8
 5651              		@ sp needed
 5652 0030 10BD     		pop	{r4, pc}
 5653              	.LVL598:
 5654              	.L499:
 5655              		.cfi_restore_state
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5656              		.loc 1 2205 6 is_stmt 1 view .LVU2043
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5657              		.loc 1 2205 27 is_stmt 0 view .LVU2044
 5658 0032 597D     		ldrb	r1, [r3, #21]	@ zero_extendqisi2
 5659 0034 1A7D     		ldrb	r2, [r3, #20]	@ zero_extendqisi2
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5660              		.loc 1 2205 20 view .LVU2045
 5661 0036 42EA0122 		orr	r2, r2, r1, lsl #8
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5662              		.loc 1 2205 63 view .LVU2046
 5663 003a D97E     		ldrb	r1, [r3, #27]	@ zero_extendqisi2
 5664 003c 9B7E     		ldrb	r3, [r3, #26]	@ zero_extendqisi2
 5665              	.LVL599:
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5666              		.loc 1 2205 63 view .LVU2047
 5667 003e 43EA0123 		orr	r3, r3, r1, lsl #8
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5668              		.loc 1 2205 61 view .LVU2048
 5669 0042 43EA0243 		orr	r3, r3, r2, lsl #16
2205:ff.c          **** 					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 5670              		.loc 1 2205 17 view .LVU2049
 5671 0046 A360     		str	r3, [r4, #8]
 5672              	.L498:
 5673              	.LVL600:
2210:ff.c          **** 				dj->id = dj->fs->id;
 5674              		.loc 1 2210 4 is_stmt 1 view .LVU2050
2211:ff.c          **** 				res = dir_seek(dj, 0);			/* Rewind dir */
 5675              		.loc 1 2211 5 view .LVU2051
2211:ff.c          **** 				res = dir_seek(dj, 0);			/* Rewind dir */
 5676              		.loc 1 2211 20 is_stmt 0 view .LVU2052
 5677 0048 2368     		ldr	r3, [r4]
2212:ff.c          **** 			}
 5678              		.loc 1 2212 11 view .LVU2053
 5679 004a 0021     		movs	r1, #0
2211:ff.c          **** 				res = dir_seek(dj, 0);			/* Rewind dir */
 5680              		.loc 1 2211 12 view .LVU2054
 5681 004c DB88     		ldrh	r3, [r3, #6]
2212:ff.c          **** 			}
 5682              		.loc 1 2212 11 view .LVU2055
 5683 004e 2046     		mov	r0, r4
2211:ff.c          **** 				res = dir_seek(dj, 0);			/* Rewind dir */
 5684              		.loc 1 2211 12 view .LVU2056
 5685 0050 A380     		strh	r3, [r4, #4]	@ movhi
2212:ff.c          **** 			}
 5686              		.loc 1 2212 5 is_stmt 1 view .LVU2057
2212:ff.c          **** 			}
 5687              		.loc 1 2212 11 is_stmt 0 view .LVU2058
 5688 0052 FFF7FEFF 		bl	dir_seek
 5689              	.LVL601:
 5690              	.L497:
2215:ff.c          **** 	}
 5691              		.loc 1 2215 3 is_stmt 1 view .LVU2059
2215:ff.c          **** 	}
 5692              		.loc 1 2215 6 is_stmt 0 view .LVU2060
 5693 0056 0428     		cmp	r0, #4
 5694 0058 E9D1     		bne	.L496
2215:ff.c          **** 	}
 5695              		.loc 1 2215 6 view .LVU2061
 5696 005a E7E7     		b	.L500
 5697              		.cfi_endproc
 5698              	.LFE61:
 5700              		.section	.text.f_readdir,"ax",%progbits
 5701              		.align	1
 5702              		.global	f_readdir
 5703              		.syntax unified
 5704              		.thumb
 5705              		.thumb_func
 5706              		.fpu softvfp
 5708              	f_readdir:
 5709              	.LVL602:
 5710              	.LFB62:
2220:ff.c          **** 
2221:ff.c          **** 
2222:ff.c          **** 
2223:ff.c          **** 
2224:ff.c          **** /*-----------------------------------------------------------------------*/
2225:ff.c          **** /* Read Directory Entry in Sequense                                      */
2226:ff.c          **** /*-----------------------------------------------------------------------*/
2227:ff.c          **** 
2228:ff.c          **** FRESULT f_readdir (
2229:ff.c          **** 	DIR *dj,			/* Pointer to the open directory object */
2230:ff.c          **** 	FILINFO *fno		/* Pointer to file information to return */
2231:ff.c          **** )
2232:ff.c          **** {
 5711              		.loc 1 2232 1 is_stmt 1 view -0
 5712              		.cfi_startproc
 5713              		@ args = 0, pretend = 0, frame = 16
 5714              		@ frame_needed = 0, uses_anonymous_args = 0
2233:ff.c          **** 	FRESULT res;
 5715              		.loc 1 2233 2 view .LVU2063
2234:ff.c          **** 	NAMEBUF(sfn, lfn);
 5716              		.loc 1 2234 2 view .LVU2064
2235:ff.c          **** 
2236:ff.c          **** 
2237:ff.c          **** 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
 5717              		.loc 1 2237 2 view .LVU2065
2232:ff.c          **** 	FRESULT res;
 5718              		.loc 1 2232 1 is_stmt 0 view .LVU2066
 5719 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 5720              		.cfi_def_cfa_offset 32
 5721              		.cfi_offset 4, -16
 5722              		.cfi_offset 5, -12
 5723              		.cfi_offset 6, -8
 5724              		.cfi_offset 14, -4
2232:ff.c          **** 	FRESULT res;
 5725              		.loc 1 2232 1 view .LVU2067
 5726 0002 0546     		mov	r5, r0
 5727 0004 0E46     		mov	r6, r1
 5728              		.loc 1 2237 8 view .LVU2068
 5729 0006 8188     		ldrh	r1, [r0, #4]
 5730              	.LVL603:
 5731              		.loc 1 2237 8 view .LVU2069
 5732 0008 0068     		ldr	r0, [r0]
 5733              	.LVL604:
 5734              		.loc 1 2237 8 view .LVU2070
 5735 000a FFF7FEFF 		bl	validate
 5736              	.LVL605:
2238:ff.c          **** 	if (res == FR_OK) {
 5737              		.loc 1 2238 2 is_stmt 1 view .LVU2071
 5738              		.loc 1 2238 5 is_stmt 0 view .LVU2072
 5739 000e 0446     		mov	r4, r0
 5740 0010 D0B9     		cbnz	r0, .L508
2239:ff.c          **** 		INITBUF((*dj), sfn, lfn);
 5741              		.loc 1 2239 3 is_stmt 1 view .LVU2073
 5742 0012 01AB     		add	r3, sp, #4
 5743 0014 AB61     		str	r3, [r5, #24]
2240:ff.c          **** 		if (!fno) {
 5744              		.loc 1 2240 3 view .LVU2074
 5745              		.loc 1 2240 6 is_stmt 0 view .LVU2075
 5746 0016 2EB9     		cbnz	r6, .L509
2241:ff.c          **** 			res = dir_seek(dj, 0);
 5747              		.loc 1 2241 4 is_stmt 1 view .LVU2076
 5748              		.loc 1 2241 10 is_stmt 0 view .LVU2077
 5749 0018 0146     		mov	r1, r0
 5750 001a 2846     		mov	r0, r5
 5751              	.LVL606:
 5752              		.loc 1 2241 10 view .LVU2078
 5753 001c FFF7FEFF 		bl	dir_seek
 5754              	.LVL607:
 5755              	.L513:
 5756              		.loc 1 2241 10 view .LVU2079
 5757 0020 0446     		mov	r4, r0
 5758 0022 11E0     		b	.L508
 5759              	.LVL608:
 5760              	.L509:
2242:ff.c          **** 		} else {
2243:ff.c          **** 			res = dir_read(dj);
 5761              		.loc 1 2243 4 is_stmt 1 view .LVU2080
 5762              		.loc 1 2243 10 is_stmt 0 view .LVU2081
 5763 0024 2846     		mov	r0, r5
 5764              	.LVL609:
 5765              		.loc 1 2243 10 view .LVU2082
 5766 0026 FFF7FEFF 		bl	dir_read
 5767              	.LVL610:
2244:ff.c          **** 			if (res == FR_NO_FILE) {
 5768              		.loc 1 2244 4 is_stmt 1 view .LVU2083
 5769              		.loc 1 2244 7 is_stmt 0 view .LVU2084
 5770 002a 0428     		cmp	r0, #4
 5771 002c 0FD1     		bne	.L510
2245:ff.c          **** 				dj->sect = 0;
 5772              		.loc 1 2245 5 is_stmt 1 view .LVU2085
 5773              		.loc 1 2245 14 is_stmt 0 view .LVU2086
 5774 002e 2C61     		str	r4, [r5, #16]
2246:ff.c          **** 				res = FR_OK;
 5775              		.loc 1 2246 5 is_stmt 1 view .LVU2087
 5776              	.LVL611:
2247:ff.c          **** 			}
2248:ff.c          **** 			if (res == FR_OK) {				/* A valid entry is found */
 5777              		.loc 1 2248 4 view .LVU2088
 5778              	.L511:
2249:ff.c          **** 				get_fileinfo(dj, fno);		/* Get the object information */
 5779              		.loc 1 2249 5 view .LVU2089
 5780 0030 3146     		mov	r1, r6
 5781 0032 2846     		mov	r0, r5
 5782 0034 FFF7FEFF 		bl	get_fileinfo
 5783              	.LVL612:
2250:ff.c          **** 				res = dir_next(dj, FALSE);	/* Increment index for next */
 5784              		.loc 1 2250 5 view .LVU2090
 5785              		.loc 1 2250 11 is_stmt 0 view .LVU2091
 5786 0038 0021     		movs	r1, #0
 5787 003a 2846     		mov	r0, r5
 5788 003c FFF7FEFF 		bl	dir_next
 5789              	.LVL613:
2251:ff.c          **** 				if (res == FR_NO_FILE) {
 5790              		.loc 1 2251 5 is_stmt 1 view .LVU2092
 5791              		.loc 1 2251 8 is_stmt 0 view .LVU2093
 5792 0040 0428     		cmp	r0, #4
 5793 0042 EDD1     		bne	.L513
2252:ff.c          **** 					dj->sect = 0;
 5794              		.loc 1 2252 6 is_stmt 1 view .LVU2094
 5795              		.loc 1 2252 15 is_stmt 0 view .LVU2095
 5796 0044 0023     		movs	r3, #0
 5797 0046 2B61     		str	r3, [r5, #16]
2253:ff.c          **** 					res = FR_OK;
 5798              		.loc 1 2253 6 is_stmt 1 view .LVU2096
 5799              	.LVL614:
 5800              	.L508:
2254:ff.c          **** 				}
2255:ff.c          **** 			}
2256:ff.c          **** 		}
2257:ff.c          **** 	}
2258:ff.c          **** 
2259:ff.c          **** 	LEAVE_FF(dj->fs, res);
 5801              		.loc 1 2259 2 view .LVU2097
2260:ff.c          **** }
 5802              		.loc 1 2260 1 is_stmt 0 view .LVU2098
 5803 0048 2046     		mov	r0, r4
 5804 004a 04B0     		add	sp, sp, #16
 5805              		.cfi_remember_state
 5806              		.cfi_def_cfa_offset 16
 5807              		@ sp needed
 5808 004c 70BD     		pop	{r4, r5, r6, pc}
 5809              	.LVL615:
 5810              	.L510:
 5811              		.cfi_restore_state
2248:ff.c          **** 				get_fileinfo(dj, fno);		/* Get the object information */
 5812              		.loc 1 2248 4 is_stmt 1 view .LVU2099
2248:ff.c          **** 				get_fileinfo(dj, fno);		/* Get the object information */
 5813              		.loc 1 2248 7 is_stmt 0 view .LVU2100
 5814 004e 0028     		cmp	r0, #0
 5815 0050 E6D1     		bne	.L513
 5816 0052 EDE7     		b	.L511
 5817              		.cfi_endproc
 5818              	.LFE62:
 5820              		.section	.text.f_stat,"ax",%progbits
 5821              		.align	1
 5822              		.global	f_stat
 5823              		.syntax unified
 5824              		.thumb
 5825              		.thumb_func
 5826              		.fpu softvfp
 5828              	f_stat:
 5829              	.LVL616:
 5830              	.LFB63:
2261:ff.c          **** 
2262:ff.c          **** 
2263:ff.c          **** 
2264:ff.c          **** #if _FS_MINIMIZE == 0
2265:ff.c          **** /*-----------------------------------------------------------------------*/
2266:ff.c          **** /* Get File Status                                                       */
2267:ff.c          **** /*-----------------------------------------------------------------------*/
2268:ff.c          **** 
2269:ff.c          **** FRESULT f_stat (
2270:ff.c          **** 	const XCHAR *path,	/* Pointer to the file path */
2271:ff.c          **** 	FILINFO *fno		/* Pointer to file information to return */
2272:ff.c          **** )
2273:ff.c          **** {
 5831              		.loc 1 2273 1 is_stmt 1 view -0
 5832              		.cfi_startproc
 5833              		@ args = 0, pretend = 0, frame = 48
 5834              		@ frame_needed = 0, uses_anonymous_args = 0
2274:ff.c          **** 	FRESULT res;
 5835              		.loc 1 2274 2 view .LVU2102
2275:ff.c          **** 	DIR dj;
 5836              		.loc 1 2275 2 view .LVU2103
2276:ff.c          **** 	NAMEBUF(sfn, lfn);
 5837              		.loc 1 2276 2 view .LVU2104
2277:ff.c          **** 
2278:ff.c          **** 
2279:ff.c          **** 	res = auto_mount(&path, &dj.fs, 0);
 5838              		.loc 1 2279 2 view .LVU2105
2273:ff.c          **** 	FRESULT res;
 5839              		.loc 1 2273 1 is_stmt 0 view .LVU2106
 5840 0000 30B5     		push	{r4, r5, lr}
 5841              		.cfi_def_cfa_offset 12
 5842              		.cfi_offset 4, -12
 5843              		.cfi_offset 5, -8
 5844              		.cfi_offset 14, -4
 5845 0002 8DB0     		sub	sp, sp, #52
 5846              		.cfi_def_cfa_offset 64
2273:ff.c          **** 	FRESULT res;
 5847              		.loc 1 2273 1 view .LVU2107
 5848 0004 0190     		str	r0, [sp, #4]
 5849 0006 0D46     		mov	r5, r1
 5850              		.loc 1 2279 8 view .LVU2108
 5851 0008 0022     		movs	r2, #0
 5852 000a 05A9     		add	r1, sp, #20
 5853              	.LVL617:
 5854              		.loc 1 2279 8 view .LVU2109
 5855 000c 01A8     		add	r0, sp, #4
 5856              	.LVL618:
 5857              		.loc 1 2279 8 view .LVU2110
 5858 000e FFF7FEFF 		bl	auto_mount
 5859              	.LVL619:
2280:ff.c          **** 	if (res == FR_OK) {
 5860              		.loc 1 2280 2 is_stmt 1 view .LVU2111
 5861              		.loc 1 2280 5 is_stmt 0 view .LVU2112
 5862 0012 0446     		mov	r4, r0
 5863 0014 68B9     		cbnz	r0, .L515
2281:ff.c          **** 		INITBUF(dj, sfn, lfn);
 5864              		.loc 1 2281 3 is_stmt 1 view .LVU2113
 5865 0016 02AB     		add	r3, sp, #8
2282:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
 5866              		.loc 1 2282 9 is_stmt 0 view .LVU2114
 5867 0018 0199     		ldr	r1, [sp, #4]
 5868 001a 05A8     		add	r0, sp, #20
 5869              	.LVL620:
2281:ff.c          **** 		INITBUF(dj, sfn, lfn);
 5870              		.loc 1 2281 3 view .LVU2115
 5871 001c 0B93     		str	r3, [sp, #44]
 5872              		.loc 1 2282 3 is_stmt 1 view .LVU2116
 5873              		.loc 1 2282 9 is_stmt 0 view .LVU2117
 5874 001e FFF7FEFF 		bl	follow_path
 5875              	.LVL621:
2283:ff.c          **** 		if (res == FR_OK) {				/* Follwo completed */
 5876              		.loc 1 2283 3 is_stmt 1 view .LVU2118
 5877              		.loc 1 2283 6 is_stmt 0 view .LVU2119
 5878 0022 0446     		mov	r4, r0
 5879 0024 28B9     		cbnz	r0, .L515
2284:ff.c          **** 			if (dj.dir)	/* Found an object */
 5880              		.loc 1 2284 4 is_stmt 1 view .LVU2120
 5881              		.loc 1 2284 7 is_stmt 0 view .LVU2121
 5882 0026 0A9B     		ldr	r3, [sp, #40]
 5883 0028 33B1     		cbz	r3, .L516
2285:ff.c          **** 				get_fileinfo(&dj, fno);
 5884              		.loc 1 2285 5 is_stmt 1 view .LVU2122
 5885 002a 2946     		mov	r1, r5
 5886 002c 05A8     		add	r0, sp, #20
 5887              	.LVL622:
 5888              		.loc 1 2285 5 is_stmt 0 view .LVU2123
 5889 002e FFF7FEFF 		bl	get_fileinfo
 5890              	.LVL623:
 5891              	.L515:
2286:ff.c          **** 			else		/* It is root dir */
2287:ff.c          **** 				res = FR_INVALID_NAME;
2288:ff.c          **** 		}
2289:ff.c          **** 	}
2290:ff.c          **** 
2291:ff.c          **** 	LEAVE_FF(dj.fs, res);
 5892              		.loc 1 2291 2 is_stmt 1 view .LVU2124
2292:ff.c          **** }
 5893              		.loc 1 2292 1 is_stmt 0 view .LVU2125
 5894 0032 2046     		mov	r0, r4
 5895 0034 0DB0     		add	sp, sp, #52
 5896              		.cfi_remember_state
 5897              		.cfi_def_cfa_offset 12
 5898              		@ sp needed
 5899 0036 30BD     		pop	{r4, r5, pc}
 5900              	.LVL624:
 5901              	.L516:
 5902              		.cfi_restore_state
2287:ff.c          **** 		}
 5903              		.loc 1 2287 9 view .LVU2126
 5904 0038 0624     		movs	r4, #6
 5905 003a FAE7     		b	.L515
 5906              		.cfi_endproc
 5907              	.LFE63:
 5909              		.section	.text.f_getfree,"ax",%progbits
 5910              		.align	1
 5911              		.global	f_getfree
 5912              		.syntax unified
 5913              		.thumb
 5914              		.thumb_func
 5915              		.fpu softvfp
 5917              	f_getfree:
 5918              	.LVL625:
 5919              	.LFB64:
2293:ff.c          **** 
2294:ff.c          **** 
2295:ff.c          **** 
2296:ff.c          **** #if !_FS_READONLY
2297:ff.c          **** /*-----------------------------------------------------------------------*/
2298:ff.c          **** /* Get Number of Free Clusters                                           */
2299:ff.c          **** /*-----------------------------------------------------------------------*/
2300:ff.c          **** 
2301:ff.c          **** FRESULT f_getfree (
2302:ff.c          **** 	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
2303:ff.c          **** 	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
2304:ff.c          **** 	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
2305:ff.c          **** )
2306:ff.c          **** {
 5920              		.loc 1 2306 1 is_stmt 1 view -0
 5921              		.cfi_startproc
 5922              		@ args = 0, pretend = 0, frame = 8
 5923              		@ frame_needed = 0, uses_anonymous_args = 0
2307:ff.c          **** 	FRESULT res;
 5924              		.loc 1 2307 2 view .LVU2128
2308:ff.c          **** 	DWORD n, clst, sect, stat;
 5925              		.loc 1 2308 2 view .LVU2129
2309:ff.c          **** 	UINT i;
 5926              		.loc 1 2309 2 view .LVU2130
2310:ff.c          **** 	BYTE fat, *p;
 5927              		.loc 1 2310 2 view .LVU2131
2311:ff.c          **** 
2312:ff.c          **** 
2313:ff.c          **** 	/* Get drive number */
2314:ff.c          **** 	res = auto_mount(&path, fatfs, 0);
 5928              		.loc 1 2314 2 view .LVU2132
2306:ff.c          **** 	FRESULT res;
 5929              		.loc 1 2306 1 is_stmt 0 view .LVU2133
 5930 0000 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, r10, lr}
 5931              		.cfi_def_cfa_offset 40
 5932              		.cfi_offset 4, -32
 5933              		.cfi_offset 5, -28
 5934              		.cfi_offset 6, -24
 5935              		.cfi_offset 7, -20
 5936              		.cfi_offset 8, -16
 5937              		.cfi_offset 9, -12
 5938              		.cfi_offset 10, -8
 5939              		.cfi_offset 14, -4
2306:ff.c          **** 	FRESULT res;
 5940              		.loc 1 2306 1 view .LVU2134
 5941 0004 1646     		mov	r6, r2
 5942 0006 0190     		str	r0, [sp, #4]
 5943 0008 0F46     		mov	r7, r1
 5944              		.loc 1 2314 8 view .LVU2135
 5945 000a 0022     		movs	r2, #0
 5946              	.LVL626:
 5947              		.loc 1 2314 8 view .LVU2136
 5948 000c 3146     		mov	r1, r6
 5949              	.LVL627:
 5950              		.loc 1 2314 8 view .LVU2137
 5951 000e 01A8     		add	r0, sp, #4
 5952              	.LVL628:
 5953              		.loc 1 2314 8 view .LVU2138
 5954 0010 FFF7FEFF 		bl	auto_mount
 5955              	.LVL629:
2315:ff.c          **** 	if (res != FR_OK) LEAVE_FF(*fatfs, res);
 5956              		.loc 1 2315 2 is_stmt 1 view .LVU2139
 5957              		.loc 1 2315 5 is_stmt 0 view .LVU2140
 5958 0014 0446     		mov	r4, r0
 5959 0016 40B9     		cbnz	r0, .L518
2316:ff.c          **** 
2317:ff.c          **** 	/* If number of free cluster is valid, return it without cluster scan. */
2318:ff.c          **** 	if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
 5960              		.loc 1 2318 2 is_stmt 1 view .LVU2141
 5961              		.loc 1 2318 7 is_stmt 0 view .LVU2142
 5962 0018 3368     		ldr	r3, [r6]
 5963              		.loc 1 2318 38 view .LVU2143
 5964 001a D3F82090 		ldr	r9, [r3, #32]
 5965              		.loc 1 2318 14 view .LVU2144
 5966 001e 1A69     		ldr	r2, [r3, #16]
 5967              		.loc 1 2318 50 view .LVU2145
 5968 0020 A9F10201 		sub	r1, r9, #2
 5969              		.loc 1 2318 5 view .LVU2146
 5970 0024 8A42     		cmp	r2, r1
 5971 0026 04D8     		bhi	.L519
2319:ff.c          **** 		*nclst = (*fatfs)->free_clust;
 5972              		.loc 1 2319 3 is_stmt 1 view .LVU2147
 5973              		.loc 1 2319 10 is_stmt 0 view .LVU2148
 5974 0028 3A60     		str	r2, [r7]
2320:ff.c          **** 		LEAVE_FF(*fatfs, FR_OK);
 5975              		.loc 1 2320 3 is_stmt 1 view .LVU2149
 5976              	.LVL630:
 5977              	.L518:
2321:ff.c          **** 	}
2322:ff.c          **** 
2323:ff.c          **** 	/* Get number of free clusters */
2324:ff.c          **** 	fat = (*fatfs)->fs_type;
2325:ff.c          **** 	n = 0;
2326:ff.c          **** 	if (fat == FS_FAT12) {
2327:ff.c          **** 		clst = 2;
2328:ff.c          **** 		do {
2329:ff.c          **** 			stat = get_fat(*fatfs, clst);
2330:ff.c          **** 			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
2331:ff.c          **** 			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
2332:ff.c          **** 			if (stat == 0) n++;
2333:ff.c          **** 		} while (++clst < (*fatfs)->max_clust);
2334:ff.c          **** 	} else {
2335:ff.c          **** 		clst = (*fatfs)->max_clust;
2336:ff.c          **** 		sect = (*fatfs)->fatbase;
2337:ff.c          **** 		i = 0; p = 0;
2338:ff.c          **** 		do {
2339:ff.c          **** 			if (!i) {
2340:ff.c          **** 				res = move_window(*fatfs, sect++);
2341:ff.c          **** 				if (res != FR_OK)
2342:ff.c          **** 					LEAVE_FF(*fatfs, res);
2343:ff.c          **** 				p = (*fatfs)->win;
2344:ff.c          **** 				i = SS(*fatfs);
2345:ff.c          **** 			}
2346:ff.c          **** 			if (fat == FS_FAT16) {
2347:ff.c          **** 				if (LD_WORD(p) == 0) n++;
2348:ff.c          **** 				p += 2; i -= 2;
2349:ff.c          **** 			} else {
2350:ff.c          **** 				if (LD_DWORD(p) == 0) n++;
2351:ff.c          **** 				p += 4; i -= 4;
2352:ff.c          **** 			}
2353:ff.c          **** 		} while (--clst);
2354:ff.c          **** 	}
2355:ff.c          **** 	(*fatfs)->free_clust = n;
2356:ff.c          **** 	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
2357:ff.c          **** 	*nclst = n;
2358:ff.c          **** 
2359:ff.c          **** 	LEAVE_FF(*fatfs, FR_OK);
2360:ff.c          **** }
 5978              		.loc 1 2360 1 is_stmt 0 view .LVU2150
 5979 002a 2046     		mov	r0, r4
 5980 002c 02B0     		add	sp, sp, #8
 5981              		.cfi_remember_state
 5982              		.cfi_def_cfa_offset 32
 5983              		@ sp needed
 5984 002e BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 5985              	.LVL631:
 5986              	.L519:
 5987              		.cfi_restore_state
2324:ff.c          **** 	n = 0;
 5988              		.loc 1 2324 2 is_stmt 1 view .LVU2151
2324:ff.c          **** 	n = 0;
 5989              		.loc 1 2324 6 is_stmt 0 view .LVU2152
 5990 0032 93F80080 		ldrb	r8, [r3]	@ zero_extendqisi2
 5991              	.LVL632:
2325:ff.c          **** 	if (fat == FS_FAT12) {
 5992              		.loc 1 2325 2 is_stmt 1 view .LVU2153
2326:ff.c          **** 		clst = 2;
 5993              		.loc 1 2326 2 view .LVU2154
2326:ff.c          **** 		clst = 2;
 5994              		.loc 1 2326 5 is_stmt 0 view .LVU2155
 5995 0036 B8F1010F 		cmp	r8, #1
 5996 003a 1CD1     		bne	.L520
2327:ff.c          **** 		do {
 5997              		.loc 1 2327 8 view .LVU2156
 5998 003c 4FF00209 		mov	r9, #2
2325:ff.c          **** 	if (fat == FS_FAT12) {
 5999              		.loc 1 2325 4 view .LVU2157
 6000 0040 0546     		mov	r5, r0
 6001              	.LVL633:
 6002              	.L522:
2328:ff.c          **** 			stat = get_fat(*fatfs, clst);
 6003              		.loc 1 2328 3 is_stmt 1 view .LVU2158
2329:ff.c          **** 			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
 6004              		.loc 1 2329 4 view .LVU2159
2329:ff.c          **** 			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
 6005              		.loc 1 2329 11 is_stmt 0 view .LVU2160
 6006 0042 4946     		mov	r1, r9
 6007 0044 3068     		ldr	r0, [r6]
 6008 0046 FFF7FEFF 		bl	get_fat
 6009              	.LVL634:
2330:ff.c          **** 			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
 6010              		.loc 1 2330 4 is_stmt 1 view .LVU2161
2330:ff.c          **** 			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
 6011              		.loc 1 2330 7 is_stmt 0 view .LVU2162
 6012 004a 431C     		adds	r3, r0, #1
 6013 004c 39D0     		beq	.L531
2331:ff.c          **** 			if (stat == 0) n++;
 6014              		.loc 1 2331 4 is_stmt 1 view .LVU2163
2331:ff.c          **** 			if (stat == 0) n++;
 6015              		.loc 1 2331 7 is_stmt 0 view .LVU2164
 6016 004e 0128     		cmp	r0, #1
 6017 0050 39D0     		beq	.L532
2332:ff.c          **** 		} while (++clst < (*fatfs)->max_clust);
 6018              		.loc 1 2332 4 is_stmt 1 view .LVU2165
2332:ff.c          **** 		} while (++clst < (*fatfs)->max_clust);
 6019              		.loc 1 2332 7 is_stmt 0 view .LVU2166
 6020 0052 00B9     		cbnz	r0, .L521
2332:ff.c          **** 		} while (++clst < (*fatfs)->max_clust);
 6021              		.loc 1 2332 19 is_stmt 1 discriminator 1 view .LVU2167
2332:ff.c          **** 		} while (++clst < (*fatfs)->max_clust);
 6022              		.loc 1 2332 20 is_stmt 0 discriminator 1 view .LVU2168
 6023 0054 0135     		adds	r5, r5, #1
 6024              	.LVL635:
 6025              	.L521:
2333:ff.c          **** 	} else {
 6026              		.loc 1 2333 11 is_stmt 1 view .LVU2169
2333:ff.c          **** 	} else {
 6027              		.loc 1 2333 29 is_stmt 0 view .LVU2170
 6028 0056 3368     		ldr	r3, [r6]
2333:ff.c          **** 	} else {
 6029              		.loc 1 2333 3 view .LVU2171
 6030 0058 09F10109 		add	r9, r9, #1
 6031              	.LVL636:
2333:ff.c          **** 	} else {
 6032              		.loc 1 2333 3 view .LVU2172
 6033 005c 1B6A     		ldr	r3, [r3, #32]
 6034 005e 4B45     		cmp	r3, r9
 6035 0060 EFD8     		bhi	.L522
 6036              	.LVL637:
 6037              	.L523:
2355:ff.c          **** 	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
 6038              		.loc 1 2355 2 is_stmt 1 view .LVU2173
2356:ff.c          **** 	*nclst = n;
 6039              		.loc 1 2356 5 is_stmt 0 view .LVU2174
 6040 0062 B8F1030F 		cmp	r8, #3
2356:ff.c          **** 	*nclst = n;
 6041              		.loc 1 2356 42 view .LVU2175
 6042 0066 08BF     		it	eq
 6043 0068 0122     		moveq	r2, #1
2355:ff.c          **** 	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
 6044              		.loc 1 2355 3 view .LVU2176
 6045 006a 3368     		ldr	r3, [r6]
2355:ff.c          **** 	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
 6046              		.loc 1 2355 23 view .LVU2177
 6047 006c 1D61     		str	r5, [r3, #16]
2356:ff.c          **** 	*nclst = n;
 6048              		.loc 1 2356 2 is_stmt 1 view .LVU2178
2356:ff.c          **** 	*nclst = n;
 6049              		.loc 1 2356 23 view .LVU2179
2356:ff.c          **** 	*nclst = n;
 6050              		.loc 1 2356 42 is_stmt 0 view .LVU2180
 6051 006e 08BF     		it	eq
 6052 0070 9A72     		strbeq	r2, [r3, #10]
2357:ff.c          **** 
 6053              		.loc 1 2357 2 is_stmt 1 view .LVU2181
2357:ff.c          **** 
 6054              		.loc 1 2357 9 is_stmt 0 view .LVU2182
 6055 0072 3D60     		str	r5, [r7]
2359:ff.c          **** }
 6056              		.loc 1 2359 2 is_stmt 1 view .LVU2183
 6057 0074 D9E7     		b	.L518
 6058              	.LVL638:
 6059              	.L520:
2335:ff.c          **** 		sect = (*fatfs)->fatbase;
 6060              		.loc 1 2335 3 view .LVU2184
2336:ff.c          **** 		i = 0; p = 0;
 6061              		.loc 1 2336 3 view .LVU2185
2336:ff.c          **** 		i = 0; p = 0;
 6062              		.loc 1 2336 8 is_stmt 0 view .LVU2186
 6063 0076 596A     		ldr	r1, [r3, #36]
 6064              	.LVL639:
2337:ff.c          **** 		do {
 6065              		.loc 1 2337 3 is_stmt 1 view .LVU2187
2337:ff.c          **** 		do {
 6066              		.loc 1 2337 10 view .LVU2188
2337:ff.c          **** 		do {
 6067              		.loc 1 2337 5 is_stmt 0 view .LVU2189
 6068 0078 0246     		mov	r2, r0
2337:ff.c          **** 		do {
 6069              		.loc 1 2337 12 view .LVU2190
 6070 007a 0346     		mov	r3, r0
2325:ff.c          **** 	if (fat == FS_FAT12) {
 6071              		.loc 1 2325 4 view .LVU2191
 6072 007c 0546     		mov	r5, r0
 6073              	.LVL640:
 6074              	.L529:
2338:ff.c          **** 			if (!i) {
 6075              		.loc 1 2338 3 is_stmt 1 view .LVU2192
2339:ff.c          **** 				res = move_window(*fatfs, sect++);
 6076              		.loc 1 2339 4 view .LVU2193
2339:ff.c          **** 				res = move_window(*fatfs, sect++);
 6077              		.loc 1 2339 7 is_stmt 0 view .LVU2194
 6078 007e 52B9     		cbnz	r2, .L524
 6079              	.LVL641:
2340:ff.c          **** 				if (res != FR_OK)
 6080              		.loc 1 2340 5 is_stmt 1 view .LVU2195
2340:ff.c          **** 				if (res != FR_OK)
 6081              		.loc 1 2340 11 is_stmt 0 view .LVU2196
 6082 0080 3068     		ldr	r0, [r6]
 6083 0082 01F1010A 		add	r10, r1, #1
 6084              	.LVL642:
2340:ff.c          **** 				if (res != FR_OK)
 6085              		.loc 1 2340 11 view .LVU2197
 6086 0086 FFF7FEFF 		bl	move_window
 6087              	.LVL643:
2341:ff.c          **** 					LEAVE_FF(*fatfs, res);
 6088              		.loc 1 2341 5 is_stmt 1 view .LVU2198
2341:ff.c          **** 					LEAVE_FF(*fatfs, res);
 6089              		.loc 1 2341 8 is_stmt 0 view .LVU2199
 6090 008a F0B9     		cbnz	r0, .L533
2343:ff.c          **** 				i = SS(*fatfs);
 6091              		.loc 1 2343 5 is_stmt 1 view .LVU2200
2340:ff.c          **** 				if (res != FR_OK)
 6092              		.loc 1 2340 11 is_stmt 0 view .LVU2201
 6093 008c 5146     		mov	r1, r10
2344:ff.c          **** 			}
 6094              		.loc 1 2344 7 view .LVU2202
 6095 008e 4FF40072 		mov	r2, #512
2343:ff.c          **** 				i = SS(*fatfs);
 6096              		.loc 1 2343 7 view .LVU2203
 6097 0092 3368     		ldr	r3, [r6]
 6098              	.LVL644:
2343:ff.c          **** 				i = SS(*fatfs);
 6099              		.loc 1 2343 7 view .LVU2204
 6100 0094 3433     		adds	r3, r3, #52
 6101              	.LVL645:
2344:ff.c          **** 			}
 6102              		.loc 1 2344 5 is_stmt 1 view .LVU2205
 6103              	.L524:
2346:ff.c          **** 				if (LD_WORD(p) == 0) n++;
 6104              		.loc 1 2346 4 view .LVU2206
2346:ff.c          **** 				if (LD_WORD(p) == 0) n++;
 6105              		.loc 1 2346 7 is_stmt 0 view .LVU2207
 6106 0096 B8F1020F 		cmp	r8, #2
 6107 009a 93F801C0 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
 6108 009e 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 6109 00a0 09D1     		bne	.L525
2347:ff.c          **** 				p += 2; i -= 2;
 6110              		.loc 1 2347 5 is_stmt 1 view .LVU2208
2347:ff.c          **** 				p += 2; i -= 2;
 6111              		.loc 1 2347 8 is_stmt 0 view .LVU2209
 6112 00a2 50EA0C20 		orrs	r0, r0, ip, lsl #8
2347:ff.c          **** 				p += 2; i -= 2;
 6113              		.loc 1 2347 26 is_stmt 1 view .LVU2210
2347:ff.c          **** 				p += 2; i -= 2;
 6114              		.loc 1 2347 27 is_stmt 0 view .LVU2211
 6115 00a6 08BF     		it	eq
 6116 00a8 0135     		addeq	r5, r5, #1
 6117              	.LVL646:
2348:ff.c          **** 			} else {
 6118              		.loc 1 2348 5 is_stmt 1 view .LVU2212
2348:ff.c          **** 			} else {
 6119              		.loc 1 2348 7 is_stmt 0 view .LVU2213
 6120 00aa 0233     		adds	r3, r3, #2
 6121              	.LVL647:
2348:ff.c          **** 			} else {
 6122              		.loc 1 2348 13 is_stmt 1 view .LVU2214
2348:ff.c          **** 			} else {
 6123              		.loc 1 2348 15 is_stmt 0 view .LVU2215
 6124 00ac 023A     		subs	r2, r2, #2
 6125              	.LVL648:
 6126              	.L527:
2353:ff.c          **** 	}
 6127              		.loc 1 2353 11 is_stmt 1 view .LVU2216
2353:ff.c          **** 	}
 6128              		.loc 1 2353 3 is_stmt 0 view .LVU2217
 6129 00ae B9F10109 		subs	r9, r9, #1
 6130              	.LVL649:
2353:ff.c          **** 	}
 6131              		.loc 1 2353 3 view .LVU2218
 6132 00b2 E4D1     		bne	.L529
2353:ff.c          **** 	}
 6133              		.loc 1 2353 3 view .LVU2219
 6134 00b4 D5E7     		b	.L523
 6135              	.LVL650:
 6136              	.L525:
2350:ff.c          **** 				p += 4; i -= 4;
 6137              		.loc 1 2350 5 is_stmt 1 view .LVU2220
2350:ff.c          **** 				p += 4; i -= 4;
 6138              		.loc 1 2350 9 is_stmt 0 view .LVU2221
 6139 00b6 1868     		ldr	r0, [r3]	@ unaligned
2350:ff.c          **** 				p += 4; i -= 4;
 6140              		.loc 1 2350 8 view .LVU2222
 6141 00b8 00B9     		cbnz	r0, .L528
2350:ff.c          **** 				p += 4; i -= 4;
 6142              		.loc 1 2350 27 is_stmt 1 discriminator 1 view .LVU2223
2350:ff.c          **** 				p += 4; i -= 4;
 6143              		.loc 1 2350 28 is_stmt 0 discriminator 1 view .LVU2224
 6144 00ba 0135     		adds	r5, r5, #1
 6145              	.LVL651:
 6146              	.L528:
2351:ff.c          **** 			}
 6147              		.loc 1 2351 5 is_stmt 1 view .LVU2225
2351:ff.c          **** 			}
 6148              		.loc 1 2351 7 is_stmt 0 view .LVU2226
 6149 00bc 0433     		adds	r3, r3, #4
 6150              	.LVL652:
2351:ff.c          **** 			}
 6151              		.loc 1 2351 13 is_stmt 1 view .LVU2227
2351:ff.c          **** 			}
 6152              		.loc 1 2351 15 is_stmt 0 view .LVU2228
 6153 00be 043A     		subs	r2, r2, #4
 6154              	.LVL653:
2351:ff.c          **** 			}
 6155              		.loc 1 2351 15 view .LVU2229
 6156 00c0 F5E7     		b	.L527
 6157              	.LVL654:
 6158              	.L531:
2330:ff.c          **** 			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
 6159              		.loc 1 2330 28 view .LVU2230
 6160 00c2 0124     		movs	r4, #1
 6161 00c4 B1E7     		b	.L518
 6162              	.L532:
2331:ff.c          **** 			if (stat == 0) n++;
 6163              		.loc 1 2331 19 view .LVU2231
 6164 00c6 0224     		movs	r4, #2
 6165 00c8 AFE7     		b	.L518
 6166              	.LVL655:
 6167              	.L533:
2340:ff.c          **** 				if (res != FR_OK)
 6168              		.loc 1 2340 11 view .LVU2232
 6169 00ca 0446     		mov	r4, r0
 6170 00cc ADE7     		b	.L518
 6171              		.cfi_endproc
 6172              	.LFE64:
 6174              		.section	.text.f_truncate,"ax",%progbits
 6175              		.align	1
 6176              		.global	f_truncate
 6177              		.syntax unified
 6178              		.thumb
 6179              		.thumb_func
 6180              		.fpu softvfp
 6182              	f_truncate:
 6183              	.LVL656:
 6184              	.LFB65:
2361:ff.c          **** 
2362:ff.c          **** 
2363:ff.c          **** 
2364:ff.c          **** 
2365:ff.c          **** /*-----------------------------------------------------------------------*/
2366:ff.c          **** /* Truncate File                                                         */
2367:ff.c          **** /*-----------------------------------------------------------------------*/
2368:ff.c          **** 
2369:ff.c          **** FRESULT f_truncate (
2370:ff.c          **** 	FIL *fp		/* Pointer to the file object */
2371:ff.c          **** )
2372:ff.c          **** {
 6185              		.loc 1 2372 1 is_stmt 1 view -0
 6186              		.cfi_startproc
 6187              		@ args = 0, pretend = 0, frame = 0
 6188              		@ frame_needed = 0, uses_anonymous_args = 0
2373:ff.c          **** 	FRESULT res;
 6189              		.loc 1 2373 2 view .LVU2234
2374:ff.c          **** 	DWORD ncl;
 6190              		.loc 1 2374 2 view .LVU2235
2375:ff.c          **** 
2376:ff.c          **** 
2377:ff.c          **** 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 6191              		.loc 1 2377 2 view .LVU2236
2372:ff.c          **** 	FRESULT res;
 6192              		.loc 1 2372 1 is_stmt 0 view .LVU2237
 6193 0000 70B5     		push	{r4, r5, r6, lr}
 6194              		.cfi_def_cfa_offset 16
 6195              		.cfi_offset 4, -16
 6196              		.cfi_offset 5, -12
 6197              		.cfi_offset 6, -8
 6198              		.cfi_offset 14, -4
 6199              		.loc 1 2377 8 view .LVU2238
 6200 0002 8188     		ldrh	r1, [r0, #4]
2372:ff.c          **** 	FRESULT res;
 6201              		.loc 1 2372 1 view .LVU2239
 6202 0004 0446     		mov	r4, r0
 6203              		.loc 1 2377 8 view .LVU2240
 6204 0006 0068     		ldr	r0, [r0]
 6205              	.LVL657:
 6206              		.loc 1 2377 8 view .LVU2241
 6207 0008 FFF7FEFF 		bl	validate
 6208              	.LVL658:
2378:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 6209              		.loc 1 2378 2 is_stmt 1 view .LVU2242
 6210              		.loc 1 2378 5 is_stmt 0 view .LVU2243
 6211 000c 0546     		mov	r5, r0
 6212 000e A8B9     		cbnz	r0, .L549
2379:ff.c          **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
 6213              		.loc 1 2379 2 is_stmt 1 view .LVU2244
 6214              		.loc 1 2379 5 is_stmt 0 view .LVU2245
 6215 0010 94F90620 		ldrsb	r2, [r4, #6]
 6216              		.loc 1 2379 8 view .LVU2246
 6217 0014 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 6218              		.loc 1 2379 5 view .LVU2247
 6219 0016 002A     		cmp	r2, #0
 6220 0018 21DB     		blt	.L545
2380:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2381:ff.c          **** 	if (!(fp->flag & FA_WRITE))			/* Check access mode */
 6221              		.loc 1 2381 2 is_stmt 1 view .LVU2248
 6222              		.loc 1 2381 5 is_stmt 0 view .LVU2249
 6223 001a 9A07     		lsls	r2, r3, #30
 6224 001c 21D5     		bpl	.L546
2382:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
2383:ff.c          **** 
2384:ff.c          **** 	if (fp->fsize > fp->fptr) {
 6225              		.loc 1 2384 2 is_stmt 1 view .LVU2250
 6226              		.loc 1 2384 5 is_stmt 0 view .LVU2251
 6227 001e D4E90221 		ldrd	r2, r1, [r4, #8]
 6228 0022 9142     		cmp	r1, r2
 6229 0024 0AD9     		bls	.L549
2385:ff.c          **** 		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 6230              		.loc 1 2385 3 is_stmt 1 view .LVU2252
2386:ff.c          **** 		fp->flag |= FA__WRITTEN;
 6231              		.loc 1 2386 12 is_stmt 0 view .LVU2253
 6232 0026 43F02003 		orr	r3, r3, #32
 6233 002a 2068     		ldr	r0, [r4]
 6234              	.LVL659:
2385:ff.c          **** 		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 6235              		.loc 1 2385 13 view .LVU2254
 6236 002c E260     		str	r2, [r4, #12]
 6237              		.loc 1 2386 3 is_stmt 1 view .LVU2255
 6238              		.loc 1 2386 12 is_stmt 0 view .LVU2256
 6239 002e A371     		strb	r3, [r4, #6]
2387:ff.c          **** 		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 6240              		.loc 1 2387 3 is_stmt 1 view .LVU2257
 6241              		.loc 1 2387 6 is_stmt 0 view .LVU2258
 6242 0030 32B9     		cbnz	r2, .L539
2388:ff.c          **** 			res = remove_chain(fp->fs, fp->org_clust);
 6243              		.loc 1 2388 4 is_stmt 1 view .LVU2259
 6244              		.loc 1 2388 10 is_stmt 0 view .LVU2260
 6245 0032 2169     		ldr	r1, [r4, #16]
 6246 0034 FFF7FEFF 		bl	remove_chain
 6247              	.LVL660:
2389:ff.c          **** 			fp->org_clust = 0;
 6248              		.loc 1 2389 4 is_stmt 1 view .LVU2261
 6249              		.loc 1 2389 18 is_stmt 0 view .LVU2262
 6250 0038 2561     		str	r5, [r4, #16]
 6251              	.L540:
2390:ff.c          **** 		} else {				/* When truncate a part of the file, remove remaining clusters */
2391:ff.c          **** 			ncl = get_fat(fp->fs, fp->curr_clust);
2392:ff.c          **** 			res = FR_OK;
2393:ff.c          **** 			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
2394:ff.c          **** 			if (ncl == 1) res = FR_INT_ERR;
2395:ff.c          **** 			if (res == FR_OK && ncl < fp->fs->max_clust) {
2396:ff.c          **** 				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
2397:ff.c          **** 				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
2398:ff.c          **** 			}
2399:ff.c          **** 		}
2400:ff.c          **** 	}
2401:ff.c          **** 	if (res != FR_OK) fp->flag |= FA__ERROR;
 6252              		.loc 1 2401 2 is_stmt 1 view .LVU2263
 6253              		.loc 1 2401 5 is_stmt 0 view .LVU2264
 6254 003a 40B9     		cbnz	r0, .L541
 6255              	.LVL661:
 6256              	.L549:
2402:ff.c          **** 
2403:ff.c          **** 	LEAVE_FF(fp->fs, res);
2404:ff.c          **** }
 6257              		.loc 1 2404 1 view .LVU2265
 6258 003c 2846     		mov	r0, r5
 6259 003e 70BD     		pop	{r4, r5, r6, pc}
 6260              	.LVL662:
 6261              	.L539:
2391:ff.c          **** 			res = FR_OK;
 6262              		.loc 1 2391 4 is_stmt 1 view .LVU2266
2391:ff.c          **** 			res = FR_OK;
 6263              		.loc 1 2391 10 is_stmt 0 view .LVU2267
 6264 0040 6169     		ldr	r1, [r4, #20]
 6265 0042 FFF7FEFF 		bl	get_fat
 6266              	.LVL663:
2393:ff.c          **** 			if (ncl == 1) res = FR_INT_ERR;
 6267              		.loc 1 2393 7 view .LVU2268
 6268 0046 431C     		adds	r3, r0, #1
2391:ff.c          **** 			res = FR_OK;
 6269              		.loc 1 2391 10 view .LVU2269
 6270 0048 0646     		mov	r6, r0
 6271              	.LVL664:
2392:ff.c          **** 			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 6272              		.loc 1 2392 4 is_stmt 1 view .LVU2270
2393:ff.c          **** 			if (ncl == 1) res = FR_INT_ERR;
 6273              		.loc 1 2393 4 view .LVU2271
2393:ff.c          **** 			if (ncl == 1) res = FR_INT_ERR;
 6274              		.loc 1 2393 7 is_stmt 0 view .LVU2272
 6275 004a 0CD1     		bne	.L553
 6276 004c 0120     		movs	r0, #1
 6277              	.LVL665:
 6278              	.L541:
2401:ff.c          **** 
 6279              		.loc 1 2401 20 is_stmt 1 discriminator 1 view .LVU2273
2401:ff.c          **** 
 6280              		.loc 1 2401 29 is_stmt 0 discriminator 1 view .LVU2274
 6281 004e A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 6282 0050 0546     		mov	r5, r0
 6283 0052 63F07F03 		orn	r3, r3, #127
 6284 0056 A371     		strb	r3, [r4, #6]
 6285 0058 F0E7     		b	.L549
 6286              	.LVL666:
 6287              	.L548:
2394:ff.c          **** 			if (res == FR_OK && ncl < fp->fs->max_clust) {
 6288              		.loc 1 2394 22 view .LVU2275
 6289 005a 0220     		movs	r0, #2
 6290              	.LVL667:
2394:ff.c          **** 			if (res == FR_OK && ncl < fp->fs->max_clust) {
 6291              		.loc 1 2394 22 view .LVU2276
 6292 005c F7E7     		b	.L541
 6293              	.LVL668:
 6294              	.L545:
2380:ff.c          **** 	if (!(fp->flag & FA_WRITE))			/* Check access mode */
 6295              		.loc 1 2380 3 view .LVU2277
 6296 005e 0225     		movs	r5, #2
 6297 0060 ECE7     		b	.L549
 6298              	.L546:
2382:ff.c          **** 
 6299              		.loc 1 2382 3 view .LVU2278
 6300 0062 0725     		movs	r5, #7
 6301 0064 EAE7     		b	.L549
 6302              	.LVL669:
 6303              	.L553:
2394:ff.c          **** 			if (res == FR_OK && ncl < fp->fs->max_clust) {
 6304              		.loc 1 2394 4 is_stmt 1 view .LVU2279
2394:ff.c          **** 			if (res == FR_OK && ncl < fp->fs->max_clust) {
 6305              		.loc 1 2394 7 is_stmt 0 view .LVU2280
 6306 0066 0128     		cmp	r0, #1
 6307 0068 F7D0     		beq	.L548
 6308              	.LVL670:
2395:ff.c          **** 				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
 6309              		.loc 1 2395 32 discriminator 1 view .LVU2281
 6310 006a 2068     		ldr	r0, [r4]
 6311              	.LVL671:
2395:ff.c          **** 				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
 6312              		.loc 1 2395 21 discriminator 1 view .LVU2282
 6313 006c 036A     		ldr	r3, [r0, #32]
 6314 006e B342     		cmp	r3, r6
 6315 0070 E4D9     		bls	.L549
2396:ff.c          **** 				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 6316              		.loc 1 2396 5 is_stmt 1 view .LVU2283
2396:ff.c          **** 				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 6317              		.loc 1 2396 11 is_stmt 0 view .LVU2284
 6318 0072 6FF07042 		mvn	r2, #-268435456
 6319 0076 6169     		ldr	r1, [r4, #20]
 6320 0078 FFF7FEFF 		bl	put_fat
 6321              	.LVL672:
2397:ff.c          **** 			}
 6322              		.loc 1 2397 5 is_stmt 1 view .LVU2285
2397:ff.c          **** 			}
 6323              		.loc 1 2397 8 is_stmt 0 view .LVU2286
 6324 007c 0028     		cmp	r0, #0
 6325 007e E6D1     		bne	.L541
2397:ff.c          **** 			}
 6326              		.loc 1 2397 23 is_stmt 1 discriminator 1 view .LVU2287
2397:ff.c          **** 			}
 6327              		.loc 1 2397 29 is_stmt 0 discriminator 1 view .LVU2288
 6328 0080 3146     		mov	r1, r6
 6329 0082 2068     		ldr	r0, [r4]
 6330              	.LVL673:
2397:ff.c          **** 			}
 6331              		.loc 1 2397 29 discriminator 1 view .LVU2289
 6332 0084 FFF7FEFF 		bl	remove_chain
 6333              	.LVL674:
2397:ff.c          **** 			}
 6334              		.loc 1 2397 29 discriminator 1 view .LVU2290
 6335 0088 D7E7     		b	.L540
 6336              		.cfi_endproc
 6337              	.LFE65:
 6339              		.section	.text.f_unlink,"ax",%progbits
 6340              		.align	1
 6341              		.global	f_unlink
 6342              		.syntax unified
 6343              		.thumb
 6344              		.thumb_func
 6345              		.fpu softvfp
 6347              	f_unlink:
 6348              	.LVL675:
 6349              	.LFB66:
2405:ff.c          **** 
2406:ff.c          **** 
2407:ff.c          **** 
2408:ff.c          **** 
2409:ff.c          **** /*-----------------------------------------------------------------------*/
2410:ff.c          **** /* Delete a File or Directory                                            */
2411:ff.c          **** /*-----------------------------------------------------------------------*/
2412:ff.c          **** 
2413:ff.c          **** FRESULT f_unlink (
2414:ff.c          **** 	const XCHAR *path		/* Pointer to the file or directory path */
2415:ff.c          **** )
2416:ff.c          **** {
 6350              		.loc 1 2416 1 is_stmt 1 view -0
 6351              		.cfi_startproc
 6352              		@ args = 0, pretend = 0, frame = 80
 6353              		@ frame_needed = 0, uses_anonymous_args = 0
2417:ff.c          **** 	FRESULT res;
 6354              		.loc 1 2417 2 view .LVU2292
2418:ff.c          **** 	DIR dj, sdj;
 6355              		.loc 1 2418 2 view .LVU2293
2419:ff.c          **** 	NAMEBUF(sfn, lfn);
 6356              		.loc 1 2419 2 view .LVU2294
2420:ff.c          **** 	BYTE *dir;
 6357              		.loc 1 2420 2 view .LVU2295
2421:ff.c          **** 	DWORD dclst;
 6358              		.loc 1 2421 2 view .LVU2296
2422:ff.c          **** 
2423:ff.c          **** 
2424:ff.c          **** 	res = auto_mount(&path, &dj.fs, 1);
 6359              		.loc 1 2424 2 view .LVU2297
2416:ff.c          **** 	FRESULT res;
 6360              		.loc 1 2416 1 is_stmt 0 view .LVU2298
 6361 0000 30B5     		push	{r4, r5, lr}
 6362              		.cfi_def_cfa_offset 12
 6363              		.cfi_offset 4, -12
 6364              		.cfi_offset 5, -8
 6365              		.cfi_offset 14, -4
 6366 0002 95B0     		sub	sp, sp, #84
 6367              		.cfi_def_cfa_offset 96
2416:ff.c          **** 	FRESULT res;
 6368              		.loc 1 2416 1 view .LVU2299
 6369 0004 0190     		str	r0, [sp, #4]
 6370              		.loc 1 2424 8 view .LVU2300
 6371 0006 0122     		movs	r2, #1
 6372 0008 06A9     		add	r1, sp, #24
 6373 000a 01A8     		add	r0, sp, #4
 6374              	.LVL676:
 6375              		.loc 1 2424 8 view .LVU2301
 6376 000c FFF7FEFF 		bl	auto_mount
 6377              	.LVL677:
2425:ff.c          **** 	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 6378              		.loc 1 2425 2 is_stmt 1 view .LVU2302
 6379              		.loc 1 2425 5 is_stmt 0 view .LVU2303
 6380 0010 0446     		mov	r4, r0
 6381 0012 90B9     		cbnz	r0, .L556
2426:ff.c          **** 
2427:ff.c          **** 	INITBUF(dj, sfn, lfn);
 6382              		.loc 1 2427 2 is_stmt 1 view .LVU2304
 6383 0014 03AB     		add	r3, sp, #12
2428:ff.c          **** 	res = follow_path(&dj, path);			/* Follow the file path */
 6384              		.loc 1 2428 8 is_stmt 0 view .LVU2305
 6385 0016 0199     		ldr	r1, [sp, #4]
 6386 0018 06A8     		add	r0, sp, #24
 6387              	.LVL678:
2427:ff.c          **** 	res = follow_path(&dj, path);			/* Follow the file path */
 6388              		.loc 1 2427 2 view .LVU2306
 6389 001a 0C93     		str	r3, [sp, #48]
 6390              		.loc 1 2428 2 is_stmt 1 view .LVU2307
 6391              		.loc 1 2428 8 is_stmt 0 view .LVU2308
 6392 001c FFF7FEFF 		bl	follow_path
 6393              	.LVL679:
2429:ff.c          **** 	if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
 6394              		.loc 1 2429 2 is_stmt 1 view .LVU2309
 6395              		.loc 1 2429 5 is_stmt 0 view .LVU2310
 6396 0020 0446     		mov	r4, r0
 6397 0022 50B9     		cbnz	r0, .L556
 6398              		.loc 1 2429 41 discriminator 1 view .LVU2311
 6399 0024 0C9B     		ldr	r3, [sp, #48]
 6400              		.loc 1 2429 32 discriminator 1 view .LVU2312
 6401 0026 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 6402 0028 9906     		lsls	r1, r3, #26
 6403 002a 41D4     		bmi	.L565
 6404              	.LVL680:
2430:ff.c          **** 		res = FR_INVALID_NAME;
2431:ff.c          **** 	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
 6405              		.loc 1 2431 2 is_stmt 1 view .LVU2313
2432:ff.c          **** 
2433:ff.c          **** 	dir = dj.dir;
 6406              		.loc 1 2433 2 view .LVU2314
 6407              		.loc 1 2433 6 is_stmt 0 view .LVU2315
 6408 002c 0B9B     		ldr	r3, [sp, #44]
 6409              	.LVL681:
2434:ff.c          **** 	if (!dir)								/* Is it the root directory? */
 6410              		.loc 1 2434 2 is_stmt 1 view .LVU2316
 6411              		.loc 1 2434 5 is_stmt 0 view .LVU2317
 6412 002e 002B     		cmp	r3, #0
 6413 0030 3ED0     		beq	.L565
2435:ff.c          **** 		LEAVE_FF(dj.fs, FR_INVALID_NAME);
2436:ff.c          **** 	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
 6414              		.loc 1 2436 2 is_stmt 1 view .LVU2318
 6415              		.loc 1 2436 9 is_stmt 0 view .LVU2319
 6416 0032 D97A     		ldrb	r1, [r3, #11]	@ zero_extendqisi2
 6417              		.loc 1 2436 5 view .LVU2320
 6418 0034 CA07     		lsls	r2, r1, #31
 6419 0036 03D5     		bpl	.L557
 6420              	.LVL682:
 6421              	.L560:
2437:ff.c          **** 		LEAVE_FF(dj.fs, FR_DENIED);
 6422              		.loc 1 2437 3 view .LVU2321
 6423 0038 0724     		movs	r4, #7
 6424              	.L556:
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
2439:ff.c          **** 
2440:ff.c          **** 	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
2441:ff.c          **** 		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
2442:ff.c          **** 		mem_cpy(&sdj, &dj, sizeof(DIR));		/* Check if the sub-dir is empty or not */
2443:ff.c          **** 		sdj.sclust = dclst;
2444:ff.c          **** 		res = dir_seek(&sdj, 0);
2445:ff.c          **** 		if (res != FR_OK) LEAVE_FF(dj.fs, res);
2446:ff.c          **** 		res = dir_read(&sdj);
2447:ff.c          **** 		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
2448:ff.c          **** 		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
2449:ff.c          **** 	}
2450:ff.c          **** 
2451:ff.c          **** 	res = dir_remove(&dj);					/* Remove directory entry */
2452:ff.c          **** 	if (res == FR_OK) {
2453:ff.c          **** 		if (dclst)
2454:ff.c          **** 			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
2455:ff.c          **** 		if (res == FR_OK) res = sync(dj.fs);
2456:ff.c          **** 	}
2457:ff.c          **** 
2458:ff.c          **** 	LEAVE_FF(dj.fs, res);
2459:ff.c          **** }
 6425              		.loc 1 2459 1 view .LVU2322
 6426 003a 2046     		mov	r0, r4
 6427 003c 15B0     		add	sp, sp, #84
 6428              		.cfi_remember_state
 6429              		.cfi_def_cfa_offset 12
 6430              		@ sp needed
 6431 003e 30BD     		pop	{r4, r5, pc}
 6432              	.LVL683:
 6433              	.L557:
 6434              		.cfi_restore_state
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 6435              		.loc 1 2438 2 is_stmt 1 view .LVU2323
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 6436              		.loc 1 2438 18 is_stmt 0 view .LVU2324
 6437 0040 1D7D     		ldrb	r5, [r3, #20]	@ zero_extendqisi2
 6438 0042 5A7D     		ldrb	r2, [r3, #21]	@ zero_extendqisi2
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 6439              		.loc 1 2438 54 view .LVU2325
 6440 0044 D87E     		ldrb	r0, [r3, #27]	@ zero_extendqisi2
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 6441              		.loc 1 2438 11 view .LVU2326
 6442 0046 45EA0222 		orr	r2, r5, r2, lsl #8
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 6443              		.loc 1 2438 54 view .LVU2327
 6444 004a 9D7E     		ldrb	r5, [r3, #26]	@ zero_extendqisi2
2440:ff.c          **** 		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
 6445              		.loc 1 2440 5 view .LVU2328
 6446 004c CB06     		lsls	r3, r1, #27
 6447              	.LVL684:
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 6448              		.loc 1 2438 54 view .LVU2329
 6449 004e 45EA0025 		orr	r5, r5, r0, lsl #8
2438:ff.c          **** 	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 6450              		.loc 1 2438 8 view .LVU2330
 6451 0052 45EA0245 		orr	r5, r5, r2, lsl #16
 6452              	.LVL685:
2440:ff.c          **** 		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
 6453              		.loc 1 2440 2 is_stmt 1 view .LVU2331
2440:ff.c          **** 		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
 6454              		.loc 1 2440 5 is_stmt 0 view .LVU2332
 6455 0056 0BD4     		bmi	.L558
 6456              	.LVL686:
 6457              	.L561:
2451:ff.c          **** 	if (res == FR_OK) {
 6458              		.loc 1 2451 2 is_stmt 1 view .LVU2333
2451:ff.c          **** 	if (res == FR_OK) {
 6459              		.loc 1 2451 8 is_stmt 0 view .LVU2334
 6460 0058 06A8     		add	r0, sp, #24
 6461 005a FFF7FEFF 		bl	dir_remove
 6462              	.LVL687:
2452:ff.c          **** 		if (dclst)
 6463              		.loc 1 2452 2 is_stmt 1 view .LVU2335
2452:ff.c          **** 		if (dclst)
 6464              		.loc 1 2452 5 is_stmt 0 view .LVU2336
 6465 005e 0446     		mov	r4, r0
 6466 0060 0028     		cmp	r0, #0
 6467 0062 EAD1     		bne	.L556
2453:ff.c          **** 			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
 6468              		.loc 1 2453 3 is_stmt 1 view .LVU2337
2453:ff.c          **** 			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
 6469              		.loc 1 2453 6 is_stmt 0 view .LVU2338
 6470 0064 E5B9     		cbnz	r5, .L562
 6471              	.L563:
 6472              	.LVL688:
2455:ff.c          **** 	}
 6473              		.loc 1 2455 21 is_stmt 1 view .LVU2339
2455:ff.c          **** 	}
 6474              		.loc 1 2455 27 is_stmt 0 view .LVU2340
 6475 0066 0698     		ldr	r0, [sp, #24]
 6476 0068 FFF7FEFF 		bl	sync
 6477              	.LVL689:
 6478 006c 0446     		mov	r4, r0
 6479              	.LVL690:
2455:ff.c          **** 	}
 6480              		.loc 1 2455 27 view .LVU2341
 6481 006e E4E7     		b	.L556
 6482              	.LVL691:
 6483              	.L558:
2441:ff.c          **** 		mem_cpy(&sdj, &dj, sizeof(DIR));		/* Check if the sub-dir is empty or not */
 6484              		.loc 1 2441 3 is_stmt 1 view .LVU2342
2441:ff.c          **** 		mem_cpy(&sdj, &dj, sizeof(DIR));		/* Check if the sub-dir is empty or not */
 6485              		.loc 1 2441 6 is_stmt 0 view .LVU2343
 6486 0070 012D     		cmp	r5, #1
 6487 0072 1FD9     		bls	.L566
2442:ff.c          **** 		sdj.sclust = dclst;
 6488              		.loc 1 2442 3 is_stmt 1 view .LVU2344
 6489 0074 1C22     		movs	r2, #28
 6490 0076 06A9     		add	r1, sp, #24
 6491 0078 0DA8     		add	r0, sp, #52
 6492 007a FFF7FEFF 		bl	mem_cpy
 6493              	.LVL692:
2443:ff.c          **** 		res = dir_seek(&sdj, 0);
 6494              		.loc 1 2443 3 view .LVU2345
2444:ff.c          **** 		if (res != FR_OK) LEAVE_FF(dj.fs, res);
 6495              		.loc 1 2444 9 is_stmt 0 view .LVU2346
 6496 007e 2146     		mov	r1, r4
 6497 0080 0DA8     		add	r0, sp, #52
2443:ff.c          **** 		res = dir_seek(&sdj, 0);
 6498              		.loc 1 2443 14 view .LVU2347
 6499 0082 0F95     		str	r5, [sp, #60]
2444:ff.c          **** 		if (res != FR_OK) LEAVE_FF(dj.fs, res);
 6500              		.loc 1 2444 3 is_stmt 1 view .LVU2348
2444:ff.c          **** 		if (res != FR_OK) LEAVE_FF(dj.fs, res);
 6501              		.loc 1 2444 9 is_stmt 0 view .LVU2349
 6502 0084 FFF7FEFF 		bl	dir_seek
 6503              	.LVL693:
2445:ff.c          **** 		res = dir_read(&sdj);
 6504              		.loc 1 2445 3 is_stmt 1 view .LVU2350
2445:ff.c          **** 		res = dir_read(&sdj);
 6505              		.loc 1 2445 6 is_stmt 0 view .LVU2351
 6506 0088 0446     		mov	r4, r0
 6507 008a 0028     		cmp	r0, #0
 6508 008c D5D1     		bne	.L556
2446:ff.c          **** 		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
 6509              		.loc 1 2446 3 is_stmt 1 view .LVU2352
2446:ff.c          **** 		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
 6510              		.loc 1 2446 9 is_stmt 0 view .LVU2353
 6511 008e 0DA8     		add	r0, sp, #52
 6512              	.LVL694:
2446:ff.c          **** 		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
 6513              		.loc 1 2446 9 view .LVU2354
 6514 0090 FFF7FEFF 		bl	dir_read
 6515              	.LVL695:
2447:ff.c          **** 		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
 6516              		.loc 1 2447 3 is_stmt 1 view .LVU2355
2447:ff.c          **** 		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
 6517              		.loc 1 2447 6 is_stmt 0 view .LVU2356
 6518 0094 0446     		mov	r4, r0
 6519 0096 0028     		cmp	r0, #0
 6520 0098 CED0     		beq	.L560
2448:ff.c          **** 	}
 6521              		.loc 1 2448 3 is_stmt 1 view .LVU2357
2448:ff.c          **** 	}
 6522              		.loc 1 2448 6 is_stmt 0 view .LVU2358
 6523 009a 0428     		cmp	r0, #4
 6524 009c CDD1     		bne	.L556
 6525 009e DBE7     		b	.L561
 6526              	.L562:
2454:ff.c          **** 		if (res == FR_OK) res = sync(dj.fs);
 6527              		.loc 1 2454 4 is_stmt 1 view .LVU2359
2454:ff.c          **** 		if (res == FR_OK) res = sync(dj.fs);
 6528              		.loc 1 2454 10 is_stmt 0 view .LVU2360
 6529 00a0 2946     		mov	r1, r5
 6530 00a2 0698     		ldr	r0, [sp, #24]
 6531              	.LVL696:
2454:ff.c          **** 		if (res == FR_OK) res = sync(dj.fs);
 6532              		.loc 1 2454 10 view .LVU2361
 6533 00a4 FFF7FEFF 		bl	remove_chain
 6534              	.LVL697:
2455:ff.c          **** 	}
 6535              		.loc 1 2455 3 is_stmt 1 view .LVU2362
2455:ff.c          **** 	}
 6536              		.loc 1 2455 6 is_stmt 0 view .LVU2363
 6537 00a8 0446     		mov	r4, r0
 6538 00aa 0028     		cmp	r0, #0
 6539 00ac C5D1     		bne	.L556
 6540 00ae DAE7     		b	.L563
 6541              	.LVL698:
 6542              	.L565:
2430:ff.c          **** 	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
 6543              		.loc 1 2430 7 view .LVU2364
 6544 00b0 0624     		movs	r4, #6
 6545 00b2 C2E7     		b	.L556
 6546              	.LVL699:
 6547              	.L566:
2441:ff.c          **** 		mem_cpy(&sdj, &dj, sizeof(DIR));		/* Check if the sub-dir is empty or not */
 6548              		.loc 1 2441 18 view .LVU2365
 6549 00b4 0224     		movs	r4, #2
 6550 00b6 C0E7     		b	.L556
 6551              		.cfi_endproc
 6552              	.LFE66:
 6554              		.section	.text.f_mkdir,"ax",%progbits
 6555              		.align	1
 6556              		.global	f_mkdir
 6557              		.syntax unified
 6558              		.thumb
 6559              		.thumb_func
 6560              		.fpu softvfp
 6562              	f_mkdir:
 6563              	.LVL700:
 6564              	.LFB67:
2460:ff.c          **** 
2461:ff.c          **** 
2462:ff.c          **** 
2463:ff.c          **** 
2464:ff.c          **** /*-----------------------------------------------------------------------*/
2465:ff.c          **** /* Create a Directory                                                    */
2466:ff.c          **** /*-----------------------------------------------------------------------*/
2467:ff.c          **** 
2468:ff.c          **** FRESULT f_mkdir (
2469:ff.c          **** 	const XCHAR *path		/* Pointer to the directory path */
2470:ff.c          **** )
2471:ff.c          **** {
 6565              		.loc 1 2471 1 is_stmt 1 view -0
 6566              		.cfi_startproc
 6567              		@ args = 0, pretend = 0, frame = 72
 6568              		@ frame_needed = 0, uses_anonymous_args = 0
2472:ff.c          **** 	FRESULT res;
 6569              		.loc 1 2472 2 view .LVU2367
2473:ff.c          **** 	DIR dj;
 6570              		.loc 1 2473 2 view .LVU2368
2474:ff.c          **** 	NAMEBUF(sfn, lfn);
 6571              		.loc 1 2474 2 view .LVU2369
2475:ff.c          **** 	BYTE *dir, n;
 6572              		.loc 1 2475 2 view .LVU2370
2476:ff.c          **** 	DWORD dsect, dclst, pclst, tim;
 6573              		.loc 1 2476 2 view .LVU2371
2477:ff.c          **** 
2478:ff.c          **** 
2479:ff.c          **** 	res = auto_mount(&path, &dj.fs, 1);
 6574              		.loc 1 2479 2 view .LVU2372
2471:ff.c          **** 	FRESULT res;
 6575              		.loc 1 2471 1 is_stmt 0 view .LVU2373
 6576 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 6577              		.cfi_def_cfa_offset 36
 6578              		.cfi_offset 4, -36
 6579              		.cfi_offset 5, -32
 6580              		.cfi_offset 6, -28
 6581              		.cfi_offset 7, -24
 6582              		.cfi_offset 8, -20
 6583              		.cfi_offset 9, -16
 6584              		.cfi_offset 10, -12
 6585              		.cfi_offset 11, -8
 6586              		.cfi_offset 14, -4
 6587 0004 93B0     		sub	sp, sp, #76
 6588              		.cfi_def_cfa_offset 112
2471:ff.c          **** 	FRESULT res;
 6589              		.loc 1 2471 1 view .LVU2374
 6590 0006 0790     		str	r0, [sp, #28]
 6591              		.loc 1 2479 8 view .LVU2375
 6592 0008 0122     		movs	r2, #1
 6593 000a 0BA9     		add	r1, sp, #44
 6594 000c 07A8     		add	r0, sp, #28
 6595              	.LVL701:
 6596              		.loc 1 2479 8 view .LVU2376
 6597 000e FFF7FEFF 		bl	auto_mount
 6598              	.LVL702:
2480:ff.c          **** 	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 6599              		.loc 1 2480 2 is_stmt 1 view .LVU2377
 6600              		.loc 1 2480 5 is_stmt 0 view .LVU2378
 6601 0012 0646     		mov	r6, r0
 6602 0014 0028     		cmp	r0, #0
 6603 0016 40F09480 		bne	.L592
2481:ff.c          **** 
2482:ff.c          **** 	INITBUF(dj, sfn, lfn);
 6604              		.loc 1 2482 2 is_stmt 1 view .LVU2379
 6605 001a 08AB     		add	r3, sp, #32
2483:ff.c          **** 	res = follow_path(&dj, path);			/* Follow the file path */
 6606              		.loc 1 2483 8 is_stmt 0 view .LVU2380
 6607 001c 0799     		ldr	r1, [sp, #28]
 6608 001e 0BA8     		add	r0, sp, #44
 6609              	.LVL703:
2482:ff.c          **** 	res = follow_path(&dj, path);			/* Follow the file path */
 6610              		.loc 1 2482 2 view .LVU2381
 6611 0020 1193     		str	r3, [sp, #68]
 6612              		.loc 1 2483 2 is_stmt 1 view .LVU2382
 6613              		.loc 1 2483 8 is_stmt 0 view .LVU2383
 6614 0022 FFF7FEFF 		bl	follow_path
 6615              	.LVL704:
2484:ff.c          **** 	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
 6616              		.loc 1 2484 2 is_stmt 1 view .LVU2384
 6617              		.loc 1 2484 5 is_stmt 0 view .LVU2385
 6618 0026 0646     		mov	r6, r0
 6619 0028 0028     		cmp	r0, #0
 6620 002a 00F0C280 		beq	.L587
2485:ff.c          **** 	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[11] & NS_DOT))
 6621              		.loc 1 2485 2 is_stmt 1 view .LVU2386
 6622              		.loc 1 2485 5 is_stmt 0 view .LVU2387
 6623 002e 0428     		cmp	r0, #4
 6624 0030 40F08780 		bne	.L592
 6625              		.loc 1 2485 46 discriminator 1 view .LVU2388
 6626 0034 119B     		ldr	r3, [sp, #68]
 6627              		.loc 1 2485 37 discriminator 1 view .LVU2389
 6628 0036 DC7A     		ldrb	r4, [r3, #11]	@ zero_extendqisi2
 6629 0038 14F02004 		ands	r4, r4, #32
 6630 003c 40F0BB80 		bne	.L588
 6631              	.LVL705:
2486:ff.c          **** 		res = FR_INVALID_NAME;
2487:ff.c          **** 	if (res != FR_NO_FILE)					/* Any error occured */
 6632              		.loc 1 2487 2 is_stmt 1 view .LVU2390
2488:ff.c          **** 		LEAVE_FF(dj.fs, res);
2489:ff.c          **** 
2490:ff.c          **** 	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
 6633              		.loc 1 2490 2 view .LVU2391
 6634              		.loc 1 2490 10 is_stmt 0 view .LVU2392
 6635 0040 2146     		mov	r1, r4
 6636 0042 0B98     		ldr	r0, [sp, #44]
 6637 0044 FFF7FEFF 		bl	create_chain
 6638              	.LVL706:
2491:ff.c          **** 	res = FR_OK;
 6639              		.loc 1 2491 2 is_stmt 1 view .LVU2393
2492:ff.c          **** 	if (dclst == 0) res = FR_DENIED;
 6640              		.loc 1 2492 2 view .LVU2394
 6641              		.loc 1 2492 5 is_stmt 0 view .LVU2395
 6642 0048 0546     		mov	r5, r0
 6643 004a 0028     		cmp	r0, #0
 6644 004c 00F0B580 		beq	.L589
2493:ff.c          **** 	if (dclst == 1) res = FR_INT_ERR;
 6645              		.loc 1 2493 2 is_stmt 1 view .LVU2396
 6646              		.loc 1 2493 5 is_stmt 0 view .LVU2397
 6647 0050 0128     		cmp	r0, #1
 6648 0052 00F0B480 		beq	.L590
2494:ff.c          **** 	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
 6649              		.loc 1 2494 2 is_stmt 1 view .LVU2398
 6650              		.loc 1 2494 5 is_stmt 0 view .LVU2399
 6651 0056 431C     		adds	r3, r0, #1
 6652 0058 00F0B380 		beq	.L591
2495:ff.c          **** 	if (res == FR_OK)
 6653              		.loc 1 2495 2 is_stmt 1 view .LVU2400
 6654              	.LVL707:
2496:ff.c          **** 		res = move_window(dj.fs, 0);
 6655              		.loc 1 2496 3 view .LVU2401
 6656              		.loc 1 2496 9 is_stmt 0 view .LVU2402
 6657 005c 2146     		mov	r1, r4
 6658 005e 0B98     		ldr	r0, [sp, #44]
 6659              	.LVL708:
 6660              		.loc 1 2496 9 view .LVU2403
 6661 0060 FFF7FEFF 		bl	move_window
 6662              	.LVL709:
2497:ff.c          **** 	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 6663              		.loc 1 2497 2 is_stmt 1 view .LVU2404
 6664              		.loc 1 2497 5 is_stmt 0 view .LVU2405
 6665 0064 0646     		mov	r6, r0
 6666 0066 0028     		cmp	r0, #0
 6667 0068 6BD1     		bne	.L592
2498:ff.c          **** 	dsect = clust2sect(dj.fs, dclst);
 6668              		.loc 1 2498 2 is_stmt 1 view .LVU2406
 6669              		.loc 1 2498 10 is_stmt 0 view .LVU2407
 6670 006a 0B9C     		ldr	r4, [sp, #44]
 6671 006c 2946     		mov	r1, r5
 6672 006e 2046     		mov	r0, r4
 6673              	.LVL710:
 6674              		.loc 1 2498 10 view .LVU2408
 6675 0070 FFF7FEFF 		bl	clust2sect
 6676              	.LVL711:
2499:ff.c          **** 
2500:ff.c          **** 	dir = dj.fs->win;						/* Initialize the new directory table */
 6677              		.loc 1 2500 6 view .LVU2409
 6678 0074 04F13407 		add	r7, r4, #52
2498:ff.c          **** 	dsect = clust2sect(dj.fs, dclst);
 6679              		.loc 1 2498 10 view .LVU2410
 6680 0078 0690     		str	r0, [sp, #24]
 6681              	.LVL712:
 6682              		.loc 1 2500 2 is_stmt 1 view .LVU2411
2501:ff.c          **** 	mem_set(dir, 0, SS(dj.fs));
 6683              		.loc 1 2501 2 view .LVU2412
 6684              	.LBB143:
 6685              	.LBI143:
 170:ff.c          **** 	char *d = (char*)dst;
 6686              		.loc 1 170 6 view .LVU2413
 6687              	.LBB144:
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 6688              		.loc 1 171 2 view .LVU2414
 172:ff.c          **** }
 6689              		.loc 1 172 2 view .LVU2415
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 6690              		.loc 1 171 8 is_stmt 0 view .LVU2416
 6691 007a B846     		mov	r8, r7
 172:ff.c          **** }
 6692              		.loc 1 172 21 view .LVU2417
 6693 007c 3046     		mov	r0, r6
 6694              	.LVL713:
 172:ff.c          **** }
 6695              		.loc 1 172 21 view .LVU2418
 6696 007e 04F50D72 		add	r2, r4, #564
 6697              	.LVL714:
 6698              	.L576:
 172:ff.c          **** }
 6699              		.loc 1 172 8 is_stmt 1 view .LVU2419
 172:ff.c          **** }
 6700              		.loc 1 172 8 is_stmt 0 view .LVU2420
 6701 0082 4245     		cmp	r2, r8
 6702 0084 61D1     		bne	.L577
 172:ff.c          **** }
 6703              		.loc 1 172 8 view .LVU2421
 6704              	.LBE144:
 6705              	.LBE143:
 6706              	.LBB146:
 6707              	.LBB147:
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 6708              		.loc 1 171 8 view .LVU2422
 6709 0086 3B46     		mov	r3, r7
 172:ff.c          **** }
 6710              		.loc 1 172 21 view .LVU2423
 6711 0088 2021     		movs	r1, #32
 6712 008a 04F13F02 		add	r2, r4, #63
 6713              	.LVL715:
 6714              	.L578:
 172:ff.c          **** }
 6715              		.loc 1 172 8 is_stmt 1 view .LVU2424
 172:ff.c          **** }
 6716              		.loc 1 172 8 is_stmt 0 view .LVU2425
 6717 008e 9A42     		cmp	r2, r3
 6718 0090 5ED1     		bne	.L579
 6719              	.LVL716:
 172:ff.c          **** }
 6720              		.loc 1 172 8 view .LVU2426
 6721              	.LBE147:
 6722              	.LBE146:
2502:ff.c          **** 	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
2503:ff.c          **** 	dir[DIR_Name] = '.';
 6723              		.loc 1 2503 2 is_stmt 1 view .LVU2427
2504:ff.c          **** 	dir[DIR_Attr] = AM_DIR;
 6724              		.loc 1 2504 16 is_stmt 0 view .LVU2428
 6725 0092 1022     		movs	r2, #16
2503:ff.c          **** 	dir[DIR_Attr] = AM_DIR;
 6726              		.loc 1 2503 16 view .LVU2429
 6727 0094 2E26     		movs	r6, #46
 6728              		.loc 1 2504 16 view .LVU2430
 6729 0096 84F83F20 		strb	r2, [r4, #63]
2503:ff.c          **** 	dir[DIR_Attr] = AM_DIR;
 6730              		.loc 1 2503 16 view .LVU2431
 6731 009a 84F83460 		strb	r6, [r4, #52]
 6732              		.loc 1 2504 2 is_stmt 1 view .LVU2432
2505:ff.c          **** 	tim = get_fattime();
 6733              		.loc 1 2505 2 view .LVU2433
 6734              		.loc 1 2505 8 is_stmt 0 view .LVU2434
 6735 009e FFF7FEFF 		bl	get_fattime
 6736              	.LVL717:
2506:ff.c          **** 	ST_DWORD(dir+DIR_WrtTime, tim);
 6737              		.loc 1 2506 2 is_stmt 1 view .LVU2435
 6738 00a2 030E     		lsrs	r3, r0, #24
 6739 00a4 0193     		str	r3, [sp, #4]
 6740 00a6 84F84D30 		strb	r3, [r4, #77]
2507:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, dclst);
 6741              		.loc 1 2507 2 is_stmt 0 view .LVU2436
 6742 00aa EBB2     		uxtb	r3, r5
 6743 00ac 0293     		str	r3, [sp, #8]
 6744 00ae 84F84E30 		strb	r3, [r4, #78]
 6745 00b2 C5F30723 		ubfx	r3, r5, #8, #8
 6746 00b6 0393     		str	r3, [sp, #12]
 6747 00b8 84F84F30 		strb	r3, [r4, #79]
2508:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6748              		.loc 1 2508 2 view .LVU2437
 6749 00bc C5F30743 		ubfx	r3, r5, #16, #8
2506:ff.c          **** 	ST_DWORD(dir+DIR_WrtTime, tim);
 6750              		.loc 1 2506 2 view .LVU2438
 6751 00c0 5FFA80FB 		uxtb	fp, r0
 6752 00c4 C0F3072A 		ubfx	r10, r0, #8, #8
 6753 00c8 C0F30749 		ubfx	r9, r0, #16, #8
 6754              		.loc 1 2508 2 view .LVU2439
 6755 00cc 0493     		str	r3, [sp, #16]
 6756 00ce 84F84830 		strb	r3, [r4, #72]
 6757 00d2 2B0E     		lsrs	r3, r5, #24
2509:ff.c          **** 	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 6758              		.loc 1 2509 2 view .LVU2440
 6759 00d4 2022     		movs	r2, #32
 6760 00d6 3946     		mov	r1, r7
2508:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6761              		.loc 1 2508 2 view .LVU2441
 6762 00d8 84F84930 		strb	r3, [r4, #73]
2506:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, dclst);
 6763              		.loc 1 2506 2 view .LVU2442
 6764 00dc 84F84AB0 		strb	fp, [r4, #74]
2506:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, dclst);
 6765              		.loc 1 2506 2 is_stmt 1 view .LVU2443
 6766 00e0 84F84BA0 		strb	r10, [r4, #75]
2506:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, dclst);
 6767              		.loc 1 2506 2 view .LVU2444
 6768 00e4 84F84C90 		strb	r9, [r4, #76]
2506:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, dclst);
 6769              		.loc 1 2506 2 view .LVU2445
2507:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6770              		.loc 1 2507 2 view .LVU2446
2507:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6771              		.loc 1 2507 2 view .LVU2447
2508:ff.c          **** 	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 6772              		.loc 1 2508 2 view .LVU2448
2508:ff.c          **** 	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 6773              		.loc 1 2508 2 view .LVU2449
 6774              		.loc 1 2509 2 view .LVU2450
 6775 00e8 04F15400 		add	r0, r4, #84
 6776              	.LVL718:
2508:ff.c          **** 	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 6777              		.loc 1 2508 2 is_stmt 0 view .LVU2451
 6778 00ec 0593     		str	r3, [sp, #20]
 6779              		.loc 1 2509 2 view .LVU2452
 6780 00ee FFF7FEFF 		bl	mem_cpy
 6781              	.LVL719:
2510:ff.c          **** 	dir[33] = '.';
 6782              		.loc 1 2510 2 is_stmt 1 view .LVU2453
2511:ff.c          **** 	pclst = dj.sclust;
2512:ff.c          **** 	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
 6783              		.loc 1 2512 8 is_stmt 0 view .LVU2454
 6784 00f2 0B9A     		ldr	r2, [sp, #44]
2510:ff.c          **** 	dir[33] = '.';
 6785              		.loc 1 2510 10 view .LVU2455
 6786 00f4 84F85560 		strb	r6, [r4, #85]
2511:ff.c          **** 	pclst = dj.sclust;
 6787              		.loc 1 2511 2 is_stmt 1 view .LVU2456
 6788              		.loc 1 2512 5 is_stmt 0 view .LVU2457
 6789 00f8 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
2511:ff.c          **** 	pclst = dj.sclust;
 6790              		.loc 1 2511 8 view .LVU2458
 6791 00fa 0D9B     		ldr	r3, [sp, #52]
 6792              	.LVL720:
 6793              		.loc 1 2512 2 is_stmt 1 view .LVU2459
 6794              		.loc 1 2512 5 is_stmt 0 view .LVU2460
 6795 00fc 0329     		cmp	r1, #3
 6796 00fe 03D1     		bne	.L580
 6797              		.loc 1 2512 33 discriminator 1 view .LVU2461
 6798 0100 926A     		ldr	r2, [r2, #40]
2513:ff.c          **** 		pclst = 0;
 6799              		.loc 1 2513 9 discriminator 1 view .LVU2462
 6800 0102 9A42     		cmp	r2, r3
 6801 0104 08BF     		it	eq
 6802 0106 0023     		moveq	r3, #0
 6803              	.LVL721:
 6804              	.L580:
2514:ff.c          **** 	ST_WORD(dir+32+DIR_FstClusLO, pclst);
 6805              		.loc 1 2514 2 is_stmt 1 view .LVU2463
 6806 0108 84F86E30 		strb	r3, [r4, #110]
 6807              		.loc 1 2514 2 view .LVU2464
 6808 010c C3F30722 		ubfx	r2, r3, #8, #8
2515:ff.c          **** 	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
 6809              		.loc 1 2515 2 is_stmt 0 view .LVU2465
 6810 0110 1B0C     		lsrs	r3, r3, #16
 6811              	.LVL722:
 6812              		.loc 1 2515 2 view .LVU2466
 6813 0112 84F86830 		strb	r3, [r4, #104]
 6814 0116 1B0A     		lsrs	r3, r3, #8
2514:ff.c          **** 	ST_WORD(dir+32+DIR_FstClusLO, pclst);
 6815              		.loc 1 2514 2 view .LVU2467
 6816 0118 84F86F20 		strb	r2, [r4, #111]
 6817              		.loc 1 2515 2 is_stmt 1 view .LVU2468
 6818              		.loc 1 2515 2 view .LVU2469
 6819 011c 84F86930 		strb	r3, [r4, #105]
2516:ff.c          **** 	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
 6820              		.loc 1 2516 2 view .LVU2470
 6821              	.LVL723:
 6822              		.loc 1 2516 2 is_stmt 0 view .LVU2471
 6823 0120 0024     		movs	r4, #0
 6824              	.LVL724:
 6825              	.L581:
 6826              		.loc 1 2516 20 discriminator 1 view .LVU2472
 6827 0122 0B98     		ldr	r0, [sp, #44]
 6828 0124 069B     		ldr	r3, [sp, #24]
 6829              		.loc 1 2516 2 discriminator 1 view .LVU2473
 6830 0126 8178     		ldrb	r1, [r0, #2]	@ zero_extendqisi2
 6831 0128 1A19     		adds	r2, r3, r4
 6832              	.LVL725:
 6833              		.loc 1 2516 14 is_stmt 1 discriminator 1 view .LVU2474
 6834              		.loc 1 2516 2 is_stmt 0 discriminator 1 view .LVU2475
 6835 012a E3B2     		uxtb	r3, r4
 6836 012c 9942     		cmp	r1, r3
 6837 012e 12D8     		bhi	.L584
2517:ff.c          **** 		dj.fs->winsect = dsect++;
2518:ff.c          **** 		dj.fs->wflag = 1;
2519:ff.c          **** 		res = move_window(dj.fs, 0);
2520:ff.c          **** 		if (res) LEAVE_FF(dj.fs, res);
2521:ff.c          **** 		mem_set(dir, 0, SS(dj.fs));
2522:ff.c          **** 	}
2523:ff.c          **** 
2524:ff.c          **** 	res = dir_register(&dj);
 6838              		.loc 1 2524 2 is_stmt 1 view .LVU2476
 6839              		.loc 1 2524 8 is_stmt 0 view .LVU2477
 6840 0130 0BA8     		add	r0, sp, #44
 6841 0132 FFF7FEFF 		bl	dir_register
 6842              	.LVL726:
2525:ff.c          **** 	if (res != FR_OK) {
 6843              		.loc 1 2525 2 is_stmt 1 view .LVU2478
 6844              		.loc 1 2525 5 is_stmt 0 view .LVU2479
 6845 0136 0646     		mov	r6, r0
 6846 0138 08B3     		cbz	r0, .L585
2526:ff.c          **** 		remove_chain(dj.fs, dclst);
 6847              		.loc 1 2526 3 is_stmt 1 view .LVU2480
 6848 013a 2946     		mov	r1, r5
 6849 013c 0B98     		ldr	r0, [sp, #44]
 6850              	.LVL727:
 6851              		.loc 1 2526 3 is_stmt 0 view .LVU2481
 6852 013e FFF7FEFF 		bl	remove_chain
 6853              	.LVL728:
 6854              	.L592:
2527:ff.c          **** 	} else {
2528:ff.c          **** 		dir = dj.dir;
2529:ff.c          **** 		dir[DIR_Attr] = AM_DIR;					/* Attribute */
2530:ff.c          **** 		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
2531:ff.c          **** 		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
2532:ff.c          **** 		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
2533:ff.c          **** 		dj.fs->wflag = 1;
2534:ff.c          **** 		res = sync(dj.fs);
2535:ff.c          **** 	}
2536:ff.c          **** 
2537:ff.c          **** 	LEAVE_FF(dj.fs, res);
2538:ff.c          **** }
 6855              		.loc 1 2538 1 view .LVU2482
 6856 0142 3046     		mov	r0, r6
 6857 0144 13B0     		add	sp, sp, #76
 6858              		.cfi_remember_state
 6859              		.cfi_def_cfa_offset 36
 6860              		@ sp needed
 6861 0146 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 6862              	.LVL729:
 6863              	.L577:
 6864              		.cfi_restore_state
 6865              	.LBB149:
 6866              	.LBB145:
 172:ff.c          **** }
 6867              		.loc 1 172 16 is_stmt 1 view .LVU2483
 172:ff.c          **** }
 6868              		.loc 1 172 21 is_stmt 0 view .LVU2484
 6869 014a 08F8010B 		strb	r0, [r8], #1
 6870              	.LVL730:
 172:ff.c          **** }
 6871              		.loc 1 172 21 view .LVU2485
 6872 014e 98E7     		b	.L576
 6873              	.LVL731:
 6874              	.L579:
 172:ff.c          **** }
 6875              		.loc 1 172 21 view .LVU2486
 6876              	.LBE145:
 6877              	.LBE149:
 6878              	.LBB150:
 6879              	.LBB148:
 172:ff.c          **** }
 6880              		.loc 1 172 16 is_stmt 1 view .LVU2487
 172:ff.c          **** }
 6881              		.loc 1 172 21 is_stmt 0 view .LVU2488
 6882 0150 03F8011B 		strb	r1, [r3], #1
 6883              	.LVL732:
 172:ff.c          **** }
 6884              		.loc 1 172 21 view .LVU2489
 6885 0154 9BE7     		b	.L578
 6886              	.LVL733:
 6887              	.L584:
 172:ff.c          **** }
 6888              		.loc 1 172 21 view .LVU2490
 6889              	.LBE148:
 6890              	.LBE150:
2517:ff.c          **** 		dj.fs->wflag = 1;
 6891              		.loc 1 2517 3 is_stmt 1 view .LVU2491
2518:ff.c          **** 		res = move_window(dj.fs, 0);
 6892              		.loc 1 2518 16 is_stmt 0 view .LVU2492
 6893 0156 4FF00103 		mov	r3, #1
2519:ff.c          **** 		if (res) LEAVE_FF(dj.fs, res);
 6894              		.loc 1 2519 9 view .LVU2493
 6895 015a 0021     		movs	r1, #0
2517:ff.c          **** 		dj.fs->wflag = 1;
 6896              		.loc 1 2517 18 view .LVU2494
 6897 015c 0263     		str	r2, [r0, #48]
2518:ff.c          **** 		res = move_window(dj.fs, 0);
 6898              		.loc 1 2518 3 is_stmt 1 view .LVU2495
2518:ff.c          **** 		res = move_window(dj.fs, 0);
 6899              		.loc 1 2518 16 is_stmt 0 view .LVU2496
 6900 015e 0371     		strb	r3, [r0, #4]
2519:ff.c          **** 		if (res) LEAVE_FF(dj.fs, res);
 6901              		.loc 1 2519 3 is_stmt 1 view .LVU2497
2519:ff.c          **** 		if (res) LEAVE_FF(dj.fs, res);
 6902              		.loc 1 2519 9 is_stmt 0 view .LVU2498
 6903 0160 FFF7FEFF 		bl	move_window
 6904              	.LVL734:
2520:ff.c          **** 		mem_set(dir, 0, SS(dj.fs));
 6905              		.loc 1 2520 3 is_stmt 1 view .LVU2499
2520:ff.c          **** 		mem_set(dir, 0, SS(dj.fs));
 6906              		.loc 1 2520 6 is_stmt 0 view .LVU2500
 6907 0164 0646     		mov	r6, r0
 6908 0166 0028     		cmp	r0, #0
 6909 0168 EBD1     		bne	.L592
 6910              	.LBB151:
 6911              	.LBB152:
 171:ff.c          **** 	while (cnt--) *d++ = (char)val;
 6912              		.loc 1 171 8 view .LVU2501
 6913 016a 3B46     		mov	r3, r7
 6914              	.L582:
 6915              	.LVL735:
 172:ff.c          **** }
 6916              		.loc 1 172 8 is_stmt 1 view .LVU2502
 172:ff.c          **** }
 6917              		.loc 1 172 8 is_stmt 0 view .LVU2503
 6918 016c 9845     		cmp	r8, r3
 6919 016e 01D1     		bne	.L583
 6920              	.LVL736:
 172:ff.c          **** }
 6921              		.loc 1 172 8 view .LVU2504
 6922              	.LBE152:
 6923              	.LBE151:
2516:ff.c          **** 		dj.fs->winsect = dsect++;
 6924              		.loc 1 2516 32 is_stmt 1 discriminator 2 view .LVU2505
2516:ff.c          **** 		dj.fs->winsect = dsect++;
 6925              		.loc 1 2516 32 is_stmt 0 discriminator 2 view .LVU2506
 6926 0170 0134     		adds	r4, r4, #1
 6927              	.LVL737:
2516:ff.c          **** 		dj.fs->winsect = dsect++;
 6928              		.loc 1 2516 32 discriminator 2 view .LVU2507
 6929 0172 D6E7     		b	.L581
 6930              	.LVL738:
 6931              	.L583:
 6932              	.LBB154:
 6933              	.LBB153:
 172:ff.c          **** }
 6934              		.loc 1 172 16 is_stmt 1 view .LVU2508
 172:ff.c          **** }
 6935              		.loc 1 172 21 is_stmt 0 view .LVU2509
 6936 0174 4FF00002 		mov	r2, #0
 6937 0178 03F8012B 		strb	r2, [r3], #1
 6938              	.LVL739:
 172:ff.c          **** }
 6939              		.loc 1 172 21 view .LVU2510
 6940 017c F6E7     		b	.L582
 6941              	.LVL740:
 6942              	.L585:
 172:ff.c          **** }
 6943              		.loc 1 172 21 view .LVU2511
 6944              	.LBE153:
 6945              	.LBE154:
2528:ff.c          **** 		dir[DIR_Attr] = AM_DIR;					/* Attribute */
 6946              		.loc 1 2528 3 is_stmt 1 view .LVU2512
2529:ff.c          **** 		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
 6947              		.loc 1 2529 17 is_stmt 0 view .LVU2513
 6948 017e 1022     		movs	r2, #16
2528:ff.c          **** 		dir[DIR_Attr] = AM_DIR;					/* Attribute */
 6949              		.loc 1 2528 7 view .LVU2514
 6950 0180 109B     		ldr	r3, [sp, #64]
 6951              	.LVL741:
2529:ff.c          **** 		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
 6952              		.loc 1 2529 3 is_stmt 1 view .LVU2515
2533:ff.c          **** 		res = sync(dj.fs);
 6953              		.loc 1 2533 5 is_stmt 0 view .LVU2516
 6954 0182 0B98     		ldr	r0, [sp, #44]
 6955              	.LVL742:
2529:ff.c          **** 		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
 6956              		.loc 1 2529 17 view .LVU2517
 6957 0184 DA72     		strb	r2, [r3, #11]
2530:ff.c          **** 		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 6958              		.loc 1 2530 3 is_stmt 1 view .LVU2518
 6959 0186 019A     		ldr	r2, [sp, #4]
 6960 0188 83F816B0 		strb	fp, [r3, #22]
2530:ff.c          **** 		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 6961              		.loc 1 2530 3 view .LVU2519
 6962 018c 5A76     		strb	r2, [r3, #25]
2531:ff.c          **** 		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6963              		.loc 1 2531 3 is_stmt 0 view .LVU2520
 6964 018e 029A     		ldr	r2, [sp, #8]
2530:ff.c          **** 		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 6965              		.loc 1 2530 3 view .LVU2521
 6966 0190 83F817A0 		strb	r10, [r3, #23]
2530:ff.c          **** 		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 6967              		.loc 1 2530 3 is_stmt 1 view .LVU2522
2531:ff.c          **** 		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6968              		.loc 1 2531 3 is_stmt 0 view .LVU2523
 6969 0194 9A76     		strb	r2, [r3, #26]
 6970 0196 039A     		ldr	r2, [sp, #12]
2530:ff.c          **** 		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 6971              		.loc 1 2530 3 view .LVU2524
 6972 0198 83F81890 		strb	r9, [r3, #24]
2530:ff.c          **** 		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 6973              		.loc 1 2530 3 is_stmt 1 view .LVU2525
2531:ff.c          **** 		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6974              		.loc 1 2531 3 view .LVU2526
2531:ff.c          **** 		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 6975              		.loc 1 2531 3 view .LVU2527
 6976 019c DA76     		strb	r2, [r3, #27]
2532:ff.c          **** 		dj.fs->wflag = 1;
 6977              		.loc 1 2532 3 view .LVU2528
 6978 019e 049A     		ldr	r2, [sp, #16]
 6979 01a0 1A75     		strb	r2, [r3, #20]
2532:ff.c          **** 		dj.fs->wflag = 1;
 6980              		.loc 1 2532 3 view .LVU2529
 6981 01a2 059A     		ldr	r2, [sp, #20]
 6982 01a4 5A75     		strb	r2, [r3, #21]
2533:ff.c          **** 		res = sync(dj.fs);
 6983              		.loc 1 2533 3 view .LVU2530
2533:ff.c          **** 		res = sync(dj.fs);
 6984              		.loc 1 2533 16 is_stmt 0 view .LVU2531
 6985 01a6 0123     		movs	r3, #1
 6986              	.LVL743:
2533:ff.c          **** 		res = sync(dj.fs);
 6987              		.loc 1 2533 16 view .LVU2532
 6988 01a8 0371     		strb	r3, [r0, #4]
2534:ff.c          **** 	}
 6989              		.loc 1 2534 3 is_stmt 1 view .LVU2533
2534:ff.c          **** 	}
 6990              		.loc 1 2534 9 is_stmt 0 view .LVU2534
 6991 01aa FFF7FEFF 		bl	sync
 6992              	.LVL744:
 6993 01ae 0646     		mov	r6, r0
 6994              	.LVL745:
2534:ff.c          **** 	}
 6995              		.loc 1 2534 9 view .LVU2535
 6996 01b0 C7E7     		b	.L592
 6997              	.LVL746:
 6998              	.L587:
2484:ff.c          **** 	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[11] & NS_DOT))
 6999              		.loc 1 2484 24 view .LVU2536
 7000 01b2 0826     		movs	r6, #8
 7001 01b4 C5E7     		b	.L592
 7002              	.L588:
2486:ff.c          **** 	if (res != FR_NO_FILE)					/* Any error occured */
 7003              		.loc 1 2486 7 view .LVU2537
 7004 01b6 0626     		movs	r6, #6
 7005 01b8 C3E7     		b	.L592
 7006              	.LVL747:
 7007              	.L589:
2492:ff.c          **** 	if (dclst == 1) res = FR_INT_ERR;
 7008              		.loc 1 2492 22 view .LVU2538
 7009 01ba 0726     		movs	r6, #7
 7010 01bc C1E7     		b	.L592
 7011              	.L590:
2493:ff.c          **** 	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
 7012              		.loc 1 2493 22 view .LVU2539
 7013 01be 0226     		movs	r6, #2
 7014 01c0 BFE7     		b	.L592
 7015              	.L591:
2494:ff.c          **** 	if (res == FR_OK)
 7016              		.loc 1 2494 31 view .LVU2540
 7017 01c2 0126     		movs	r6, #1
 7018 01c4 BDE7     		b	.L592
 7019              		.cfi_endproc
 7020              	.LFE67:
 7022              		.section	.text.f_chmod,"ax",%progbits
 7023              		.align	1
 7024              		.global	f_chmod
 7025              		.syntax unified
 7026              		.thumb
 7027              		.thumb_func
 7028              		.fpu softvfp
 7030              	f_chmod:
 7031              	.LVL748:
 7032              	.LFB68:
2539:ff.c          **** 
2540:ff.c          **** 
2541:ff.c          **** 
2542:ff.c          **** 
2543:ff.c          **** /*-----------------------------------------------------------------------*/
2544:ff.c          **** /* Change File Attribute                                                 */
2545:ff.c          **** /*-----------------------------------------------------------------------*/
2546:ff.c          **** 
2547:ff.c          **** FRESULT f_chmod (
2548:ff.c          **** 	const XCHAR *path,	/* Pointer to the file path */
2549:ff.c          **** 	BYTE value,			/* Attribute bits */
2550:ff.c          **** 	BYTE mask			/* Attribute mask to change */
2551:ff.c          **** )
2552:ff.c          **** {
 7033              		.loc 1 2552 1 is_stmt 1 view -0
 7034              		.cfi_startproc
 7035              		@ args = 0, pretend = 0, frame = 48
 7036              		@ frame_needed = 0, uses_anonymous_args = 0
2553:ff.c          **** 	FRESULT res;
 7037              		.loc 1 2553 2 view .LVU2542
2554:ff.c          **** 	DIR dj;
 7038              		.loc 1 2554 2 view .LVU2543
2555:ff.c          **** 	NAMEBUF(sfn, lfn);
 7039              		.loc 1 2555 2 view .LVU2544
2556:ff.c          **** 	BYTE *dir;
 7040              		.loc 1 2556 2 view .LVU2545
2557:ff.c          **** 
2558:ff.c          **** 
2559:ff.c          **** 	res = auto_mount(&path, &dj.fs, 1);
 7041              		.loc 1 2559 2 view .LVU2546
2552:ff.c          **** 	FRESULT res;
 7042              		.loc 1 2552 1 is_stmt 0 view .LVU2547
 7043 0000 30B5     		push	{r4, r5, lr}
 7044              		.cfi_def_cfa_offset 12
 7045              		.cfi_offset 4, -12
 7046              		.cfi_offset 5, -8
 7047              		.cfi_offset 14, -4
 7048 0002 8DB0     		sub	sp, sp, #52
 7049              		.cfi_def_cfa_offset 64
2552:ff.c          **** 	FRESULT res;
 7050              		.loc 1 2552 1 view .LVU2548
 7051 0004 0D46     		mov	r5, r1
 7052 0006 1446     		mov	r4, r2
 7053 0008 0190     		str	r0, [sp, #4]
 7054              		.loc 1 2559 8 view .LVU2549
 7055 000a 0122     		movs	r2, #1
 7056              	.LVL749:
 7057              		.loc 1 2559 8 view .LVU2550
 7058 000c 05A9     		add	r1, sp, #20
 7059              	.LVL750:
 7060              		.loc 1 2559 8 view .LVU2551
 7061 000e 01A8     		add	r0, sp, #4
 7062              	.LVL751:
 7063              		.loc 1 2559 8 view .LVU2552
 7064 0010 FFF7FEFF 		bl	auto_mount
 7065              	.LVL752:
2560:ff.c          **** 	if (res == FR_OK) {
 7066              		.loc 1 2560 2 is_stmt 1 view .LVU2553
 7067              		.loc 1 2560 5 is_stmt 0 view .LVU2554
 7068 0014 C0B9     		cbnz	r0, .L596
2561:ff.c          **** 		INITBUF(dj, sfn, lfn);
 7069              		.loc 1 2561 3 is_stmt 1 view .LVU2555
 7070 0016 02AB     		add	r3, sp, #8
2562:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the file path */
 7071              		.loc 1 2562 9 is_stmt 0 view .LVU2556
 7072 0018 0199     		ldr	r1, [sp, #4]
 7073 001a 05A8     		add	r0, sp, #20
 7074              	.LVL753:
2561:ff.c          **** 		INITBUF(dj, sfn, lfn);
 7075              		.loc 1 2561 3 view .LVU2557
 7076 001c 0B93     		str	r3, [sp, #44]
 7077              		.loc 1 2562 3 is_stmt 1 view .LVU2558
 7078              		.loc 1 2562 9 is_stmt 0 view .LVU2559
 7079 001e FFF7FEFF 		bl	follow_path
 7080              	.LVL754:
2563:ff.c          **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
 7081              		.loc 1 2563 3 is_stmt 1 view .LVU2560
 7082              		.loc 1 2563 6 is_stmt 0 view .LVU2561
 7083 0022 88B9     		cbnz	r0, .L596
 7084              		.loc 1 2563 42 discriminator 1 view .LVU2562
 7085 0024 0B9B     		ldr	r3, [sp, #44]
 7086              		.loc 1 2563 33 discriminator 1 view .LVU2563
 7087 0026 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 7088 0028 9B06     		lsls	r3, r3, #26
 7089 002a 0FD4     		bmi	.L598
 7090              	.LVL755:
2564:ff.c          **** 			res = FR_INVALID_NAME;
2565:ff.c          **** 		if (res == FR_OK) {
 7091              		.loc 1 2565 3 is_stmt 1 view .LVU2564
2566:ff.c          **** 			dir = dj.dir;
 7092              		.loc 1 2566 4 view .LVU2565
 7093              		.loc 1 2566 8 is_stmt 0 view .LVU2566
 7094 002c 0A98     		ldr	r0, [sp, #40]
 7095              	.LVL756:
2567:ff.c          **** 			if (!dir) {						/* Is it a root directory? */
 7096              		.loc 1 2567 4 is_stmt 1 view .LVU2567
 7097              		.loc 1 2567 7 is_stmt 0 view .LVU2568
 7098 002e 68B1     		cbz	r0, .L598
2568:ff.c          **** 				res = FR_INVALID_NAME;
2569:ff.c          **** 			} else {						/* File or sub directory */
2570:ff.c          **** 				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
 7099              		.loc 1 2570 5 is_stmt 1 view .LVU2569
 7100              	.LVL757:
2571:ff.c          **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 7101              		.loc 1 2571 5 view .LVU2570
 7102              		.loc 1 2571 42 is_stmt 0 view .LVU2571
 7103 0030 C37A     		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 7104              		.loc 1 2571 19 view .LVU2572
 7105 0032 5D40     		eors	r5, r5, r3
 7106 0034 2C40     		ands	r4, r4, r5
 7107              	.LVL758:
 7108              		.loc 1 2571 19 view .LVU2573
 7109 0036 04F02704 		and	r4, r4, #39
 7110 003a 5C40     		eors	r4, r4, r3
2572:ff.c          **** 				dj.fs->wflag = 1;
 7111              		.loc 1 2572 18 view .LVU2574
 7112 003c 0123     		movs	r3, #1
2571:ff.c          **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 7113              		.loc 1 2571 19 view .LVU2575
 7114 003e C472     		strb	r4, [r0, #11]
 7115              		.loc 1 2572 5 is_stmt 1 view .LVU2576
 7116              		.loc 1 2572 7 is_stmt 0 view .LVU2577
 7117 0040 0598     		ldr	r0, [sp, #20]
 7118              	.LVL759:
 7119              		.loc 1 2572 18 view .LVU2578
 7120 0042 0371     		strb	r3, [r0, #4]
2573:ff.c          **** 				res = sync(dj.fs);
 7121              		.loc 1 2573 5 is_stmt 1 view .LVU2579
 7122              		.loc 1 2573 11 is_stmt 0 view .LVU2580
 7123 0044 FFF7FEFF 		bl	sync
 7124              	.LVL760:
 7125              	.L596:
2574:ff.c          **** 			}
2575:ff.c          **** 		}
2576:ff.c          **** 	}
2577:ff.c          **** 
2578:ff.c          **** 	LEAVE_FF(dj.fs, res);
 7126              		.loc 1 2578 2 is_stmt 1 view .LVU2581
2579:ff.c          **** }
 7127              		.loc 1 2579 1 is_stmt 0 view .LVU2582
 7128 0048 0DB0     		add	sp, sp, #52
 7129              		.cfi_remember_state
 7130              		.cfi_def_cfa_offset 12
 7131              		@ sp needed
 7132 004a 30BD     		pop	{r4, r5, pc}
 7133              	.LVL761:
 7134              	.L598:
 7135              		.cfi_restore_state
2564:ff.c          **** 		if (res == FR_OK) {
 7136              		.loc 1 2564 8 view .LVU2583
 7137 004c 0620     		movs	r0, #6
 7138 004e FBE7     		b	.L596
 7139              		.cfi_endproc
 7140              	.LFE68:
 7142              		.section	.text.f_utime,"ax",%progbits
 7143              		.align	1
 7144              		.global	f_utime
 7145              		.syntax unified
 7146              		.thumb
 7147              		.thumb_func
 7148              		.fpu softvfp
 7150              	f_utime:
 7151              	.LVL762:
 7152              	.LFB69:
2580:ff.c          **** 
2581:ff.c          **** 
2582:ff.c          **** 
2583:ff.c          **** 
2584:ff.c          **** /*-----------------------------------------------------------------------*/
2585:ff.c          **** /* Change Timestamp                                                      */
2586:ff.c          **** /*-----------------------------------------------------------------------*/
2587:ff.c          **** 
2588:ff.c          **** FRESULT f_utime (
2589:ff.c          **** 	const XCHAR *path,	/* Pointer to the file/directory name */
2590:ff.c          **** 	const FILINFO *fno	/* Pointer to the timestamp to be set */
2591:ff.c          **** )
2592:ff.c          **** {
 7153              		.loc 1 2592 1 is_stmt 1 view -0
 7154              		.cfi_startproc
 7155              		@ args = 0, pretend = 0, frame = 48
 7156              		@ frame_needed = 0, uses_anonymous_args = 0
2593:ff.c          **** 	FRESULT res;
 7157              		.loc 1 2593 2 view .LVU2585
2594:ff.c          **** 	DIR dj;
 7158              		.loc 1 2594 2 view .LVU2586
2595:ff.c          **** 	NAMEBUF(sfn, lfn);
 7159              		.loc 1 2595 2 view .LVU2587
2596:ff.c          **** 	BYTE *dir;
 7160              		.loc 1 2596 2 view .LVU2588
2597:ff.c          **** 
2598:ff.c          **** 
2599:ff.c          **** 	res = auto_mount(&path, &dj.fs, 1);
 7161              		.loc 1 2599 2 view .LVU2589
2592:ff.c          **** 	FRESULT res;
 7162              		.loc 1 2592 1 is_stmt 0 view .LVU2590
 7163 0000 10B5     		push	{r4, lr}
 7164              		.cfi_def_cfa_offset 8
 7165              		.cfi_offset 4, -8
 7166              		.cfi_offset 14, -4
 7167 0002 8CB0     		sub	sp, sp, #48
 7168              		.cfi_def_cfa_offset 56
2592:ff.c          **** 	FRESULT res;
 7169              		.loc 1 2592 1 view .LVU2591
 7170 0004 0C46     		mov	r4, r1
 7171 0006 0190     		str	r0, [sp, #4]
 7172              		.loc 1 2599 8 view .LVU2592
 7173 0008 0122     		movs	r2, #1
 7174 000a 05A9     		add	r1, sp, #20
 7175              	.LVL763:
 7176              		.loc 1 2599 8 view .LVU2593
 7177 000c 01A8     		add	r0, sp, #4
 7178              	.LVL764:
 7179              		.loc 1 2599 8 view .LVU2594
 7180 000e FFF7FEFF 		bl	auto_mount
 7181              	.LVL765:
2600:ff.c          **** 	if (res == FR_OK) {
 7182              		.loc 1 2600 2 is_stmt 1 view .LVU2595
 7183              		.loc 1 2600 5 is_stmt 0 view .LVU2596
 7184 0012 D8B9     		cbnz	r0, .L600
2601:ff.c          **** 		INITBUF(dj, sfn, lfn);
 7185              		.loc 1 2601 3 is_stmt 1 view .LVU2597
 7186 0014 02AB     		add	r3, sp, #8
2602:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
 7187              		.loc 1 2602 9 is_stmt 0 view .LVU2598
 7188 0016 0199     		ldr	r1, [sp, #4]
 7189 0018 05A8     		add	r0, sp, #20
 7190              	.LVL766:
2601:ff.c          **** 		INITBUF(dj, sfn, lfn);
 7191              		.loc 1 2601 3 view .LVU2599
 7192 001a 0B93     		str	r3, [sp, #44]
 7193              		.loc 1 2602 3 is_stmt 1 view .LVU2600
 7194              		.loc 1 2602 9 is_stmt 0 view .LVU2601
 7195 001c FFF7FEFF 		bl	follow_path
 7196              	.LVL767:
2603:ff.c          **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
 7197              		.loc 1 2603 3 is_stmt 1 view .LVU2602
 7198              		.loc 1 2603 6 is_stmt 0 view .LVU2603
 7199 0020 A0B9     		cbnz	r0, .L600
 7200              		.loc 1 2603 42 discriminator 1 view .LVU2604
 7201 0022 0B9B     		ldr	r3, [sp, #44]
 7202              		.loc 1 2603 33 discriminator 1 view .LVU2605
 7203 0024 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 7204 0026 9B06     		lsls	r3, r3, #26
 7205 0028 12D4     		bmi	.L602
 7206              	.LVL768:
2604:ff.c          **** 			res = FR_INVALID_NAME;
2605:ff.c          **** 		if (res == FR_OK) {
 7207              		.loc 1 2605 3 is_stmt 1 view .LVU2606
2606:ff.c          **** 			dir = dj.dir;
 7208              		.loc 1 2606 4 view .LVU2607
 7209              		.loc 1 2606 8 is_stmt 0 view .LVU2608
 7210 002a 0A9B     		ldr	r3, [sp, #40]
 7211              	.LVL769:
2607:ff.c          **** 			if (!dir) {				/* Root directory */
 7212              		.loc 1 2607 4 is_stmt 1 view .LVU2609
 7213              		.loc 1 2607 7 is_stmt 0 view .LVU2610
 7214 002c 83B1     		cbz	r3, .L602
2608:ff.c          **** 				res = FR_INVALID_NAME;
2609:ff.c          **** 			} else {				/* File or sub-directory */
2610:ff.c          **** 				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 7215              		.loc 1 2610 5 is_stmt 1 view .LVU2611
 7216 002e E288     		ldrh	r2, [r4, #6]
2611:ff.c          **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
2612:ff.c          **** 				dj.fs->wflag = 1;
 7217              		.loc 1 2612 7 is_stmt 0 view .LVU2612
 7218 0030 0598     		ldr	r0, [sp, #20]
2610:ff.c          **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 7219              		.loc 1 2610 5 view .LVU2613
 7220 0032 9A75     		strb	r2, [r3, #22]
2610:ff.c          **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 7221              		.loc 1 2610 5 is_stmt 1 view .LVU2614
 7222 0034 E288     		ldrh	r2, [r4, #6]
 7223 0036 120A     		lsrs	r2, r2, #8
 7224 0038 DA75     		strb	r2, [r3, #23]
2611:ff.c          **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 7225              		.loc 1 2611 5 view .LVU2615
 7226 003a A288     		ldrh	r2, [r4, #4]
 7227 003c 1A76     		strb	r2, [r3, #24]
2611:ff.c          **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 7228              		.loc 1 2611 5 view .LVU2616
 7229 003e A288     		ldrh	r2, [r4, #4]
 7230 0040 120A     		lsrs	r2, r2, #8
 7231 0042 5A76     		strb	r2, [r3, #25]
 7232              		.loc 1 2612 5 view .LVU2617
 7233              		.loc 1 2612 18 is_stmt 0 view .LVU2618
 7234 0044 0123     		movs	r3, #1
 7235              	.LVL770:
 7236              		.loc 1 2612 18 view .LVU2619
 7237 0046 0371     		strb	r3, [r0, #4]
2613:ff.c          **** 				res = sync(dj.fs);
 7238              		.loc 1 2613 5 is_stmt 1 view .LVU2620
 7239              		.loc 1 2613 11 is_stmt 0 view .LVU2621
 7240 0048 FFF7FEFF 		bl	sync
 7241              	.LVL771:
 7242              	.L600:
2614:ff.c          **** 			}
2615:ff.c          **** 		}
2616:ff.c          **** 	}
2617:ff.c          **** 
2618:ff.c          **** 	LEAVE_FF(dj.fs, res);
 7243              		.loc 1 2618 2 is_stmt 1 view .LVU2622
2619:ff.c          **** }
 7244              		.loc 1 2619 1 is_stmt 0 view .LVU2623
 7245 004c 0CB0     		add	sp, sp, #48
 7246              		.cfi_remember_state
 7247              		.cfi_def_cfa_offset 8
 7248              		@ sp needed
 7249 004e 10BD     		pop	{r4, pc}
 7250              	.LVL772:
 7251              	.L602:
 7252              		.cfi_restore_state
2604:ff.c          **** 		if (res == FR_OK) {
 7253              		.loc 1 2604 8 view .LVU2624
 7254 0050 0620     		movs	r0, #6
 7255 0052 FBE7     		b	.L600
 7256              		.cfi_endproc
 7257              	.LFE69:
 7259              		.section	.text.f_rename,"ax",%progbits
 7260              		.align	1
 7261              		.global	f_rename
 7262              		.syntax unified
 7263              		.thumb
 7264              		.thumb_func
 7265              		.fpu softvfp
 7267              	f_rename:
 7268              	.LVL773:
 7269              	.LFB70:
2620:ff.c          **** 
2621:ff.c          **** 
2622:ff.c          **** 
2623:ff.c          **** 
2624:ff.c          **** /*-----------------------------------------------------------------------*/
2625:ff.c          **** /* Rename File/Directory                                                 */
2626:ff.c          **** /*-----------------------------------------------------------------------*/
2627:ff.c          **** 
2628:ff.c          **** FRESULT f_rename (
2629:ff.c          **** 	const XCHAR *path_old,	/* Pointer to the old name */
2630:ff.c          **** 	const XCHAR *path_new	/* Pointer to the new name */
2631:ff.c          **** )
2632:ff.c          **** {
 7270              		.loc 1 2632 1 is_stmt 1 view -0
 7271              		.cfi_startproc
 7272              		@ args = 0, pretend = 0, frame = 104
 7273              		@ frame_needed = 0, uses_anonymous_args = 0
2633:ff.c          **** 	FRESULT res;
 7274              		.loc 1 2633 2 view .LVU2626
2634:ff.c          **** 	DIR dj_old, dj_new;
 7275              		.loc 1 2634 2 view .LVU2627
2635:ff.c          **** 	NAMEBUF(sfn, lfn);
 7276              		.loc 1 2635 2 view .LVU2628
2636:ff.c          **** 	BYTE buf[21], *dir;
 7277              		.loc 1 2636 2 view .LVU2629
2637:ff.c          **** 	DWORD dw;
 7278              		.loc 1 2637 2 view .LVU2630
2638:ff.c          **** 
2639:ff.c          **** 
2640:ff.c          **** 	INITBUF(dj_old, sfn, lfn);
 7279              		.loc 1 2640 2 view .LVU2631
2632:ff.c          **** 	FRESULT res;
 7280              		.loc 1 2632 1 is_stmt 0 view .LVU2632
 7281 0000 10B5     		push	{r4, lr}
 7282              		.cfi_def_cfa_offset 8
 7283              		.cfi_offset 4, -8
 7284              		.cfi_offset 14, -4
 7285 0002 9AB0     		sub	sp, sp, #104
 7286              		.cfi_def_cfa_offset 112
2632:ff.c          **** 	FRESULT res;
 7287              		.loc 1 2632 1 view .LVU2633
 7288 0004 0C46     		mov	r4, r1
 7289 0006 0190     		str	r0, [sp, #4]
 7290              		.loc 1 2640 2 view .LVU2634
 7291 0008 03AB     		add	r3, sp, #12
2641:ff.c          **** 	res = auto_mount(&path_old, &dj_old.fs, 1);
 7292              		.loc 1 2641 8 view .LVU2635
 7293 000a 0122     		movs	r2, #1
 7294 000c 0CA9     		add	r1, sp, #48
 7295              	.LVL774:
 7296              		.loc 1 2641 8 view .LVU2636
 7297 000e 01A8     		add	r0, sp, #4
 7298              	.LVL775:
2640:ff.c          **** 	res = auto_mount(&path_old, &dj_old.fs, 1);
 7299              		.loc 1 2640 2 view .LVU2637
 7300 0010 1293     		str	r3, [sp, #72]
 7301              		.loc 1 2641 2 is_stmt 1 view .LVU2638
 7302              		.loc 1 2641 8 is_stmt 0 view .LVU2639
 7303 0012 FFF7FEFF 		bl	auto_mount
 7304              	.LVL776:
2642:ff.c          **** 	if (res == FR_OK) {
 7305              		.loc 1 2642 2 is_stmt 1 view .LVU2640
 7306              		.loc 1 2642 5 is_stmt 0 view .LVU2641
 7307 0016 0028     		cmp	r0, #0
 7308 0018 6DD1     		bne	.L604
2643:ff.c          **** 		dj_new.fs = dj_old.fs;
 7309              		.loc 1 2643 3 is_stmt 1 view .LVU2642
 7310              		.loc 1 2643 13 is_stmt 0 view .LVU2643
 7311 001a 0C9B     		ldr	r3, [sp, #48]
2644:ff.c          **** 		res = follow_path(&dj_old, path_old);	/* Check old object */
 7312              		.loc 1 2644 9 view .LVU2644
 7313 001c 0199     		ldr	r1, [sp, #4]
 7314 001e 0CA8     		add	r0, sp, #48
 7315              	.LVL777:
2643:ff.c          **** 		dj_new.fs = dj_old.fs;
 7316              		.loc 1 2643 13 view .LVU2645
 7317 0020 1393     		str	r3, [sp, #76]
 7318              		.loc 1 2644 3 is_stmt 1 view .LVU2646
 7319              		.loc 1 2644 9 is_stmt 0 view .LVU2647
 7320 0022 FFF7FEFF 		bl	follow_path
 7321              	.LVL778:
2645:ff.c          **** 		if (_FS_RPATH && res == FR_OK && (dj_old.fn[11] & NS_DOT))
 7322              		.loc 1 2645 3 is_stmt 1 view .LVU2648
 7323              		.loc 1 2645 6 is_stmt 0 view .LVU2649
 7324 0026 0028     		cmp	r0, #0
 7325 0028 65D1     		bne	.L604
 7326              		.loc 1 2645 46 discriminator 1 view .LVU2650
 7327 002a 129B     		ldr	r3, [sp, #72]
 7328              		.loc 1 2645 33 discriminator 1 view .LVU2651
 7329 002c DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 7330 002e 9A06     		lsls	r2, r3, #26
 7331 0030 63D4     		bmi	.L609
 7332              	.LVL779:
2646:ff.c          **** 			res = FR_INVALID_NAME;
2647:ff.c          **** 	}
2648:ff.c          **** 	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
 7333              		.loc 1 2648 2 is_stmt 1 view .LVU2652
2649:ff.c          **** 
2650:ff.c          **** 	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
 7334              		.loc 1 2650 2 view .LVU2653
 7335              		.loc 1 2650 13 is_stmt 0 view .LVU2654
 7336 0032 1199     		ldr	r1, [sp, #68]
 7337              		.loc 1 2650 5 view .LVU2655
 7338 0034 0029     		cmp	r1, #0
 7339 0036 62D0     		beq	.L610
2651:ff.c          **** 	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
 7340              		.loc 1 2651 2 is_stmt 1 view .LVU2656
 7341 0038 1522     		movs	r2, #21
 7342 003a 0B31     		adds	r1, r1, #11
 7343 003c 06A8     		add	r0, sp, #24
 7344 003e FFF7FEFF 		bl	mem_cpy
 7345              	.LVL780:
2652:ff.c          **** 
2653:ff.c          **** 	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
 7346              		.loc 1 2653 2 view .LVU2657
 7347 0042 0CA9     		add	r1, sp, #48
 7348 0044 13A8     		add	r0, sp, #76
 7349 0046 1C22     		movs	r2, #28
 7350 0048 FFF7FEFF 		bl	mem_cpy
 7351              	.LVL781:
2654:ff.c          **** 	res = follow_path(&dj_new, path_new);		/* Check new object */
 7352              		.loc 1 2654 2 view .LVU2658
 7353              		.loc 1 2654 8 is_stmt 0 view .LVU2659
 7354 004c 2146     		mov	r1, r4
 7355 004e 13A8     		add	r0, sp, #76
 7356 0050 FFF7FEFF 		bl	follow_path
 7357              	.LVL782:
2655:ff.c          **** 	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
 7358              		.loc 1 2655 2 is_stmt 1 view .LVU2660
 7359              		.loc 1 2655 5 is_stmt 0 view .LVU2661
 7360 0054 0028     		cmp	r0, #0
 7361 0056 54D0     		beq	.L611
2656:ff.c          **** 	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
 7362              		.loc 1 2656 2 is_stmt 1 view .LVU2662
 7363              		.loc 1 2656 5 is_stmt 0 view .LVU2663
 7364 0058 0428     		cmp	r0, #4
 7365 005a 4CD1     		bne	.L604
2657:ff.c          **** 		res = dir_register(&dj_new);			/* Register the new object */
 7366              		.loc 1 2657 3 is_stmt 1 view .LVU2664
 7367              		.loc 1 2657 9 is_stmt 0 view .LVU2665
 7368 005c 13A8     		add	r0, sp, #76
 7369              	.LVL783:
 7370              		.loc 1 2657 9 view .LVU2666
 7371 005e FFF7FEFF 		bl	dir_register
 7372              	.LVL784:
2658:ff.c          **** 		if (res == FR_OK) {
 7373              		.loc 1 2658 3 is_stmt 1 view .LVU2667
 7374              		.loc 1 2658 6 is_stmt 0 view .LVU2668
 7375 0062 0028     		cmp	r0, #0
 7376 0064 47D1     		bne	.L604
2659:ff.c          **** 			dir = dj_new.dir;					/* Copy object information into new entry */
 7377              		.loc 1 2659 4 is_stmt 1 view .LVU2669
 7378              		.loc 1 2659 8 is_stmt 0 view .LVU2670
 7379 0066 189C     		ldr	r4, [sp, #96]
 7380              	.LVL785:
2660:ff.c          **** 			mem_cpy(dir+13, buf+2, 19);
 7381              		.loc 1 2660 4 is_stmt 1 view .LVU2671
 7382 0068 1322     		movs	r2, #19
 7383 006a 0DF11A01 		add	r1, sp, #26
 7384 006e 04F10D00 		add	r0, r4, #13
 7385              	.LVL786:
 7386              		.loc 1 2660 4 is_stmt 0 view .LVU2672
 7387 0072 FFF7FEFF 		bl	mem_cpy
 7388              	.LVL787:
2661:ff.c          **** 			dir[DIR_Attr] = buf[0] | AM_ARC;
 7389              		.loc 1 2661 4 is_stmt 1 view .LVU2673
2662:ff.c          **** 			dj_old.fs->wflag = 1;
 7390              		.loc 1 2662 21 is_stmt 0 view .LVU2674
 7391 0076 0122     		movs	r2, #1
2661:ff.c          **** 			dir[DIR_Attr] = buf[0] | AM_ARC;
 7392              		.loc 1 2661 18 view .LVU2675
 7393 0078 9DF81830 		ldrb	r3, [sp, #24]	@ zero_extendqisi2
 7394 007c 43F02003 		orr	r3, r3, #32
 7395 0080 E372     		strb	r3, [r4, #11]
 7396              		.loc 1 2662 4 is_stmt 1 view .LVU2676
 7397              		.loc 1 2662 21 is_stmt 0 view .LVU2677
 7398 0082 0C9B     		ldr	r3, [sp, #48]
 7399 0084 1A71     		strb	r2, [r3, #4]
2663:ff.c          **** 			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
 7400              		.loc 1 2663 4 is_stmt 1 view .LVU2678
 7401              		.loc 1 2663 7 is_stmt 0 view .LVU2679
 7402 0086 E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 7403 0088 DB06     		lsls	r3, r3, #27
 7404 008a 2DD5     		bpl	.L606
2664:ff.c          **** 				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
 7405              		.loc 1 2664 5 is_stmt 1 view .LVU2680
 7406              		.loc 1 2664 39 is_stmt 0 view .LVU2681
 7407 008c 637D     		ldrb	r3, [r4, #21]	@ zero_extendqisi2
 7408 008e 217D     		ldrb	r1, [r4, #20]	@ zero_extendqisi2
 7409              		.loc 1 2664 68 view .LVU2682
 7410 0090 E07E     		ldrb	r0, [r4, #27]	@ zero_extendqisi2
 7411              		.loc 1 2664 39 view .LVU2683
 7412 0092 41EA0321 		orr	r1, r1, r3, lsl #8
 7413              		.loc 1 2664 68 view .LVU2684
 7414 0096 A37E     		ldrb	r3, [r4, #26]	@ zero_extendqisi2
 7415              		.loc 1 2664 10 view .LVU2685
 7416 0098 139A     		ldr	r2, [sp, #76]
 7417              		.loc 1 2664 68 view .LVU2686
 7418 009a 43EA0023 		orr	r3, r3, r0, lsl #8
 7419              		.loc 1 2664 10 view .LVU2687
 7420 009e 1943     		orrs	r1, r1, r3
 7421 00a0 1046     		mov	r0, r2
 7422 00a2 FFF7FEFF 		bl	clust2sect
 7423              	.LVL788:
2665:ff.c          **** 				if (!dw) {
 7424              		.loc 1 2665 5 is_stmt 1 view .LVU2688
 7425              		.loc 1 2665 8 is_stmt 0 view .LVU2689
 7426 00a6 0146     		mov	r1, r0
 7427 00a8 68B3     		cbz	r0, .L612
2666:ff.c          **** 					res = FR_INT_ERR;
2667:ff.c          **** 				} else {
2668:ff.c          **** 					res = move_window(dj_new.fs, dw);
 7428              		.loc 1 2668 6 is_stmt 1 view .LVU2690
 7429              		.loc 1 2668 12 is_stmt 0 view .LVU2691
 7430 00aa 1046     		mov	r0, r2
 7431              	.LVL789:
 7432              		.loc 1 2668 12 view .LVU2692
 7433 00ac FFF7FEFF 		bl	move_window
 7434              	.LVL790:
2669:ff.c          **** 					dir = dj_new.fs->win+32;
 7435              		.loc 1 2669 6 is_stmt 1 view .LVU2693
2670:ff.c          **** 					if (res == FR_OK && dir[1] == '.') {
 7436              		.loc 1 2670 6 view .LVU2694
 7437              		.loc 1 2670 9 is_stmt 0 view .LVU2695
 7438 00b0 08BB     		cbnz	r0, .L604
2669:ff.c          **** 					dir = dj_new.fs->win+32;
 7439              		.loc 1 2669 18 discriminator 1 view .LVU2696
 7440 00b2 139A     		ldr	r2, [sp, #76]
 7441              		.loc 1 2670 23 discriminator 1 view .LVU2697
 7442 00b4 92F85530 		ldrb	r3, [r2, #85]	@ zero_extendqisi2
 7443 00b8 2E2B     		cmp	r3, #46
 7444 00ba 15D1     		bne	.L606
2671:ff.c          **** 						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.scl
 7445              		.loc 1 2671 7 is_stmt 1 view .LVU2698
 7446              		.loc 1 2671 88 is_stmt 0 view .LVU2699
 7447 00bc 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 7448 00be 159B     		ldr	r3, [sp, #84]
 7449 00c0 0329     		cmp	r1, #3
 7450 00c2 03D1     		bne	.L608
 7451              		.loc 1 2671 44 discriminator 2 view .LVU2700
 7452 00c4 916A     		ldr	r1, [r2, #40]
 7453              		.loc 1 2671 88 discriminator 2 view .LVU2701
 7454 00c6 9942     		cmp	r1, r3
 7455 00c8 08BF     		it	eq
 7456 00ca 0023     		moveq	r3, #0
 7457              	.L608:
 7458              	.LVL791:
2672:ff.c          **** 						ST_WORD(dir+DIR_FstClusLO, dw);
 7459              		.loc 1 2672 7 is_stmt 1 discriminator 6 view .LVU2702
 7460 00cc C3F30721 		ubfx	r1, r3, #8, #8
 7461 00d0 82F86E30 		strb	r3, [r2, #110]
 7462              		.loc 1 2672 7 discriminator 6 view .LVU2703
2673:ff.c          **** 						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
 7463              		.loc 1 2673 7 is_stmt 0 discriminator 6 view .LVU2704
 7464 00d4 1B0C     		lsrs	r3, r3, #16
 7465              	.LVL792:
 7466              		.loc 1 2673 7 discriminator 6 view .LVU2705
 7467 00d6 82F86830 		strb	r3, [r2, #104]
 7468 00da 1B0A     		lsrs	r3, r3, #8
 7469 00dc 82F86930 		strb	r3, [r2, #105]
2674:ff.c          **** 						dj_new.fs->wflag = 1;
 7470              		.loc 1 2674 24 discriminator 6 view .LVU2706
 7471 00e0 0123     		movs	r3, #1
2672:ff.c          **** 						ST_WORD(dir+DIR_FstClusLO, dw);
 7472              		.loc 1 2672 7 discriminator 6 view .LVU2707
 7473 00e2 82F86F10 		strb	r1, [r2, #111]
2673:ff.c          **** 						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
 7474              		.loc 1 2673 7 is_stmt 1 discriminator 6 view .LVU2708
2673:ff.c          **** 						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
 7475              		.loc 1 2673 7 discriminator 6 view .LVU2709
 7476              		.loc 1 2674 7 discriminator 6 view .LVU2710
 7477              		.loc 1 2674 24 is_stmt 0 discriminator 6 view .LVU2711
 7478 00e6 1371     		strb	r3, [r2, #4]
 7479              	.LVL793:
2675:ff.c          **** 					}
2676:ff.c          **** 				}
2677:ff.c          **** 			}
2678:ff.c          **** 			if (res == FR_OK) {
 7480              		.loc 1 2678 4 is_stmt 1 discriminator 6 view .LVU2712
 7481              	.L606:
2679:ff.c          **** 				res = dir_remove(&dj_old);			/* Remove old entry */
 7482              		.loc 1 2679 5 view .LVU2713
 7483              		.loc 1 2679 11 is_stmt 0 view .LVU2714
 7484 00e8 0CA8     		add	r0, sp, #48
 7485 00ea FFF7FEFF 		bl	dir_remove
 7486              	.LVL794:
2680:ff.c          **** 				if (res == FR_OK)
 7487              		.loc 1 2680 5 is_stmt 1 view .LVU2715
 7488              		.loc 1 2680 8 is_stmt 0 view .LVU2716
 7489 00ee 10B9     		cbnz	r0, .L604
2681:ff.c          **** 					res = sync(dj_old.fs);
 7490              		.loc 1 2681 6 is_stmt 1 view .LVU2717
 7491              		.loc 1 2681 12 is_stmt 0 view .LVU2718
 7492 00f0 0C98     		ldr	r0, [sp, #48]
 7493              	.LVL795:
 7494              		.loc 1 2681 12 view .LVU2719
 7495 00f2 FFF7FEFF 		bl	sync
 7496              	.LVL796:
 7497              	.L604:
2682:ff.c          **** 			}
2683:ff.c          **** 		}
2684:ff.c          **** 	}
2685:ff.c          **** 
2686:ff.c          **** 	LEAVE_FF(dj_old.fs, res);
2687:ff.c          **** }
 7498              		.loc 1 2687 1 view .LVU2720
 7499 00f6 1AB0     		add	sp, sp, #104
 7500              		.cfi_remember_state
 7501              		.cfi_def_cfa_offset 8
 7502              		@ sp needed
 7503 00f8 10BD     		pop	{r4, pc}
 7504              	.LVL797:
 7505              	.L609:
 7506              		.cfi_restore_state
2646:ff.c          **** 	}
 7507              		.loc 1 2646 8 view .LVU2721
 7508 00fa 0620     		movs	r0, #6
 7509              	.LVL798:
2646:ff.c          **** 	}
 7510              		.loc 1 2646 8 view .LVU2722
 7511 00fc FBE7     		b	.L604
 7512              	.LVL799:
 7513              	.L610:
2650:ff.c          **** 	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
 7514              		.loc 1 2650 19 view .LVU2723
 7515 00fe 0420     		movs	r0, #4
 7516 0100 F9E7     		b	.L604
 7517              	.LVL800:
 7518              	.L611:
2655:ff.c          **** 	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
 7519              		.loc 1 2655 24 view .LVU2724
 7520 0102 0820     		movs	r0, #8
 7521              	.LVL801:
2655:ff.c          **** 	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
 7522              		.loc 1 2655 24 view .LVU2725
 7523 0104 F7E7     		b	.L604
 7524              	.LVL802:
 7525              	.L612:
2666:ff.c          **** 				} else {
 7526              		.loc 1 2666 10 view .LVU2726
 7527 0106 0220     		movs	r0, #2
 7528              	.LVL803:
2666:ff.c          **** 				} else {
 7529              		.loc 1 2666 10 view .LVU2727
 7530 0108 F5E7     		b	.L604
 7531              		.cfi_endproc
 7532              	.LFE70:
 7534              		.section	.text.f_gets,"ax",%progbits
 7535              		.align	1
 7536              		.global	f_gets
 7537              		.syntax unified
 7538              		.thumb
 7539              		.thumb_func
 7540              		.fpu softvfp
 7542              	f_gets:
 7543              	.LVL804:
 7544              	.LFB71:
2688:ff.c          **** 
2689:ff.c          **** #endif /* !_FS_READONLY */
2690:ff.c          **** #endif /* _FS_MINIMIZE == 0 */
2691:ff.c          **** #endif /* _FS_MINIMIZE <= 1 */
2692:ff.c          **** #endif /* _FS_MINIMIZE <= 2 */
2693:ff.c          **** 
2694:ff.c          **** 
2695:ff.c          **** 
2696:ff.c          **** /*-----------------------------------------------------------------------*/
2697:ff.c          **** /* Forward data to the stream directly (Available on only _FS_TINY cfg)  */
2698:ff.c          **** /*-----------------------------------------------------------------------*/
2699:ff.c          **** #if _USE_FORWARD && _FS_TINY
2700:ff.c          **** 
2701:ff.c          **** FRESULT f_forward (
2702:ff.c          **** 	FIL *fp, 						/* Pointer to the file object */
2703:ff.c          **** 	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
2704:ff.c          **** 	UINT btr,						/* Number of bytes to forward */
2705:ff.c          **** 	UINT *bf						/* Pointer to number of bytes forwarded */
2706:ff.c          **** )
2707:ff.c          **** {
2708:ff.c          **** 	FRESULT res;
2709:ff.c          **** 	DWORD remain, clst, sect;
2710:ff.c          **** 	UINT rcnt;
2711:ff.c          **** 
2712:ff.c          **** 
2713:ff.c          **** 	*bf = 0;
2714:ff.c          **** 
2715:ff.c          **** 	res = validate(fp->fs, fp->id);					/* Check validity of the object */
2716:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2717:ff.c          **** 	if (fp->flag & FA__ERROR)						/* Check error flag */
2718:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2719:ff.c          **** 	if (!(fp->flag & FA_READ))						/* Check access mode */
2720:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
2721:ff.c          **** 
2722:ff.c          **** 	remain = fp->fsize - fp->fptr;
2723:ff.c          **** 	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
2724:ff.c          **** 
2725:ff.c          **** 	for ( ;  btr && (*func)(NULL, 0);				/* Repeat until all data transferred or stream becomes busy *
2726:ff.c          **** 		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
2727:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
2728:ff.c          **** 			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
2729:ff.c          **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
2730:ff.c          **** 					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
2731:ff.c          **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
2732:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2733:ff.c          **** 				fp->curr_clust = clst;				/* Update current cluster */
2734:ff.c          **** 				fp->csect = 0;						/* Reset sector address in the cluster */
2735:ff.c          **** 			}
2736:ff.c          **** 			fp->csect++;							/* Next sector address in the cluster */
2737:ff.c          **** 		}
2738:ff.c          **** 		sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current data sector */
2739:ff.c          **** 		if (!sect) ABORT(fp->fs, FR_INT_ERR);
2740:ff.c          **** 		sect += fp->csect - 1;
2741:ff.c          **** 		if (move_window(fp->fs, sect))				/* Move sector window */
2742:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
2743:ff.c          **** 		fp->dsect = sect;
2744:ff.c          **** 		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
2745:ff.c          **** 		if (rcnt > btr) rcnt = btr;
2746:ff.c          **** 		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
2747:ff.c          **** 		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
2748:ff.c          **** 	}
2749:ff.c          **** 
2750:ff.c          **** 	LEAVE_FF(fp->fs, FR_OK);
2751:ff.c          **** }
2752:ff.c          **** #endif /* _USE_FORWARD */
2753:ff.c          **** 
2754:ff.c          **** 
2755:ff.c          **** 
2756:ff.c          **** #if _USE_MKFS && !_FS_READONLY
2757:ff.c          **** /*-----------------------------------------------------------------------*/
2758:ff.c          **** /* Create File System on the Drive                                       */
2759:ff.c          **** /*-----------------------------------------------------------------------*/
2760:ff.c          **** #define N_ROOTDIR	512			/* Multiple of 32 and <= 2048 */
2761:ff.c          **** #define N_FATS		1			/* 1 or 2 */
2762:ff.c          **** #define MAX_SECTOR	131072000UL	/* Maximum partition size */
2763:ff.c          **** #define MIN_SECTOR	2000UL		/* Minimum partition size */
2764:ff.c          **** 
2765:ff.c          **** 
2766:ff.c          **** FRESULT f_mkfs (
2767:ff.c          **** 	BYTE drv,			/* Logical drive number */
2768:ff.c          **** 	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
2769:ff.c          **** 	WORD allocsize		/* Allocation unit size [bytes] */
2770:ff.c          **** )
2771:ff.c          **** {
2772:ff.c          **** 	static const DWORD sstbl[] = { 2048000, 1024000, 512000, 256000, 128000, 64000, 32000, 16000, 8000
2773:ff.c          **** 	static const WORD cstbl[] =  {   32768,   16384,   8192,   4096,   2048, 16384,  8192,  4096, 2048
2774:ff.c          **** 	BYTE fmt, m, *tbl;
2775:ff.c          **** 	DWORD b_part, b_fat, b_dir, b_data;		/* Area offset (LBA) */
2776:ff.c          **** 	DWORD n_part, n_rsv, n_fat, n_dir;		/* Area size */
2777:ff.c          **** 	DWORD n_clst, d, n;
2778:ff.c          **** 	WORD as;
2779:ff.c          **** 	FATFS *fs;
2780:ff.c          **** 	DSTATUS stat;
2781:ff.c          **** 
2782:ff.c          **** 
2783:ff.c          **** 	/* Check validity of the parameters */
2784:ff.c          **** 	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
2785:ff.c          **** 	if (partition >= 2) return FR_MKFS_ABORTED;
2786:ff.c          **** 
2787:ff.c          **** 	/* Check mounted drive and clear work area */
2788:ff.c          **** 	fs = FatFs[drv];
2789:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;
2790:ff.c          **** 	fs->fs_type = 0;
2791:ff.c          **** 	drv = LD2PD(drv);
2792:ff.c          **** 
2793:ff.c          **** 	/* Get disk statics */
2794:ff.c          **** 	stat = disk_initialize(drv);
2795:ff.c          **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
2796:ff.c          **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
2797:ff.c          **** #if _MAX_SS != 512						/* Get disk sector size */
2798:ff.c          **** 	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
2799:ff.c          **** 		|| SS(fs) > _MAX_SS)
2800:ff.c          **** 		return FR_MKFS_ABORTED;
2801:ff.c          **** #endif
2802:ff.c          **** 	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
2803:ff.c          **** 		return FR_MKFS_ABORTED;
2804:ff.c          **** 	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
2805:ff.c          **** 	b_part = (!partition) ? 63 : 0;		/* Boot sector */
2806:ff.c          **** 	n_part -= b_part;
2807:ff.c          **** 	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit s
2808:ff.c          **** 	if (d != allocsize) allocsize = 0;
2809:ff.c          **** 	if (!allocsize) {					/* Auto selection of cluster size */
2810:ff.c          **** 		d = n_part;
2811:ff.c          **** 		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
2812:ff.c          **** 		for (n = 0; d < sstbl[n]; n++) ;
2813:ff.c          **** 		allocsize = cstbl[n];
2814:ff.c          **** 	}
2815:ff.c          **** 	if (allocsize < SS(fs)) allocsize = SS(fs);
2816:ff.c          **** 
2817:ff.c          **** 	allocsize /= SS(fs);		/* Number of sectors per cluster */
2818:ff.c          **** 
2819:ff.c          **** 	/* Pre-compute number of clusters and FAT type */
2820:ff.c          **** 	n_clst = n_part / allocsize;
2821:ff.c          **** 	fmt = FS_FAT12;
2822:ff.c          **** 	if (n_clst >= 0xFF5) fmt = FS_FAT16;
2823:ff.c          **** 	if (n_clst >= 0xFFF5) fmt = FS_FAT32;
2824:ff.c          **** 
2825:ff.c          **** 	/* Determine offset and size of FAT structure */
2826:ff.c          **** 	switch (fmt) {
2827:ff.c          **** 	case FS_FAT12:
2828:ff.c          **** 		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
2829:ff.c          **** 		n_rsv = 1 + partition;
2830:ff.c          **** 		n_dir = N_ROOTDIR * 32 / SS(fs);
2831:ff.c          **** 		break;
2832:ff.c          **** 	case FS_FAT16:
2833:ff.c          **** 		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
2834:ff.c          **** 		n_rsv = 1 + partition;
2835:ff.c          **** 		n_dir = N_ROOTDIR * 32 / SS(fs);
2836:ff.c          **** 		break;
2837:ff.c          **** 	default:
2838:ff.c          **** 		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
2839:ff.c          **** 		n_rsv = 33 - partition;
2840:ff.c          **** 		n_dir = 0;
2841:ff.c          **** 	}
2842:ff.c          **** 	b_fat = b_part + n_rsv;			/* FATs start sector */
2843:ff.c          **** 	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
2844:ff.c          **** 	b_data = b_dir + n_dir;			/* Data start sector */
2845:ff.c          **** 
2846:ff.c          **** 	/* Align data start sector to erase block boundary (for flash memory media) */
2847:ff.c          **** 	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
2848:ff.c          **** 	n = (b_data + n - 1) & ~(n - 1);
2849:ff.c          **** 	n_fat += (n - b_data) / N_FATS;
2850:ff.c          **** 	/* b_dir and b_data are no longer used below */
2851:ff.c          **** 
2852:ff.c          **** 	/* Determine number of cluster and final check of validity of the FAT type */
2853:ff.c          **** 	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
2854:ff.c          **** 	if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
2855:ff.c          **** 		|| (fmt == FS_FAT32 && n_clst < 0xFFF5))
2856:ff.c          **** 		return FR_MKFS_ABORTED;
2857:ff.c          **** 
2858:ff.c          **** 	/* Create partition table if needed */
2859:ff.c          **** 	if (!partition) {
2860:ff.c          **** 		DWORD n_disk = b_part + n_part;
2861:ff.c          **** 
2862:ff.c          **** 		mem_set(fs->win, 0, SS(fs));
2863:ff.c          **** 		tbl = fs->win+MBR_Table;
2864:ff.c          **** 		ST_DWORD(tbl, 0x00010180);		/* Partition start in CHS */
2865:ff.c          **** 		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
2866:ff.c          **** 			n_disk = n_disk / 63 / 255;
2867:ff.c          **** 			tbl[7] = (BYTE)n_disk;
2868:ff.c          **** 			tbl[6] = (BYTE)((n_disk >> 2) | 63);
2869:ff.c          **** 		} else {
2870:ff.c          **** 			ST_WORD(&tbl[6], 0xFFFF);
2871:ff.c          **** 		}
2872:ff.c          **** 		tbl[5] = 254;
2873:ff.c          **** 		if (fmt != FS_FAT32)			/* System ID */
2874:ff.c          **** 			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
2875:ff.c          **** 		else
2876:ff.c          **** 			tbl[4] = 0x0c;
2877:ff.c          **** 		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
2878:ff.c          **** 		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
2879:ff.c          **** 		ST_WORD(tbl+64, 0xAA55);		/* Signature */
2880:ff.c          **** 		if (disk_write(drv, fs->win, 0, 1) != RES_OK)
2881:ff.c          **** 			return FR_DISK_ERR;
2882:ff.c          **** 		partition = 0xF8;
2883:ff.c          **** 	} else {
2884:ff.c          **** 		partition = 0xF0;
2885:ff.c          **** 	}
2886:ff.c          **** 
2887:ff.c          **** 	/* Create boot record */
2888:ff.c          **** 	tbl = fs->win;								/* Clear buffer */
2889:ff.c          **** 	mem_set(tbl, 0, SS(fs));
2890:ff.c          **** 	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
2891:ff.c          **** 	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
2892:ff.c          **** 	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
2893:ff.c          **** 	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
2894:ff.c          **** 	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
2895:ff.c          **** 	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
2896:ff.c          **** 	if (n_part < 0x10000) {						/* Number of total sectors */
2897:ff.c          **** 		ST_WORD(tbl+BPB_TotSec16, n_part);
2898:ff.c          **** 	} else {
2899:ff.c          **** 		ST_DWORD(tbl+BPB_TotSec32, n_part);
2900:ff.c          **** 	}
2901:ff.c          **** 	tbl[BPB_Media] = partition;					/* Media descripter */
2902:ff.c          **** 	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
2903:ff.c          **** 	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
2904:ff.c          **** 	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
2905:ff.c          **** 	n = get_fattime();							/* Use current time as a VSN */
2906:ff.c          **** 	if (fmt != FS_FAT32) {
2907:ff.c          **** 		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
2908:ff.c          **** 		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of secters per FAT */
2909:ff.c          **** 		tbl[BS_DrvNum] = 0x80;					/* Drive number */
2910:ff.c          **** 		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
2911:ff.c          **** 		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume lavel, FAT signature */
2912:ff.c          **** 	} else {
2913:ff.c          **** 		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
2914:ff.c          **** 		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of secters per FAT */
2915:ff.c          **** 		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
2916:ff.c          **** 		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
2917:ff.c          **** 		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
2918:ff.c          **** 		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
2919:ff.c          **** 		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
2920:ff.c          **** 		mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);	/* Volume lavel, FAT signature */
2921:ff.c          **** 	}
2922:ff.c          **** 	ST_WORD(tbl+BS_55AA, 0xAA55);				/* Signature */
2923:ff.c          **** 	if (SS(fs) > 512U) {
2924:ff.c          **** 		ST_WORD(tbl+SS(fs)-2, 0xAA55);
2925:ff.c          **** 	}
2926:ff.c          **** 	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
2927:ff.c          **** 		return FR_DISK_ERR;
2928:ff.c          **** 	if (fmt == FS_FAT32)
2929:ff.c          **** 		disk_write(drv, tbl, b_part+6, 1);
2930:ff.c          **** 
2931:ff.c          **** 	/* Initialize FAT area */
2932:ff.c          **** 	for (m = 0; m < N_FATS; m++) {
2933:ff.c          **** 		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
2934:ff.c          **** 		if (fmt != FS_FAT32) {
2935:ff.c          **** 			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
2936:ff.c          **** 			n |= partition;
2937:ff.c          **** 			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
2938:ff.c          **** 		} else {
2939:ff.c          **** 			ST_DWORD(tbl+0, 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
2940:ff.c          **** 			ST_DWORD(tbl+4, 0xFFFFFFFF);
2941:ff.c          **** 			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
2942:ff.c          **** 		}
2943:ff.c          **** 		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
2944:ff.c          **** 			return FR_DISK_ERR;
2945:ff.c          **** 		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
2946:ff.c          **** 		for (n = 1; n < n_fat; n++) {
2947:ff.c          **** 			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
2948:ff.c          **** 				return FR_DISK_ERR;
2949:ff.c          **** 		}
2950:ff.c          **** 	}
2951:ff.c          **** 
2952:ff.c          **** 	/* Initialize Root directory */
2953:ff.c          **** 	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
2954:ff.c          **** 	do {
2955:ff.c          **** 		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
2956:ff.c          **** 			return FR_DISK_ERR;
2957:ff.c          **** 	} while (--m);
2958:ff.c          **** 
2959:ff.c          **** 	/* Create FSInfo record if needed */
2960:ff.c          **** 	if (fmt == FS_FAT32) {
2961:ff.c          **** 		ST_WORD(tbl+BS_55AA, 0xAA55);
2962:ff.c          **** 		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
2963:ff.c          **** 		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
2964:ff.c          **** 		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
2965:ff.c          **** 		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
2966:ff.c          **** 		disk_write(drv, tbl, b_part+1, 1);
2967:ff.c          **** 		disk_write(drv, tbl, b_part+7, 1);
2968:ff.c          **** 	}
2969:ff.c          **** 
2970:ff.c          **** 	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
2971:ff.c          **** }
2972:ff.c          **** 
2973:ff.c          **** #endif /* _USE_MKFS && !_FS_READONLY */
2974:ff.c          **** 
2975:ff.c          **** 
2976:ff.c          **** 
2977:ff.c          **** 
2978:ff.c          **** #if _USE_STRFUNC
2979:ff.c          **** /*-----------------------------------------------------------------------*/
2980:ff.c          **** /* Get a string from the file                                            */
2981:ff.c          **** /*-----------------------------------------------------------------------*/
2982:ff.c          **** char* f_gets (
2983:ff.c          **** 	char* buff,	/* Pointer to the string buffer to read */
2984:ff.c          **** 	int len,	/* Size of string buffer */
2985:ff.c          **** 	FIL* fil	/* Pointer to the file object */
2986:ff.c          **** )
2987:ff.c          **** {
 7545              		.loc 1 2987 1 is_stmt 1 view -0
 7546              		.cfi_startproc
 7547              		@ args = 0, pretend = 0, frame = 8
 7548              		@ frame_needed = 0, uses_anonymous_args = 0
2988:ff.c          **** 	int i = 0;
 7549              		.loc 1 2988 2 view .LVU2729
2989:ff.c          **** 	char *p = buff;
 7550              		.loc 1 2989 2 view .LVU2730
2990:ff.c          **** 	UINT rc;
 7551              		.loc 1 2990 2 view .LVU2731
2991:ff.c          **** 
2992:ff.c          **** 
2993:ff.c          **** 	while (i < len - 1) {			/* Read bytes until buffer gets filled */
 7552              		.loc 1 2993 2 view .LVU2732
2987:ff.c          **** 	int i = 0;
 7553              		.loc 1 2987 1 is_stmt 0 view .LVU2733
 7554 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 7555              		.cfi_def_cfa_offset 32
 7556              		.cfi_offset 4, -24
 7557              		.cfi_offset 5, -20
 7558              		.cfi_offset 6, -16
 7559              		.cfi_offset 7, -12
 7560              		.cfi_offset 8, -8
 7561              		.cfi_offset 14, -4
2987:ff.c          **** 	int i = 0;
 7562              		.loc 1 2987 1 view .LVU2734
 7563 0004 0446     		mov	r4, r0
 7564 0006 9046     		mov	r8, r2
2989:ff.c          **** 	UINT rc;
 7565              		.loc 1 2989 8 view .LVU2735
 7566 0008 0646     		mov	r6, r0
2988:ff.c          **** 	char *p = buff;
 7567              		.loc 1 2988 6 view .LVU2736
 7568 000a 0025     		movs	r5, #0
 7569              		.loc 1 2993 17 view .LVU2737
 7570 000c 4F1E     		subs	r7, r1, #1
 7571              	.LVL805:
 7572              	.L614:
 7573              		.loc 1 2993 8 is_stmt 1 view .LVU2738
 7574 000e AF42     		cmp	r7, r5
 7575 0010 0DDD     		ble	.L615
2994:ff.c          **** 		f_read(fil, p, 1, &rc);
 7576              		.loc 1 2994 3 view .LVU2739
 7577 0012 01AB     		add	r3, sp, #4
 7578 0014 0122     		movs	r2, #1
 7579 0016 3146     		mov	r1, r6
 7580 0018 4046     		mov	r0, r8
 7581 001a FFF7FEFF 		bl	f_read
 7582              	.LVL806:
2995:ff.c          **** 		if (rc != 1) break;			/* Break when no data to read */
 7583              		.loc 1 2995 3 view .LVU2740
 7584              		.loc 1 2995 6 is_stmt 0 view .LVU2741
 7585 001e 019B     		ldr	r3, [sp, #4]
 7586 0020 012B     		cmp	r3, #1
 7587 0022 04D1     		bne	.L615
2996:ff.c          **** #if _USE_STRFUNC >= 2
2997:ff.c          **** 		if (*p == '\r') continue;	/* Strip '\r' */
2998:ff.c          **** #endif
2999:ff.c          **** 		i++;
 7588              		.loc 1 2999 3 is_stmt 1 view .LVU2742
3000:ff.c          **** 		if (*p++ == '\n') break;	/* Break when reached end of line */
 7589              		.loc 1 3000 6 is_stmt 0 view .LVU2743
 7590 0024 16F8013B 		ldrb	r3, [r6], #1	@ zero_extendqisi2
 7591              	.LVL807:
2999:ff.c          **** 		if (*p++ == '\n') break;	/* Break when reached end of line */
 7592              		.loc 1 2999 4 view .LVU2744
 7593 0028 0135     		adds	r5, r5, #1
 7594              	.LVL808:
 7595              		.loc 1 3000 3 is_stmt 1 view .LVU2745
 7596              		.loc 1 3000 6 is_stmt 0 view .LVU2746
 7597 002a 0A2B     		cmp	r3, #10
 7598 002c EFD1     		bne	.L614
 7599              	.L615:
 7600              	.LVL809:
3001:ff.c          **** 	}
3002:ff.c          **** 	*p = 0;
 7601              		.loc 1 3002 2 is_stmt 1 view .LVU2747
 7602              		.loc 1 3002 5 is_stmt 0 view .LVU2748
 7603 002e 0023     		movs	r3, #0
3003:ff.c          **** 	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
 7604              		.loc 1 3003 18 view .LVU2749
 7605 0030 9D42     		cmp	r5, r3
3004:ff.c          **** }
 7606              		.loc 1 3004 1 view .LVU2750
 7607 0032 14BF     		ite	ne
 7608 0034 2046     		movne	r0, r4
 7609 0036 1846     		moveq	r0, r3
3002:ff.c          **** 	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
 7610              		.loc 1 3002 5 view .LVU2751
 7611 0038 3370     		strb	r3, [r6]
3003:ff.c          **** 	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
 7612              		.loc 1 3003 2 is_stmt 1 view .LVU2752
 7613              		.loc 1 3004 1 is_stmt 0 view .LVU2753
 7614 003a 02B0     		add	sp, sp, #8
 7615              		.cfi_def_cfa_offset 24
 7616              		@ sp needed
 7617 003c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 7618              		.loc 1 3004 1 view .LVU2754
 7619              		.cfi_endproc
 7620              	.LFE71:
 7622              		.section	.text.f_putc,"ax",%progbits
 7623              		.align	1
 7624              		.global	f_putc
 7625              		.syntax unified
 7626              		.thumb
 7627              		.thumb_func
 7628              		.fpu softvfp
 7630              	f_putc:
 7631              	.LVL810:
 7632              	.LFB72:
3005:ff.c          **** 
3006:ff.c          **** 
3007:ff.c          **** 
3008:ff.c          **** #if !_FS_READONLY
3009:ff.c          **** #include <stdarg.h>
3010:ff.c          **** /*-----------------------------------------------------------------------*/
3011:ff.c          **** /* Put a character to the file                                           */
3012:ff.c          **** /*-----------------------------------------------------------------------*/
3013:ff.c          **** int f_putc (
3014:ff.c          **** 	int chr,	/* A character to be output */
3015:ff.c          **** 	FIL* fil	/* Ponter to the file object */
3016:ff.c          **** )
3017:ff.c          **** {
 7633              		.loc 1 3017 1 is_stmt 1 view -0
 7634              		.cfi_startproc
 7635              		@ args = 0, pretend = 0, frame = 8
 7636              		@ frame_needed = 0, uses_anonymous_args = 0
3018:ff.c          **** 	UINT bw;
 7637              		.loc 1 3018 2 view .LVU2756
3019:ff.c          **** 	char c;
 7638              		.loc 1 3019 2 view .LVU2757
3020:ff.c          **** 
3021:ff.c          **** 
3022:ff.c          **** #if _USE_STRFUNC >= 2
3023:ff.c          **** 	if (chr == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
3024:ff.c          **** #endif
3025:ff.c          **** 	if (!fil) {	/* Special value may be used to switch the destination to any other device */
 7639              		.loc 1 3025 2 view .LVU2758
3017:ff.c          **** 	UINT bw;
 7640              		.loc 1 3017 1 is_stmt 0 view .LVU2759
 7641 0000 13B5     		push	{r0, r1, r4, lr}
 7642              		.cfi_def_cfa_offset 16
 7643              		.cfi_offset 4, -8
 7644              		.cfi_offset 14, -4
3017:ff.c          **** 	UINT bw;
 7645              		.loc 1 3017 1 view .LVU2760
 7646 0002 0446     		mov	r4, r0
 7647              		.loc 1 3025 5 view .LVU2761
 7648 0004 0846     		mov	r0, r1
 7649              	.LVL811:
 7650              		.loc 1 3025 5 view .LVU2762
 7651 0006 61B1     		cbz	r1, .L622
 7652              	.LVL812:
 7653              	.LBB157:
 7654              	.LBI157:
3013:ff.c          **** 	int chr,	/* A character to be output */
 7655              		.loc 1 3013 5 is_stmt 1 view .LVU2763
 7656              	.LBB158:
3026:ff.c          **** 	/*	put_console(chr);	*/
3027:ff.c          **** 		return chr;
3028:ff.c          **** 	}
3029:ff.c          **** 	c = (char)chr;
 7657              		.loc 1 3029 2 view .LVU2764
3030:ff.c          **** 	f_write(fil, &c, 1, &bw);	/* Write a byte to the file */
 7658              		.loc 1 3030 2 is_stmt 0 view .LVU2765
 7659 0008 01AB     		add	r3, sp, #4
 7660 000a 0122     		movs	r2, #1
 7661 000c 0DF10301 		add	r1, sp, #3
 7662              	.LVL813:
3029:ff.c          **** 	f_write(fil, &c, 1, &bw);	/* Write a byte to the file */
 7663              		.loc 1 3029 6 view .LVU2766
 7664 0010 8DF80340 		strb	r4, [sp, #3]
 7665              		.loc 1 3030 2 is_stmt 1 view .LVU2767
 7666 0014 FFF7FEFF 		bl	f_write
 7667              	.LVL814:
3031:ff.c          **** 	return bw ? chr : EOF;		/* Return the result */
 7668              		.loc 1 3031 2 view .LVU2768
 7669              		.loc 1 3031 18 is_stmt 0 view .LVU2769
 7670 0018 019B     		ldr	r3, [sp, #4]
 7671 001a 002B     		cmp	r3, #0
 7672 001c 08BF     		it	eq
 7673 001e 4FF0FF34 		moveq	r4, #-1
 7674              	.LVL815:
 7675              	.L622:
 7676              		.loc 1 3031 18 view .LVU2770
 7677              	.LBE158:
 7678              	.LBE157:
3032:ff.c          **** }
 7679              		.loc 1 3032 1 view .LVU2771
 7680 0022 2046     		mov	r0, r4
 7681 0024 02B0     		add	sp, sp, #8
 7682              		.cfi_def_cfa_offset 8
 7683              		@ sp needed
 7684 0026 10BD     		pop	{r4, pc}
 7685              		.cfi_endproc
 7686              	.LFE72:
 7688              		.section	.text.f_puts,"ax",%progbits
 7689              		.align	1
 7690              		.global	f_puts
 7691              		.syntax unified
 7692              		.thumb
 7693              		.thumb_func
 7694              		.fpu softvfp
 7696              	f_puts:
 7697              	.LVL816:
 7698              	.LFB73:
3033:ff.c          **** 
3034:ff.c          **** 
3035:ff.c          **** 
3036:ff.c          **** 
3037:ff.c          **** /*-----------------------------------------------------------------------*/
3038:ff.c          **** /* Put a string to the file                                              */
3039:ff.c          **** /*-----------------------------------------------------------------------*/
3040:ff.c          **** int f_puts (
3041:ff.c          **** 	const char* str,	/* Pointer to the string to be output */
3042:ff.c          **** 	FIL* fil			/* Pointer to the file object */
3043:ff.c          **** )
3044:ff.c          **** {
 7699              		.loc 1 3044 1 is_stmt 1 view -0
 7700              		.cfi_startproc
 7701              		@ args = 0, pretend = 0, frame = 0
 7702              		@ frame_needed = 0, uses_anonymous_args = 0
3045:ff.c          **** 	int n;
 7703              		.loc 1 3045 2 view .LVU2773
3046:ff.c          **** 
3047:ff.c          **** 
3048:ff.c          **** 	for (n = 0; *str; str++, n++) {
 7704              		.loc 1 3048 2 view .LVU2774
3044:ff.c          **** 	int n;
 7705              		.loc 1 3044 1 is_stmt 0 view .LVU2775
 7706 0000 70B5     		push	{r4, r5, r6, lr}
 7707              		.cfi_def_cfa_offset 16
 7708              		.cfi_offset 4, -16
 7709              		.cfi_offset 5, -12
 7710              		.cfi_offset 6, -8
 7711              		.cfi_offset 14, -4
3044:ff.c          **** 	int n;
 7712              		.loc 1 3044 1 view .LVU2776
 7713 0002 0546     		mov	r5, r0
 7714 0004 0E46     		mov	r6, r1
 7715              		.loc 1 3048 9 view .LVU2777
 7716 0006 0024     		movs	r4, #0
 7717              	.LVL817:
 7718              	.L628:
 7719              		.loc 1 3048 14 is_stmt 1 discriminator 1 view .LVU2778
 7720 0008 285D     		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 7721              		.loc 1 3048 2 is_stmt 0 discriminator 1 view .LVU2779
 7722 000a 08B9     		cbnz	r0, .L630
 7723 000c 2046     		mov	r0, r4
 7724              	.L627:
3049:ff.c          **** 		if (f_putc(*str, fil) == EOF) return EOF;
3050:ff.c          **** 	}
3051:ff.c          **** 	return n;
3052:ff.c          **** }
 7725              		.loc 1 3052 1 view .LVU2780
 7726 000e 70BD     		pop	{r4, r5, r6, pc}
 7727              	.LVL818:
 7728              	.L630:
3049:ff.c          **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7729              		.loc 1 3049 3 is_stmt 1 view .LVU2781
3049:ff.c          **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7730              		.loc 1 3049 7 is_stmt 0 view .LVU2782
 7731 0010 3146     		mov	r1, r6
 7732 0012 FFF7FEFF 		bl	f_putc
 7733              	.LVL819:
3049:ff.c          **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7734              		.loc 1 3049 6 view .LVU2783
 7735 0016 431C     		adds	r3, r0, #1
 7736 0018 F9D0     		beq	.L627
3048:ff.c          **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7737              		.loc 1 3048 20 is_stmt 1 discriminator 2 view .LVU2784
 7738              	.LVL820:
3048:ff.c          **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7739              		.loc 1 3048 28 is_stmt 0 discriminator 2 view .LVU2785
 7740 001a 0134     		adds	r4, r4, #1
 7741              	.LVL821:
3048:ff.c          **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7742              		.loc 1 3048 28 discriminator 2 view .LVU2786
 7743 001c F4E7     		b	.L628
 7744              		.cfi_endproc
 7745              	.LFE73:
 7747              		.section	.text.f_printf,"ax",%progbits
 7748              		.align	1
 7749              		.global	f_printf
 7750              		.syntax unified
 7751              		.thumb
 7752              		.thumb_func
 7753              		.fpu softvfp
 7755              	f_printf:
 7756              	.LVL822:
 7757              	.LFB74:
3053:ff.c          **** 
3054:ff.c          **** 
3055:ff.c          **** 
3056:ff.c          **** 
3057:ff.c          **** /*-----------------------------------------------------------------------*/
3058:ff.c          **** /* Put a formatted string to the file                                    */
3059:ff.c          **** /*-----------------------------------------------------------------------*/
3060:ff.c          **** int f_printf (
3061:ff.c          **** 	FIL* fil,			/* Pointer to the file object */
3062:ff.c          **** 	const char* str,	/* Pointer to the format string */
3063:ff.c          **** 	...					/* Optional arguments... */
3064:ff.c          **** )
3065:ff.c          **** {
 7758              		.loc 1 3065 1 is_stmt 1 view -0
 7759              		.cfi_startproc
 7760              		@ args = 4, pretend = 12, frame = 24
 7761              		@ frame_needed = 0, uses_anonymous_args = 1
3066:ff.c          **** 	va_list arp;
 7762              		.loc 1 3066 2 view .LVU2788
3067:ff.c          **** 	UCHAR c, f, r;
 7763              		.loc 1 3067 2 view .LVU2789
3068:ff.c          **** 	ULONG val;
 7764              		.loc 1 3068 2 view .LVU2790
3069:ff.c          **** 	char s[16];
 7765              		.loc 1 3069 2 view .LVU2791
3070:ff.c          **** 	int i, w, res, cc;
 7766              		.loc 1 3070 2 view .LVU2792
3071:ff.c          **** 
3072:ff.c          **** 
3073:ff.c          **** 	va_start(arp, str);
 7767              		.loc 1 3073 2 view .LVU2793
3065:ff.c          **** 	va_list arp;
 7768              		.loc 1 3065 1 is_stmt 0 view .LVU2794
 7769 0000 0EB4     		push	{r1, r2, r3}
 7770              		.cfi_def_cfa_offset 12
 7771              		.cfi_offset 1, -12
 7772              		.cfi_offset 2, -8
 7773              		.cfi_offset 3, -4
 7774 0002 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7775              		.cfi_def_cfa_offset 48
 7776              		.cfi_offset 4, -48
 7777              		.cfi_offset 5, -44
 7778              		.cfi_offset 6, -40
 7779              		.cfi_offset 7, -36
 7780              		.cfi_offset 8, -32
 7781              		.cfi_offset 9, -28
 7782              		.cfi_offset 10, -24
 7783              		.cfi_offset 11, -20
 7784              		.cfi_offset 14, -16
3074:ff.c          **** 
3075:ff.c          **** 	for (cc = res = 0; cc != EOF; res += cc) {
 7785              		.loc 1 3075 16 view .LVU2795
 7786 0006 0024     		movs	r4, #0
3065:ff.c          **** 	va_list arp;
 7787              		.loc 1 3065 1 view .LVU2796
 7788 0008 8046     		mov	r8, r0
3076:ff.c          **** 		c = *str++;
3077:ff.c          **** 		if (c == 0) break;			/* End of string */
3078:ff.c          **** 		if (c != '%') {				/* Non escape cahracter */
3079:ff.c          **** 			cc = f_putc(c, fil);
3080:ff.c          **** 			if (cc != EOF) cc = 1;
3081:ff.c          **** 			continue;
3082:ff.c          **** 		}
3083:ff.c          **** 		w = f = 0;
 7789              		.loc 1 3083 9 view .LVU2797
 7790 000a 2646     		mov	r6, r4
3065:ff.c          **** 	va_list arp;
 7791              		.loc 1 3065 1 view .LVU2798
 7792 000c 86B0     		sub	sp, sp, #24
 7793              		.cfi_def_cfa_offset 72
3065:ff.c          **** 	va_list arp;
 7794              		.loc 1 3065 1 view .LVU2799
 7795 000e 0FAB     		add	r3, sp, #60
 7796 0010 53F8042B 		ldr	r2, [r3], #4
3084:ff.c          **** 		c = *str++;
3085:ff.c          **** 		if (c == '0') {				/* Flag: '0' padding */
3086:ff.c          **** 			f = 1; c = *str++;
3087:ff.c          **** 		}
3088:ff.c          **** 		while (c >= '0' && c <= '9') {	/* Precision */
3089:ff.c          **** 			w = w * 10 + (c - '0');
3090:ff.c          **** 			c = *str++;
3091:ff.c          **** 		}
3092:ff.c          **** 		if (c == 'l') {				/* Prefix: Size is long int */
3093:ff.c          **** 			f |= 2; c = *str++;
3094:ff.c          **** 		}
3095:ff.c          **** 		if (c == 's') {				/* Type is string */
3096:ff.c          **** 			cc = f_puts(va_arg(arp, char*), fil);
3097:ff.c          **** 			continue;
3098:ff.c          **** 		}
3099:ff.c          **** 		if (c == 'c') {				/* Type is character */
3100:ff.c          **** 			cc = f_putc(va_arg(arp, int), fil);
3101:ff.c          **** 			if (cc != EOF) cc = 1;
3102:ff.c          **** 			continue;
3103:ff.c          **** 		}
3104:ff.c          **** 		r = 0;
3105:ff.c          **** 		if (c == 'd') r = 10;		/* Type is signed decimal */
3106:ff.c          **** 		if (c == 'u') r = 10;		/* Type is unsigned decimal */
3107:ff.c          **** 		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
3108:ff.c          **** 		if (r == 0) break;			/* Unknown type */
3109:ff.c          **** 		if (f & 2) {				/* Get the value */
3110:ff.c          **** 			val = (ULONG)va_arg(arp, long);
3111:ff.c          **** 		} else {
3112:ff.c          **** 			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
3113:ff.c          **** 		}
3114:ff.c          **** 		/* Put numeral string */
3115:ff.c          **** 		if (c == 'd') {
3116:ff.c          **** 			if (val & 0x80000000) {
3117:ff.c          **** 				val = 0 - val;
3118:ff.c          **** 				f |= 4;
3119:ff.c          **** 			}
3120:ff.c          **** 		}
3121:ff.c          **** 		i = sizeof(s) - 1; s[i] = 0;
3122:ff.c          **** 		do {
3123:ff.c          **** 			c = (UCHAR)(val % r + '0');
3124:ff.c          **** 			if (c > '9') c += 7;
3125:ff.c          **** 			s[--i] = c;
 7797              		.loc 1 3125 11 view .LVU2800
 7798 0014 02AD     		add	r5, sp, #8
3073:ff.c          **** 
 7799              		.loc 1 3073 2 view .LVU2801
 7800 0016 0193     		str	r3, [sp, #4]
3075:ff.c          **** 		c = *str++;
 7801              		.loc 1 3075 2 is_stmt 1 view .LVU2802
 7802              	.LVL823:
3075:ff.c          **** 		c = *str++;
 7803              		.loc 1 3075 21 view .LVU2803
 7804              	.L657:
3076:ff.c          **** 		if (c == 0) break;			/* End of string */
 7805              		.loc 1 3076 3 view .LVU2804
3076:ff.c          **** 		if (c == 0) break;			/* End of string */
 7806              		.loc 1 3076 11 is_stmt 0 view .LVU2805
 7807 0018 1746     		mov	r7, r2
 7808              	.LVL824:
3076:ff.c          **** 		if (c == 0) break;			/* End of string */
 7809              		.loc 1 3076 5 view .LVU2806
 7810 001a 17F8010B 		ldrb	r0, [r7], #1	@ zero_extendqisi2
 7811              	.LVL825:
3077:ff.c          **** 		if (c != '%') {				/* Non escape cahracter */
 7812              		.loc 1 3077 3 is_stmt 1 view .LVU2807
3077:ff.c          **** 		if (c != '%') {				/* Non escape cahracter */
 7813              		.loc 1 3077 6 is_stmt 0 view .LVU2808
 7814 001e 58B1     		cbz	r0, .L634
3078:ff.c          **** 			cc = f_putc(c, fil);
 7815              		.loc 1 3078 3 is_stmt 1 view .LVU2809
3078:ff.c          **** 			cc = f_putc(c, fil);
 7816              		.loc 1 3078 6 is_stmt 0 view .LVU2810
 7817 0020 2528     		cmp	r0, #37
 7818 0022 11D0     		beq	.L636
3079:ff.c          **** 			if (cc != EOF) cc = 1;
 7819              		.loc 1 3079 4 is_stmt 1 view .LVU2811
3079:ff.c          **** 			if (cc != EOF) cc = 1;
 7820              		.loc 1 3079 9 is_stmt 0 view .LVU2812
 7821 0024 4146     		mov	r1, r8
 7822              	.LVL826:
 7823              	.L681:
3100:ff.c          **** 			if (cc != EOF) cc = 1;
 7824              		.loc 1 3100 9 view .LVU2813
 7825 0026 FFF7FEFF 		bl	f_putc
 7826              	.LVL827:
3101:ff.c          **** 			continue;
 7827              		.loc 1 3101 4 is_stmt 1 view .LVU2814
3101:ff.c          **** 			continue;
 7828              		.loc 1 3101 22 is_stmt 0 view .LVU2815
 7829 002a 421C     		adds	r2, r0, #1
 7830 002c 18BF     		it	ne
 7831 002e 0120     		movne	r0, #1
 7832              	.LVL828:
 7833              	.L637:
3075:ff.c          **** 		c = *str++;
 7834              		.loc 1 3075 32 is_stmt 1 discriminator 2 view .LVU2816
3075:ff.c          **** 		c = *str++;
 7835              		.loc 1 3075 2 is_stmt 0 discriminator 2 view .LVU2817
 7836 0030 431C     		adds	r3, r0, #1
3075:ff.c          **** 		c = *str++;
 7837              		.loc 1 3075 36 discriminator 2 view .LVU2818
 7838 0032 0444     		add	r4, r4, r0
 7839              	.LVL829:
3075:ff.c          **** 		c = *str++;
 7840              		.loc 1 3075 21 is_stmt 1 discriminator 2 view .LVU2819
3075:ff.c          **** 		c = *str++;
 7841              		.loc 1 3075 2 is_stmt 0 discriminator 2 view .LVU2820
 7842 0034 06D1     		bne	.L664
3075:ff.c          **** 		c = *str++;
 7843              		.loc 1 3075 2 discriminator 2 view .LVU2821
 7844 0036 0446     		mov	r4, r0
 7845              	.LVL830:
 7846              	.L634:
3126:ff.c          **** 			val /= r;
3127:ff.c          **** 		} while (i && val);
3128:ff.c          **** 		if (i && (f & 4)) s[--i] = '-';
3129:ff.c          **** 		w = sizeof(s) - 1 - w;
3130:ff.c          **** 		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
3131:ff.c          **** 		cc = f_puts(&s[i], fil);
3132:ff.c          **** 	}
3133:ff.c          **** 
3134:ff.c          **** 	va_end(arp);
3135:ff.c          **** 	return (cc == EOF) ? cc : res;
3136:ff.c          **** }
 7847              		.loc 1 3136 1 view .LVU2822
 7848 0038 2046     		mov	r0, r4
 7849 003a 06B0     		add	sp, sp, #24
 7850              		.cfi_remember_state
 7851              		.cfi_def_cfa_offset 48
 7852              		@ sp needed
 7853 003c BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7854              		.cfi_restore 14
 7855              		.cfi_restore 11
 7856              		.cfi_restore 10
 7857              		.cfi_restore 9
 7858              		.cfi_restore 8
 7859              		.cfi_restore 7
 7860              		.cfi_restore 6
 7861              		.cfi_restore 5
 7862              		.cfi_restore 4
 7863              		.cfi_def_cfa_offset 12
 7864              	.LVL831:
 7865              		.loc 1 3136 1 view .LVU2823
 7866 0040 03B0     		add	sp, sp, #12
 7867              		.cfi_restore 3
 7868              		.cfi_restore 2
 7869              		.cfi_restore 1
 7870              		.cfi_def_cfa_offset 0
 7871 0042 7047     		bx	lr
 7872              	.LVL832:
 7873              	.L664:
 7874              		.cfi_restore_state
 7875              		.loc 1 3136 1 view .LVU2824
 7876 0044 3A46     		mov	r2, r7
 7877 0046 E7E7     		b	.L657
 7878              	.LVL833:
 7879              	.L636:
3083:ff.c          **** 		c = *str++;
 7880              		.loc 1 3083 3 is_stmt 1 view .LVU2825
3084:ff.c          **** 		if (c == '0') {				/* Flag: '0' padding */
 7881              		.loc 1 3084 3 view .LVU2826
3084:ff.c          **** 		if (c == '0') {				/* Flag: '0' padding */
 7882              		.loc 1 3084 5 is_stmt 0 view .LVU2827
 7883 0048 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 7884              	.LVL834:
3085:ff.c          **** 			f = 1; c = *str++;
 7885              		.loc 1 3085 3 is_stmt 1 view .LVU2828
3085:ff.c          **** 			f = 1; c = *str++;
 7886              		.loc 1 3085 6 is_stmt 0 view .LVU2829
 7887 004a 302B     		cmp	r3, #48
 7888 004c 20D1     		bne	.L638
3086:ff.c          **** 		}
 7889              		.loc 1 3086 4 is_stmt 1 view .LVU2830
 7890              	.LVL835:
3086:ff.c          **** 		}
 7891              		.loc 1 3086 11 view .LVU2831
3086:ff.c          **** 		}
 7892              		.loc 1 3086 13 is_stmt 0 view .LVU2832
 7893 004e 9378     		ldrb	r3, [r2, #2]	@ zero_extendqisi2
 7894              	.LVL836:
3086:ff.c          **** 		}
 7895              		.loc 1 3086 19 view .LVU2833
 7896 0050 D71C     		adds	r7, r2, #3
 7897              	.LVL837:
3086:ff.c          **** 		}
 7898              		.loc 1 3086 6 view .LVU2834
 7899 0052 0122     		movs	r2, #1
 7900              	.LVL838:
 7901              	.L639:
3083:ff.c          **** 		c = *str++;
 7902              		.loc 1 3083 9 view .LVU2835
 7903 0054 4FF0000C 		mov	ip, #0
3089:ff.c          **** 			c = *str++;
 7904              		.loc 1 3089 10 view .LVU2836
 7905 0058 4FF00A0E 		mov	lr, #10
 7906 005c 03E0     		b	.L640
 7907              	.LVL839:
 7908              	.L641:
3089:ff.c          **** 			c = *str++;
 7909              		.loc 1 3089 4 is_stmt 1 view .LVU2837
3089:ff.c          **** 			c = *str++;
 7910              		.loc 1 3089 6 is_stmt 0 view .LVU2838
 7911 005e 0EFB0C1C 		mla	ip, lr, ip, r1
 7912              	.LVL840:
3090:ff.c          **** 		}
 7913              		.loc 1 3090 4 is_stmt 1 view .LVU2839
3090:ff.c          **** 		}
 7914              		.loc 1 3090 6 is_stmt 0 view .LVU2840
 7915 0062 17F8013B 		ldrb	r3, [r7], #1	@ zero_extendqisi2
 7916              	.LVL841:
 7917              	.L640:
3088:ff.c          **** 			w = w * 10 + (c - '0');
 7918              		.loc 1 3088 9 is_stmt 1 view .LVU2841
3088:ff.c          **** 			w = w * 10 + (c - '0');
 7919              		.loc 1 3088 19 is_stmt 0 view .LVU2842
 7920 0066 A3F13001 		sub	r1, r3, #48
3088:ff.c          **** 			w = w * 10 + (c - '0');
 7921              		.loc 1 3088 9 view .LVU2843
 7922 006a C8B2     		uxtb	r0, r1
 7923 006c 0928     		cmp	r0, #9
 7924 006e F6D9     		bls	.L641
3092:ff.c          **** 			f |= 2; c = *str++;
 7925              		.loc 1 3092 3 is_stmt 1 view .LVU2844
3092:ff.c          **** 			f |= 2; c = *str++;
 7926              		.loc 1 3092 6 is_stmt 0 view .LVU2845
 7927 0070 6C2B     		cmp	r3, #108
3093:ff.c          **** 		}
 7928              		.loc 1 3093 4 is_stmt 1 view .LVU2846
3093:ff.c          **** 		}
 7929              		.loc 1 3093 14 is_stmt 0 view .LVU2847
 7930 0072 04BF     		itt	eq
 7931 0074 17F8013B 		ldrbeq	r3, [r7], #1	@ zero_extendqisi2
 7932              	.LVL842:
3093:ff.c          **** 		}
 7933              		.loc 1 3093 6 view .LVU2848
 7934 0078 42F00202 		orreq	r2, r2, #2
 7935              	.LVL843:
3093:ff.c          **** 		}
 7936              		.loc 1 3093 12 is_stmt 1 view .LVU2849
3095:ff.c          **** 			cc = f_puts(va_arg(arp, char*), fil);
 7937              		.loc 1 3095 3 view .LVU2850
3095:ff.c          **** 			cc = f_puts(va_arg(arp, char*), fil);
 7938              		.loc 1 3095 6 is_stmt 0 view .LVU2851
 7939 007c 732B     		cmp	r3, #115
 7940 007e 0AD1     		bne	.L643
3096:ff.c          **** 			continue;
 7941              		.loc 1 3096 4 is_stmt 1 view .LVU2852
3096:ff.c          **** 			continue;
 7942              		.loc 1 3096 9 is_stmt 0 view .LVU2853
 7943 0080 4146     		mov	r1, r8
3096:ff.c          **** 			continue;
 7944              		.loc 1 3096 16 view .LVU2854
 7945 0082 019B     		ldr	r3, [sp, #4]
 7946              	.LVL844:
3096:ff.c          **** 			continue;
 7947              		.loc 1 3096 16 view .LVU2855
 7948 0084 1A1D     		adds	r2, r3, #4
 7949              	.LVL845:
3096:ff.c          **** 			continue;
 7950              		.loc 1 3096 9 view .LVU2856
 7951 0086 1868     		ldr	r0, [r3]
3096:ff.c          **** 			continue;
 7952              		.loc 1 3096 16 view .LVU2857
 7953 0088 0192     		str	r2, [sp, #4]
 7954              	.LVL846:
 7955              	.L680:
3131:ff.c          **** 	}
 7956              		.loc 1 3131 8 view .LVU2858
 7957 008a FFF7FEFF 		bl	f_puts
 7958              	.LVL847:
3131:ff.c          **** 	}
 7959              		.loc 1 3131 8 view .LVU2859
 7960 008e CFE7     		b	.L637
 7961              	.LVL848:
 7962              	.L638:
3084:ff.c          **** 		if (c == '0') {				/* Flag: '0' padding */
 7963              		.loc 1 3084 11 view .LVU2860
 7964 0090 971C     		adds	r7, r2, #2
3083:ff.c          **** 		c = *str++;
 7965              		.loc 1 3083 9 view .LVU2861
 7966 0092 0022     		movs	r2, #0
 7967              	.LVL849:
3083:ff.c          **** 		c = *str++;
 7968              		.loc 1 3083 9 view .LVU2862
 7969 0094 DEE7     		b	.L639
 7970              	.LVL850:
 7971              	.L643:
3099:ff.c          **** 			cc = f_putc(va_arg(arp, int), fil);
 7972              		.loc 1 3099 3 is_stmt 1 view .LVU2863
3099:ff.c          **** 			cc = f_putc(va_arg(arp, int), fil);
 7973              		.loc 1 3099 6 is_stmt 0 view .LVU2864
 7974 0096 632B     		cmp	r3, #99
 7975 0098 05D1     		bne	.L644
3100:ff.c          **** 			if (cc != EOF) cc = 1;
 7976              		.loc 1 3100 4 is_stmt 1 view .LVU2865
3100:ff.c          **** 			if (cc != EOF) cc = 1;
 7977              		.loc 1 3100 9 is_stmt 0 view .LVU2866
 7978 009a 019B     		ldr	r3, [sp, #4]
 7979              	.LVL851:
3100:ff.c          **** 			if (cc != EOF) cc = 1;
 7980              		.loc 1 3100 9 view .LVU2867
 7981 009c 4146     		mov	r1, r8
3100:ff.c          **** 			if (cc != EOF) cc = 1;
 7982              		.loc 1 3100 9 view .LVU2868
 7983 009e 1A1D     		adds	r2, r3, #4
 7984              	.LVL852:
3100:ff.c          **** 			if (cc != EOF) cc = 1;
 7985              		.loc 1 3100 9 view .LVU2869
 7986 00a0 1868     		ldr	r0, [r3]
 7987 00a2 0192     		str	r2, [sp, #4]
 7988 00a4 BFE7     		b	.L681
 7989              	.LVL853:
 7990              	.L644:
3104:ff.c          **** 		if (c == 'd') r = 10;		/* Type is signed decimal */
 7991              		.loc 1 3104 3 is_stmt 1 view .LVU2870
3105:ff.c          **** 		if (c == 'u') r = 10;		/* Type is unsigned decimal */
 7992              		.loc 1 3105 3 view .LVU2871
3105:ff.c          **** 		if (c == 'u') r = 10;		/* Type is unsigned decimal */
 7993              		.loc 1 3105 6 is_stmt 0 view .LVU2872
 7994 00a6 642B     		cmp	r3, #100
 7995 00a8 40D0     		beq	.L662
3106:ff.c          **** 		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
 7996              		.loc 1 3106 3 is_stmt 1 view .LVU2873
3106:ff.c          **** 		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
 7997              		.loc 1 3106 6 is_stmt 0 view .LVU2874
 7998 00aa 752B     		cmp	r3, #117
 7999 00ac 3ED0     		beq	.L662
3107:ff.c          **** 		if (r == 0) break;			/* Unknown type */
 8000              		.loc 1 3107 3 is_stmt 1 view .LVU2875
3107:ff.c          **** 		if (r == 0) break;			/* Unknown type */
 8001              		.loc 1 3107 6 is_stmt 0 view .LVU2876
 8002 00ae 582B     		cmp	r3, #88
 8003 00b0 C2D1     		bne	.L634
3107:ff.c          **** 		if (r == 0) break;			/* Unknown type */
 8004              		.loc 1 3107 19 view .LVU2877
 8005 00b2 4FF0100E 		mov	lr, #16
 8006              	.L645:
 8007              	.LVL854:
3109:ff.c          **** 			val = (ULONG)va_arg(arp, long);
 8008              		.loc 1 3109 3 is_stmt 1 view .LVU2878
 8009 00b6 0198     		ldr	r0, [sp, #4]
3112:ff.c          **** 		}
 8010              		.loc 1 3112 53 is_stmt 0 view .LVU2879
 8011 00b8 642B     		cmp	r3, #100
 8012 00ba 50F8041B 		ldr	r1, [r0], #4
3110:ff.c          **** 		} else {
 8013              		.loc 1 3110 17 view .LVU2880
 8014 00be 0190     		str	r0, [sp, #4]
3112:ff.c          **** 		}
 8015              		.loc 1 3112 4 is_stmt 1 view .LVU2881
3112:ff.c          **** 		}
 8016              		.loc 1 3112 53 is_stmt 0 view .LVU2882
 8017 00c0 04D1     		bne	.L648
 8018              	.LVL855:
3116:ff.c          **** 				val = 0 - val;
 8019              		.loc 1 3116 4 is_stmt 1 view .LVU2883
3116:ff.c          **** 				val = 0 - val;
 8020              		.loc 1 3116 7 is_stmt 0 view .LVU2884
 8021 00c2 0029     		cmp	r1, #0
3117:ff.c          **** 				f |= 4;
 8022              		.loc 1 3117 5 is_stmt 1 view .LVU2885
3117:ff.c          **** 				f |= 4;
 8023              		.loc 1 3117 9 is_stmt 0 view .LVU2886
 8024 00c4 BCBF     		itt	lt
 8025 00c6 4942     		rsblt	r1, r1, #0
 8026              	.LVL856:
3118:ff.c          **** 			}
 8027              		.loc 1 3118 5 is_stmt 1 view .LVU2887
3118:ff.c          **** 			}
 8028              		.loc 1 3118 7 is_stmt 0 view .LVU2888
 8029 00c8 42F00402 		orrlt	r2, r2, #4
 8030              	.LVL857:
 8031              	.L648:
3121:ff.c          **** 		do {
 8032              		.loc 1 3121 3 is_stmt 1 view .LVU2889
3121:ff.c          **** 		do {
 8033              		.loc 1 3121 22 view .LVU2890
3121:ff.c          **** 		do {
 8034              		.loc 1 3121 5 is_stmt 0 view .LVU2891
 8035 00cc 4FF00F09 		mov	r9, #15
3121:ff.c          **** 		do {
 8036              		.loc 1 3121 27 view .LVU2892
 8037 00d0 8DF81760 		strb	r6, [sp, #23]
 8038              	.LVL858:
 8039              	.L652:
3122:ff.c          **** 			c = (UCHAR)(val % r + '0');
 8040              		.loc 1 3122 3 is_stmt 1 view .LVU2893
3123:ff.c          **** 			if (c > '9') c += 7;
 8041              		.loc 1 3123 4 view .LVU2894
3123:ff.c          **** 			if (c > '9') c += 7;
 8042              		.loc 1 3123 20 is_stmt 0 view .LVU2895
 8043 00d4 B1FBFEFA 		udiv	r10, r1, lr
 8044 00d8 0EFB1A13 		mls	r3, lr, r10, r1
3123:ff.c          **** 			if (c > '9') c += 7;
 8045              		.loc 1 3123 8 view .LVU2896
 8046 00dc DBB2     		uxtb	r3, r3
3123:ff.c          **** 			if (c > '9') c += 7;
 8047              		.loc 1 3123 6 view .LVU2897
 8048 00de 03F1300B 		add	fp, r3, #48
 8049 00e2 5FFA8BFB 		uxtb	fp, fp
 8050              	.LVL859:
3124:ff.c          **** 			s[--i] = c;
 8051              		.loc 1 3124 4 is_stmt 1 view .LVU2898
3124:ff.c          **** 			s[--i] = c;
 8052              		.loc 1 3124 7 is_stmt 0 view .LVU2899
 8053 00e6 BBF1390F 		cmp	fp, #57
3124:ff.c          **** 			s[--i] = c;
 8054              		.loc 1 3124 17 is_stmt 1 view .LVU2900
3124:ff.c          **** 			s[--i] = c;
 8055              		.loc 1 3124 19 is_stmt 0 view .LVU2901
 8056 00ea 84BF     		itt	hi
 8057 00ec 3733     		addhi	r3, r3, #55
 8058              	.LVL860:
3124:ff.c          **** 			s[--i] = c;
 8059              		.loc 1 3124 19 view .LVU2902
 8060 00ee 5FFA83FB 		uxtbhi	fp, r3
3125:ff.c          **** 			val /= r;
 8061              		.loc 1 3125 4 is_stmt 1 view .LVU2903
3125:ff.c          **** 			val /= r;
 8062              		.loc 1 3125 11 is_stmt 0 view .LVU2904
 8063 00f2 09F1FF30 		add	r0, r9, #-1
 8064              	.LVL861:
3125:ff.c          **** 			val /= r;
 8065              		.loc 1 3125 11 view .LVU2905
 8066 00f6 00F805B0 		strb	fp, [r0, r5]
3126:ff.c          **** 		} while (i && val);
 8067              		.loc 1 3126 4 is_stmt 1 view .LVU2906
 8068              	.LVL862:
3127:ff.c          **** 		if (i && (f & 4)) s[--i] = '-';
 8069              		.loc 1 3127 11 view .LVU2907
3127:ff.c          **** 		if (i && (f & 4)) s[--i] = '-';
 8070              		.loc 1 3127 3 is_stmt 0 view .LVU2908
 8071 00fa 50B1     		cbz	r0, .L651
 8072              	.LVL863:
3127:ff.c          **** 		if (i && (f & 4)) s[--i] = '-';
 8073              		.loc 1 3127 14 discriminator 1 view .LVU2909
 8074 00fc 8E45     		cmp	lr, r1
 8075 00fe 18D9     		bls	.L663
3128:ff.c          **** 		w = sizeof(s) - 1 - w;
 8076              		.loc 1 3128 3 is_stmt 1 view .LVU2910
3128:ff.c          **** 		w = sizeof(s) - 1 - w;
 8077              		.loc 1 3128 9 is_stmt 0 view .LVU2911
 8078 0100 5107     		lsls	r1, r2, #29
 8079 0102 06D5     		bpl	.L651
3128:ff.c          **** 		w = sizeof(s) - 1 - w;
 8080              		.loc 1 3128 21 is_stmt 1 discriminator 2 view .LVU2912
3128:ff.c          **** 		w = sizeof(s) - 1 - w;
 8081              		.loc 1 3128 28 is_stmt 0 discriminator 2 view .LVU2913
 8082 0104 2D21     		movs	r1, #45
 8083 0106 A9F10200 		sub	r0, r9, #2
 8084              	.LVL864:
3128:ff.c          **** 		w = sizeof(s) - 1 - w;
 8085              		.loc 1 3128 28 discriminator 2 view .LVU2914
 8086 010a 06AB     		add	r3, sp, #24
 8087              	.LVL865:
3128:ff.c          **** 		w = sizeof(s) - 1 - w;
 8088              		.loc 1 3128 28 discriminator 2 view .LVU2915
 8089 010c 0344     		add	r3, r3, r0
 8090 010e 03F8101C 		strb	r1, [r3, #-16]
 8091              	.LVL866:
 8092              	.L651:
3129:ff.c          **** 		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
 8093              		.loc 1 3129 3 is_stmt 1 view .LVU2916
 8094 0112 12F0010F 		tst	r2, #1
 8095 0116 14BF     		ite	ne
 8096 0118 3023     		movne	r3, #48
 8097 011a 2023     		moveq	r3, #32
3129:ff.c          **** 		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
 8098              		.loc 1 3129 21 is_stmt 0 view .LVU2917
 8099 011c CCF10F0C 		rsb	ip, ip, #15
 8100              	.LVL867:
3130:ff.c          **** 		cc = f_puts(&s[i], fil);
 8101              		.loc 1 3130 3 is_stmt 1 view .LVU2918
 8102              	.L654:
3130:ff.c          **** 		cc = f_puts(&s[i], fil);
 8103              		.loc 1 3130 9 discriminator 5 view .LVU2919
 8104 0120 08B1     		cbz	r0, .L655
3130:ff.c          **** 		cc = f_puts(&s[i], fil);
 8105              		.loc 1 3130 12 is_stmt 0 discriminator 6 view .LVU2920
 8106 0122 6045     		cmp	r0, ip
 8107 0124 08DC     		bgt	.L656
 8108              	.L655:
3131:ff.c          **** 	}
 8109              		.loc 1 3131 3 is_stmt 1 view .LVU2921
3131:ff.c          **** 	}
 8110              		.loc 1 3131 8 is_stmt 0 view .LVU2922
 8111 0126 4146     		mov	r1, r8
 8112 0128 2844     		add	r0, r0, r5
 8113              	.LVL868:
3131:ff.c          **** 	}
 8114              		.loc 1 3131 8 view .LVU2923
 8115 012a AEE7     		b	.L680
 8116              	.LVL869:
 8117              	.L662:
3105:ff.c          **** 		if (c == 'u') r = 10;		/* Type is unsigned decimal */
 8118              		.loc 1 3105 19 view .LVU2924
 8119 012c 4FF00A0E 		mov	lr, #10
 8120 0130 C1E7     		b	.L645
 8121              	.LVL870:
 8122              	.L663:
3105:ff.c          **** 		if (c == 'u') r = 10;		/* Type is unsigned decimal */
 8123              		.loc 1 3105 19 view .LVU2925
 8124 0132 8146     		mov	r9, r0
3126:ff.c          **** 		} while (i && val);
 8125              		.loc 1 3126 8 view .LVU2926
 8126 0134 5146     		mov	r1, r10
 8127 0136 CDE7     		b	.L652
 8128              	.LVL871:
 8129              	.L656:
3130:ff.c          **** 		cc = f_puts(&s[i], fil);
 8130              		.loc 1 3130 22 is_stmt 1 discriminator 4 view .LVU2927
3130:ff.c          **** 		cc = f_puts(&s[i], fil);
 8131              		.loc 1 3130 29 is_stmt 0 discriminator 4 view .LVU2928
 8132 0138 0138     		subs	r0, r0, #1
 8133              	.LVL872:
3130:ff.c          **** 		cc = f_puts(&s[i], fil);
 8134              		.loc 1 3130 29 discriminator 4 view .LVU2929
 8135 013a 2B54     		strb	r3, [r5, r0]
 8136 013c F0E7     		b	.L654
 8137              		.cfi_endproc
 8138              	.LFE74:
 8140              		.section	.bss.Drive,"aw",%nobits
 8141              		.set	.LANCHOR1,. + 0
 8144              	Drive:
 8145 0000 00       		.space	1
 8146              		.section	.bss.FatFs,"aw",%nobits
 8147              		.align	2
 8148              		.set	.LANCHOR2,. + 0
 8151              	FatFs:
 8152 0000 00000000 		.space	4
 8153              		.section	.bss.Fsid,"aw",%nobits
 8154              		.align	1
 8155              		.set	.LANCHOR3,. + 0
 8158              	Fsid:
 8159 0000 0000     		.space	2
 8160              		.section	.rodata.fatstr.7068,"a"
 8161              		.set	.LANCHOR0,. + 0
 8164              	fatstr.7068:
 8165 0000 46415400 		.ascii	"FAT\000"
 8166              		.text
 8167              	.Letext0:
 8168              		.file 2 "c:\\project\\stm32fx_lib\\stm32f1x_iolib\\include\\core.h"
 8169              		.file 3 "/project/stm32fx_lib/stm32f1x_iolib/include/cmsis/stm32f1xx.h"
 8170              		.file 4 "userdefs.h"
 8171              		.file 5 "ff.h"
 8172              		.file 6 "diskio.h"
 8173              		.file 7 "c:\\program files (x86)\\gnu tools arm embedded\\9 2019-q4-major\\lib\\gcc\\arm-none-eabi
 8174              		.file 8 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:00000000 ff.c
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:16     .text.mem_cpy:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:23     .text.mem_cpy:00000000 mem_cpy
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:60     .text.mem_cmp:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:66     .text.mem_cmp:00000000 mem_cmp
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:119    .text.clust2sect:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:125    .text.clust2sect:00000000 clust2sect
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:161    .text.get_fileinfo:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:167    .text.get_fileinfo:00000000 get_fileinfo
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:344    .text.validate:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:350    .text.validate:00000000 validate
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:408    .text.check_fs:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:414    .text.check_fs:00000000 check_fs
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:508    .text.check_fs:0000005c $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:515    .text.auto_mount:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:521    .text.auto_mount:00000000 auto_mount
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:964    .text.auto_mount:000001c0 $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:972    .text.move_window:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:978    .text.move_window:00000000 move_window
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1123   .text.get_fat:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1129   .text.get_fat:00000000 get_fat
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1324   .text.dir_seek:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1330   .text.dir_seek:00000000 dir_seek
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1495   .text.put_fat:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1501   .text.put_fat:00000000 put_fat
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1740   .text.create_chain:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1746   .text.create_chain:00000000 create_chain
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1936   .text.dir_next:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:1942   .text.dir_next:00000000 dir_next
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2233   .text.dir_read:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2239   .text.dir_read:00000000 dir_read
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2343   .text.remove_chain:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2349   .text.remove_chain:00000000 remove_chain
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2479   .text.dir_remove:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2485   .text.dir_remove:00000000 dir_remove
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2551   .text.dir_register:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2557   .text.dir_register:00000000 dir_register
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2718   .text.follow_path:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:2724   .text.follow_path:00000000 follow_path
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3367   .text.follow_path:00000218 $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3374   .text.sync:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3380   .text.sync:00000000 sync
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3529   .text.sync:00000074 $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3538   .text.f_mount:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3545   .text.f_mount:00000000 f_mount
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3595   .text.f_mount:00000018 $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3600   .text.f_open:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3607   .text.f_open:00000000 f_open
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3972   .text.f_read:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:3979   .text.f_read:00000000 f_read
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:4368   .text.f_write:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:4375   .text.f_write:00000000 f_write
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:4809   .text.f_sync:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:4816   .text.f_sync:00000000 f_sync
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:4990   .text.f_close:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:4997   .text.f_close:00000000 f_close
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5031   .text.f_chdrive:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5038   .text.f_chdrive:00000000 f_chdrive
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5065   .text.f_chdrive:0000000c $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5070   .text.f_chdir:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5077   .text.f_chdir:00000000 f_chdir
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5193   .text.f_lseek:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5200   .text.f_lseek:00000000 f_lseek
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5571   .text.f_opendir:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5578   .text.f_opendir:00000000 f_opendir
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5701   .text.f_readdir:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5708   .text.f_readdir:00000000 f_readdir
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5821   .text.f_stat:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5828   .text.f_stat:00000000 f_stat
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5910   .text.f_getfree:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:5917   .text.f_getfree:00000000 f_getfree
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:6175   .text.f_truncate:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:6182   .text.f_truncate:00000000 f_truncate
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:6340   .text.f_unlink:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:6347   .text.f_unlink:00000000 f_unlink
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:6555   .text.f_mkdir:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:6562   .text.f_mkdir:00000000 f_mkdir
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7023   .text.f_chmod:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7030   .text.f_chmod:00000000 f_chmod
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7143   .text.f_utime:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7150   .text.f_utime:00000000 f_utime
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7260   .text.f_rename:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7267   .text.f_rename:00000000 f_rename
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7535   .text.f_gets:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7542   .text.f_gets:00000000 f_gets
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7623   .text.f_putc:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7630   .text.f_putc:00000000 f_putc
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7689   .text.f_puts:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7696   .text.f_puts:00000000 f_puts
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7748   .text.f_printf:00000000 $t
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:7755   .text.f_printf:00000000 f_printf
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:8144   .bss.Drive:00000000 Drive
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:8145   .bss.Drive:00000000 $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:8147   .bss.FatFs:00000000 $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:8151   .bss.FatFs:00000000 FatFs
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:8154   .bss.Fsid:00000000 $d
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:8158   .bss.Fsid:00000000 Fsid
C:\Users\gowoo\AppData\Local\Temp\cctNr6Hu.s:8164   .rodata.fatstr.7068:00000000 fatstr.7068

UNDEFINED SYMBOLS
disk_status
disk_read
disk_initialize
disk_write
disk_ioctl
get_fattime
